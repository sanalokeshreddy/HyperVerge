{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-symbol%401.1.0/node_modules/micromark-util-symbol/constants.js"],"sourcesContent":["/**\n * This module is compiled away!\n *\n * Parsing markdown comes with a couple of constants, such as minimum or maximum\n * sizes of certain sequences.\n * Additionally, there are a couple symbols used inside micromark.\n * These are all defined here, but compiled away by scripts.\n */\nexport const constants = /** @type {const} */ ({\n  attentionSideBefore: 1, // Symbol to mark an attention sequence as before content: `*a`\n  attentionSideAfter: 2, // Symbol to mark an attention sequence as after content: `a*`\n  atxHeadingOpeningFenceSizeMax: 6, // 6 number signs is fine, 7 isnâ€™t.\n  autolinkDomainSizeMax: 63, // 63 characters is fine, 64 is too many.\n  autolinkSchemeSizeMax: 32, // 32 characters is fine, 33 is too many.\n  cdataOpeningString: 'CDATA[', // And preceded by `<![`.\n  characterGroupWhitespace: 1, // Symbol used to indicate a character is whitespace\n  characterGroupPunctuation: 2, // Symbol used to indicate a character is punctuation\n  characterReferenceDecimalSizeMax: 7, // `&#9999999;`.\n  characterReferenceHexadecimalSizeMax: 6, // `&#xff9999;`.\n  characterReferenceNamedSizeMax: 31, // `&CounterClockwiseContourIntegral;`.\n  codeFencedSequenceSizeMin: 3, // At least 3 ticks or tildes are needed.\n  contentTypeDocument: 'document',\n  contentTypeFlow: 'flow',\n  contentTypeContent: 'content',\n  contentTypeString: 'string',\n  contentTypeText: 'text',\n  hardBreakPrefixSizeMin: 2, // At least 2 trailing spaces are needed.\n  htmlRaw: 1, // Symbol for `<script>`\n  htmlComment: 2, // Symbol for `<!---->`\n  htmlInstruction: 3, // Symbol for `<?php?>`\n  htmlDeclaration: 4, // Symbol for `<!doctype>`\n  htmlCdata: 5, // Symbol for `<![CDATA[]]>`\n  htmlBasic: 6, // Symbol for `<div`\n  htmlComplete: 7, // Symbol for `<x>`\n  htmlRawSizeMax: 8, // Length of `textarea`.\n  linkResourceDestinationBalanceMax: 32, // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>\n  linkReferenceSizeMax: 999, // See: <https://spec.commonmark.org/0.30/#link-label>\n  listItemValueSizeMax: 10, // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>\n  numericBaseDecimal: 10,\n  numericBaseHexadecimal: 0x10,\n  tabSize: 4, // Tabs have a hard-coded size of 4, per CommonMark.\n  thematicBreakMarkerCountMin: 3, // At least 3 asterisks, dashes, or underscores are needed.\n  v8MaxSafeChunkSize: 10000 // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.\n})\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;AACM,MAAM,YAAkC;IAC7C,qBAAqB;IACrB,oBAAoB;IACpB,+BAA+B;IAC/B,uBAAuB;IACvB,uBAAuB;IACvB,oBAAoB;IACpB,0BAA0B;IAC1B,2BAA2B;IAC3B,kCAAkC;IAClC,sCAAsC;IACtC,gCAAgC;IAChC,2BAA2B;IAC3B,qBAAqB;IACrB,iBAAiB;IACjB,oBAAoB;IACpB,mBAAmB;IACnB,iBAAiB;IACjB,wBAAwB;IACxB,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,iBAAiB;IACjB,WAAW;IACX,WAAW;IACX,cAAc;IACd,gBAAgB;IAChB,mCAAmC;IACnC,sBAAsB;IACtB,sBAAsB;IACtB,oBAAoB;IACpB,wBAAwB;IACxB,SAAS;IACT,6BAA6B;IAC7B,oBAAoB,MAAM,kHAAkH;AAC9I","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-chunked%401.1.0/node_modules/micromark-util-chunked/dev/index.js"],"sourcesContent":["import {constants} from 'micromark-util-symbol/constants.js'\n\n/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {void}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if thereâ€™s only a couple (10k) items.\n  if (items.length < constants.v8MaxSafeChunkSize) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, itâ€™s fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(\n        chunkStart,\n        chunkStart + constants.v8MaxSafeChunkSize\n      )\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, itâ€™s fine.\n      list.splice(...parameters)\n\n      chunkStart += constants.v8MaxSafeChunkSize\n      start += constants.v8MaxSafeChunkSize\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n\n  return items\n}\n"],"names":[],"mappings":";;;;AAAA;;AAwBO,SAAS,OAAO,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK;IAC/C,MAAM,MAAM,KAAK,MAAM;IACvB,IAAI,aAAa;IACjB,2BAA2B,GAC3B,IAAI;IAEJ,gDAAgD;IAChD,IAAI,QAAQ,GAAG;QACb,QAAQ,CAAC,QAAQ,MAAM,IAAI,MAAM;IACnC,OAAO;QACL,QAAQ,QAAQ,MAAM,MAAM;IAC9B;IAEA,SAAS,SAAS,IAAI,SAAS;IAE/B,mEAAmE;IACnE,IAAI,MAAM,MAAM,GAAG,mOAAA,CAAA,YAAS,CAAC,kBAAkB,EAAE;QAC/C,aAAa,MAAM,IAAI,CAAC;QACxB,WAAW,OAAO,CAAC,OAAO;QAC1B,oCAAoC;QACpC,KAAK,MAAM,IAAI;IACjB,OAAO;QACL,8CAA8C;QAC9C,IAAI,QAAQ,KAAK,MAAM,CAAC,OAAO;QAE/B,2DAA2D;QAC3D,MAAO,aAAa,MAAM,MAAM,CAAE;YAChC,aAAa,MAAM,KAAK,CACtB,YACA,aAAa,mOAAA,CAAA,YAAS,CAAC,kBAAkB;YAE3C,WAAW,OAAO,CAAC,OAAO;YAC1B,oCAAoC;YACpC,KAAK,MAAM,IAAI;YAEf,cAAc,mOAAA,CAAA,YAAS,CAAC,kBAAkB;YAC1C,SAAS,mOAAA,CAAA,YAAS,CAAC,kBAAkB;QACvC;IACF;AACF;AAkBO,SAAS,KAAK,IAAI,EAAE,KAAK;IAC9B,IAAI,KAAK,MAAM,GAAG,GAAG;QACnB,OAAO,MAAM,KAAK,MAAM,EAAE,GAAG;QAC7B,OAAO;IACT;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-combine-extensions%401.1.0/node_modules/micromark-util-combine-extensions/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Handles} Handles\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine multiple syntax extensions into one.\n *\n * @param {Array<Extension>} extensions\n *   List of syntax extensions.\n * @returns {NormalizedExtension}\n *   A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all\n *   Extension to merge into.\n * @param {Extension} extension\n *   Extension to merge.\n * @returns {void}\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {keyof Extension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    /** @type {Record<string, unknown>} */\n    const left = maybe || (all[hook] = {})\n    /** @type {Record<string, unknown> | undefined} */\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    if (right) {\n      for (code in right) {\n        if (!hasOwnProperty.call(left, code)) left[code] = []\n        const value = right[code]\n        constructs(\n          // @ts-expect-error Looks like a list.\n          left[code],\n          Array.isArray(value) ? value : value ? [value] : []\n        )\n      }\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {Array<unknown>} existing\n * @param {Array<unknown>} list\n * @returns {void}\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {Array<unknown>} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine multiple HTML extensions into one.\n *\n * @param {Array<HtmlExtension>} htmlExtensions\n *   List of HTML extensions.\n * @returns {HtmlExtension}\n *   A single combined HTML extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all\n *   Extension to merge into.\n * @param {HtmlExtension} extension\n *   Extension to merge.\n * @returns {void}\n */\nfunction htmlExtension(all, extension) {\n  /** @type {keyof HtmlExtension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {keyof Handles} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        // @ts-expect-error assume document vs regular handler are managed correctly.\n        left[type] = right[type]\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;;AAEA,MAAM,iBAAiB,CAAC,EAAE,cAAc;AAUjC,SAAS,kBAAkB,UAAU;IAC1C,gCAAgC,GAChC,MAAM,MAAM,CAAC;IACb,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,WAAW,MAAM,CAAE;QAClC,gBAAgB,KAAK,UAAU,CAAC,MAAM;IACxC;IAEA,OAAO;AACT;AAEA;;;;;;;;CAQC,GACD,SAAS,gBAAgB,GAAG,EAAE,SAAS;IACrC,4BAA4B,GAC5B,IAAI;IAEJ,IAAK,QAAQ,UAAW;QACtB,MAAM,QAAQ,eAAe,IAAI,CAAC,KAAK,QAAQ,GAAG,CAAC,KAAK,GAAG;QAC3D,oCAAoC,GACpC,MAAM,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC;QACrC,gDAAgD,GAChD,MAAM,QAAQ,SAAS,CAAC,KAAK;QAC7B,mBAAmB,GACnB,IAAI;QAEJ,IAAI,OAAO;YACT,IAAK,QAAQ,MAAO;gBAClB,IAAI,CAAC,eAAe,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,KAAK,GAAG,EAAE;gBACrD,MAAM,QAAQ,KAAK,CAAC,KAAK;gBACzB,WACE,sCAAsC;gBACtC,IAAI,CAAC,KAAK,EACV,MAAM,OAAO,CAAC,SAAS,QAAQ,QAAQ;oBAAC;iBAAM,GAAG,EAAE;YAEvD;QACF;IACF;AACF;AAEA;;;;;;;CAOC,GACD,SAAS,WAAW,QAAQ,EAAE,IAAI;IAChC,IAAI,QAAQ,CAAC;IACb,2BAA2B,GAC3B,MAAM,SAAS,EAAE;IAEjB,MAAO,EAAE,QAAQ,KAAK,MAAM,CAAE;QAC5B,yCAAyC;;QACxC,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,KAAK,UAAU,WAAW,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM;IACrE;IAEA,CAAA,GAAA,wOAAA,CAAA,SAAM,AAAD,EAAE,UAAU,GAAG,GAAG;AACzB;AAUO,SAAS,sBAAsB,cAAc;IAClD,0BAA0B,GAC1B,MAAM,WAAW,CAAC;IAClB,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,eAAe,MAAM,CAAE;QACtC,cAAc,UAAU,cAAc,CAAC,MAAM;IAC/C;IAEA,OAAO;AACT;AAEA;;;;;;;;CAQC,GACD,SAAS,cAAc,GAAG,EAAE,SAAS;IACnC,gCAAgC,GAChC,IAAI;IAEJ,IAAK,QAAQ,UAAW;QACtB,MAAM,QAAQ,eAAe,IAAI,CAAC,KAAK,QAAQ,GAAG,CAAC,KAAK,GAAG;QAC3D,MAAM,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC;QACrC,MAAM,QAAQ,SAAS,CAAC,KAAK;QAC7B,0BAA0B,GAC1B,IAAI;QAEJ,IAAI,OAAO;YACT,IAAK,QAAQ,MAAO;gBAClB,6EAA6E;gBAC7E,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK;YAC1B;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-symbol%401.1.0/node_modules/micromark-util-symbol/codes.js"],"sourcesContent":["/**\n * Character codes.\n *\n * This module is compiled away!\n *\n * micromark works based on character codes.\n * This module contains constants for the ASCII block and the replacement\n * character.\n * A couple of them are handled in a special way, such as the line endings\n * (CR, LF, and CR+LF, commonly known as end-of-line: EOLs), the tab (horizontal\n * tab) and its expansion based on what column itâ€™s at (virtual space),\n * and the end-of-file (eof) character.\n * As values are preprocessed before handling them, the actual characters LF,\n * CR, HT, and NUL (which is present as the replacement character), are\n * guaranteed to not exist.\n *\n * Unicode basic latin block.\n */\nexport const codes = /** @type {const} */ ({\n  carriageReturn: -5,\n  lineFeed: -4,\n  carriageReturnLineFeed: -3,\n  horizontalTab: -2,\n  virtualSpace: -1,\n  eof: null,\n  nul: 0,\n  soh: 1,\n  stx: 2,\n  etx: 3,\n  eot: 4,\n  enq: 5,\n  ack: 6,\n  bel: 7,\n  bs: 8,\n  ht: 9, // `\\t`\n  lf: 10, // `\\n`\n  vt: 11, // `\\v`\n  ff: 12, // `\\f`\n  cr: 13, // `\\r`\n  so: 14,\n  si: 15,\n  dle: 16,\n  dc1: 17,\n  dc2: 18,\n  dc3: 19,\n  dc4: 20,\n  nak: 21,\n  syn: 22,\n  etb: 23,\n  can: 24,\n  em: 25,\n  sub: 26,\n  esc: 27,\n  fs: 28,\n  gs: 29,\n  rs: 30,\n  us: 31,\n  space: 32,\n  exclamationMark: 33, // `!`\n  quotationMark: 34, // `\"`\n  numberSign: 35, // `#`\n  dollarSign: 36, // `$`\n  percentSign: 37, // `%`\n  ampersand: 38, // `&`\n  apostrophe: 39, // `'`\n  leftParenthesis: 40, // `(`\n  rightParenthesis: 41, // `)`\n  asterisk: 42, // `*`\n  plusSign: 43, // `+`\n  comma: 44, // `,`\n  dash: 45, // `-`\n  dot: 46, // `.`\n  slash: 47, // `/`\n  digit0: 48, // `0`\n  digit1: 49, // `1`\n  digit2: 50, // `2`\n  digit3: 51, // `3`\n  digit4: 52, // `4`\n  digit5: 53, // `5`\n  digit6: 54, // `6`\n  digit7: 55, // `7`\n  digit8: 56, // `8`\n  digit9: 57, // `9`\n  colon: 58, // `:`\n  semicolon: 59, // `;`\n  lessThan: 60, // `<`\n  equalsTo: 61, // `=`\n  greaterThan: 62, // `>`\n  questionMark: 63, // `?`\n  atSign: 64, // `@`\n  uppercaseA: 65, // `A`\n  uppercaseB: 66, // `B`\n  uppercaseC: 67, // `C`\n  uppercaseD: 68, // `D`\n  uppercaseE: 69, // `E`\n  uppercaseF: 70, // `F`\n  uppercaseG: 71, // `G`\n  uppercaseH: 72, // `H`\n  uppercaseI: 73, // `I`\n  uppercaseJ: 74, // `J`\n  uppercaseK: 75, // `K`\n  uppercaseL: 76, // `L`\n  uppercaseM: 77, // `M`\n  uppercaseN: 78, // `N`\n  uppercaseO: 79, // `O`\n  uppercaseP: 80, // `P`\n  uppercaseQ: 81, // `Q`\n  uppercaseR: 82, // `R`\n  uppercaseS: 83, // `S`\n  uppercaseT: 84, // `T`\n  uppercaseU: 85, // `U`\n  uppercaseV: 86, // `V`\n  uppercaseW: 87, // `W`\n  uppercaseX: 88, // `X`\n  uppercaseY: 89, // `Y`\n  uppercaseZ: 90, // `Z`\n  leftSquareBracket: 91, // `[`\n  backslash: 92, // `\\`\n  rightSquareBracket: 93, // `]`\n  caret: 94, // `^`\n  underscore: 95, // `_`\n  graveAccent: 96, // `` ` ``\n  lowercaseA: 97, // `a`\n  lowercaseB: 98, // `b`\n  lowercaseC: 99, // `c`\n  lowercaseD: 100, // `d`\n  lowercaseE: 101, // `e`\n  lowercaseF: 102, // `f`\n  lowercaseG: 103, // `g`\n  lowercaseH: 104, // `h`\n  lowercaseI: 105, // `i`\n  lowercaseJ: 106, // `j`\n  lowercaseK: 107, // `k`\n  lowercaseL: 108, // `l`\n  lowercaseM: 109, // `m`\n  lowercaseN: 110, // `n`\n  lowercaseO: 111, // `o`\n  lowercaseP: 112, // `p`\n  lowercaseQ: 113, // `q`\n  lowercaseR: 114, // `r`\n  lowercaseS: 115, // `s`\n  lowercaseT: 116, // `t`\n  lowercaseU: 117, // `u`\n  lowercaseV: 118, // `v`\n  lowercaseW: 119, // `w`\n  lowercaseX: 120, // `x`\n  lowercaseY: 121, // `y`\n  lowercaseZ: 122, // `z`\n  leftCurlyBrace: 123, // `{`\n  verticalBar: 124, // `|`\n  rightCurlyBrace: 125, // `}`\n  tilde: 126, // `~`\n  del: 127,\n  // Unicode Specials block.\n  byteOrderMarker: 65279,\n  // Unicode Specials block.\n  replacementCharacter: 65533 // `ï¿½`\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;CAiBC;;;AACM,MAAM,QAA8B;IACzC,gBAAgB,CAAC;IACjB,UAAU,CAAC;IACX,wBAAwB,CAAC;IACzB,eAAe,CAAC;IAChB,cAAc,CAAC;IACf,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,IAAI;IACJ,KAAK;IACL,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,OAAO;IACP,iBAAiB;IACjB,eAAe;IACf,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,WAAW;IACX,YAAY;IACZ,iBAAiB;IACjB,kBAAkB;IAClB,UAAU;IACV,UAAU;IACV,OAAO;IACP,MAAM;IACN,KAAK;IACL,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,WAAW;IACX,UAAU;IACV,UAAU;IACV,aAAa;IACb,cAAc;IACd,QAAQ;IACR,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,OAAO;IACP,YAAY;IACZ,aAAa;IACb,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,gBAAgB;IAChB,aAAa;IACb,iBAAiB;IACjB,OAAO;IACP,KAAK;IACL,0BAA0B;IAC1B,iBAAiB;IACjB,0BAA0B;IAC1B,sBAAsB,MAAM,MAAM;AACpC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 366, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-character%401.2.0/node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js"],"sourcesContent":["// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n"],"names":[],"mappings":"AAAA,yCAAyC;AACzC,EAAE;AACF,8EAA8E;AAC9E,wBAAwB;AACxB,sEAAsE;AACtE,kDAAkD;AAElD;;CAEC;;;AACM,MAAM,0BACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-character%401.2.0/node_modules/micromark-util-character/dev/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < codes.space || code === codes.del)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < codes.horizontalTab\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < codes.nul || code === codes.space)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return (\n    code === codes.horizontalTab ||\n    code === codes.virtualSpace ||\n    code === codes.space\n  )\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;;;AAED;AACA;;;AAmBO,MAAM,aAAa,WAAW;AAc9B,MAAM,oBAAoB,WAAW;AAuBrC,MAAM,aAAa,WAAW;AAa9B,SAAS,aAAa,IAAI;IAC/B,OACE,wEAAwE;IACxE,gBAAgB;IAChB,SAAS,QAAQ,CAAC,OAAO,+NAAA,CAAA,QAAK,CAAC,KAAK,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG;AAE9D;AAaO,MAAM,aAAa,WAAW;AAoB9B,MAAM,gBAAgB,WAAW;AAejC,MAAM,mBAAmB,WAAW;AAiBpC,SAAS,mBAAmB,IAAI;IACrC,OAAO,SAAS,QAAQ,OAAO,+NAAA,CAAA,QAAK,CAAC,aAAa;AACpD;AAWO,SAAS,0BAA0B,IAAI;IAC5C,OAAO,SAAS,QAAQ,CAAC,OAAO,+NAAA,CAAA,QAAK,CAAC,GAAG,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK;AACnE;AAiBO,SAAS,cAAc,IAAI;IAChC,OACE,SAAS,+NAAA,CAAA,QAAK,CAAC,aAAa,IAC5B,SAAS,+NAAA,CAAA,QAAK,CAAC,YAAY,IAC3B,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK;AAExB;AAuBO,MAAM,qBAAqB,WAAW,6QAAA,CAAA,0BAAuB;AAsB7D,MAAM,oBAAoB,WAAW;AAE5C;;;;;CAKC,GACD,SAAS,WAAW,KAAK;IACvB,OAAO;;;IAEP;;;;;;;GAOC,GACD,SAAS,MAAM,IAAI;QACjB,OAAO,SAAS,QAAQ,MAAM,IAAI,CAAC,OAAO,YAAY,CAAC;IACzD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 448, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-autolink-literal%401.0.5/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\n\nconst wwwPrefix = {tokenize: tokenizeWwwPrefix, partial: true}\nconst domain = {tokenize: tokenizeDomain, partial: true}\nconst path = {tokenize: tokenizePath, partial: true}\nconst trail = {tokenize: tokenizeTrail, partial: true}\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n}\n\nconst wwwAutolink = {tokenize: tokenizeWwwAutolink, previous: previousWww}\nconst protocolAutolink = {\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n}\nconst emailAutolink = {tokenize: tokenizeEmailAutolink, previous: previousEmail}\n\n/** @type {ConstructRecord} */\nconst text = {}\n\n// To do: next major: expose functions that yields extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * autolink literal syntax.\n *\n * @type {Extension}\n */\nexport const gfmAutolinkLiteral = {text}\n\n/** @type {Code} */\nlet code = codes.digit0\n\n// Add alphanumerics.\nwhile (code < codes.leftCurlyBrace) {\n  text[code] = emailAutolink\n  code++\n  if (code === codes.colon) code = codes.uppercaseA\n  else if (code === codes.leftSquareBracket) code = codes.lowercaseA\n}\n\ntext[codes.plusSign] = emailAutolink\ntext[codes.dash] = emailAutolink\ntext[codes.dot] = emailAutolink\ntext[codes.underscore] = emailAutolink\ntext[codes.uppercaseH] = [emailAutolink, protocolAutolink]\ntext[codes.lowercaseH] = [emailAutolink, protocolAutolink]\ntext[codes.uppercaseW] = [emailAutolink, wwwAutolink]\ntext[codes.lowercaseW] = [emailAutolink, wwwAutolink]\n\n// To do: perform email autolink literals on events, afterwards.\n// Thatâ€™s where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean | undefined} */\n  let dot\n  /** @type {boolean} */\n  let data\n\n  return start\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    if (code === codes.atSign) {\n      effects.consume(code)\n      return emailDomain\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === codes.dot) {\n      return effects.check(\n        emailDomainDotTrail,\n        emailDomainAfter,\n        emailDomainDot\n      )(code)\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (\n      code === codes.dash ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      data = true\n      effects.consume(code)\n      return emailDomain\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally weâ€™d truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isnâ€™t trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code)\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code)\n    dot = true\n    return emailDomain\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n\n  return wwwStart\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (\n      (code !== codes.uppercaseW && code !== codes.lowercaseW) ||\n      !previousWww.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww')\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(\n      wwwPrefix,\n      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),\n      nok\n    )(code)\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this\n  let buffer = ''\n  let seen = false\n\n  return protocolStart\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if (\n      (code === codes.uppercaseH || code === codes.lowercaseH) &&\n      previousProtocol.call(self, self.previous) &&\n      !previousUnbalanced(self.events)\n    ) {\n      effects.enter('literalAutolink')\n      effects.enter('literalAutolinkHttp')\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n\n    if (code === codes.colon) {\n      const protocol = buffer.toLowerCase()\n\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code)\n        return protocolSlashesInside\n      }\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n\n      if (seen) {\n        return afterProtocol\n      }\n\n      seen = true\n      return protocolSlashesInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === codes.eof ||\n      asciiControl(code) ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code)\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0\n\n  return wwwPrefixInside\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === codes.uppercaseW || code === codes.lowercaseW) && size < 3) {\n      size++\n      effects.consume(code)\n      return wwwPrefixInside\n    }\n\n    if (code === codes.dot && size === 3) {\n      effects.consume(code)\n      return wwwPrefixAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === codes.eof ? nok(code) : ok(code)\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment\n  /** @type {boolean | undefined} */\n  let seen\n\n  return domainInside\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === codes.dot || code === codes.underscore) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code)\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.é»žçœ‹.com`,\n    // so thatâ€™s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (\n      code === codes.eof ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code) ||\n      (code !== codes.dash && unicodePunctuation(code))\n    ) {\n      return domainAfter(code)\n    }\n\n    seen = true\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === codes.underscore) {\n      underscoreInLastSegment = true\n    }\n    // Otherwise, itâ€™s a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment\n      underscoreInLastSegment = undefined\n    }\n\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: thatâ€™s GH says a dot is needed, but itâ€™s not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code)\n    }\n\n    return ok(code)\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0\n  let sizeClose = 0\n\n  return pathInside\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === codes.leftParenthesis) {\n      sizeOpen++\n      effects.consume(code)\n      return pathInside\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we donâ€™t check for a trail.\n    if (code === codes.rightParenthesis && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code)\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (\n      code === codes.exclamationMark ||\n      code === codes.quotationMark ||\n      code === codes.ampersand ||\n      code === codes.apostrophe ||\n      code === codes.rightParenthesis ||\n      code === codes.asterisk ||\n      code === codes.comma ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.semicolon ||\n      code === codes.lessThan ||\n      code === codes.questionMark ||\n      code === codes.rightSquareBracket ||\n      code === codes.underscore ||\n      code === codes.tilde\n    ) {\n      return effects.check(trail, ok, pathAtPunctuation)(code)\n    }\n\n    if (\n      code === codes.eof ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n\n    effects.consume(code)\n    return pathInside\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === codes.rightParenthesis) {\n      sizeClose++\n    }\n\n    effects.consume(code)\n    return pathInside\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (\n      code === codes.exclamationMark ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.rightParenthesis ||\n      code === codes.asterisk ||\n      code === codes.comma ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.semicolon ||\n      code === codes.questionMark ||\n      code === codes.underscore ||\n      code === codes.tilde\n    ) {\n      effects.consume(code)\n      return trail\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === codes.ampersand) {\n      effects.consume(code)\n      return trailCharRefStart\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return trailBracketAfter\n    }\n\n    if (\n      // `<` is an end.\n      code === codes.lessThan ||\n      // So is whitespace.\n      code === codes.eof ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * > ðŸ‘‰ **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (\n      code === codes.eof ||\n      code === codes.leftParenthesis ||\n      code === codes.leftSquareBracket ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n\n    return trail(code)\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefStart(code) {\n    // When non-alpha, itâ€™s not a trail.\n    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code)\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === codes.semicolon) {\n      effects.consume(code)\n      return trail\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return trailCharRefInside\n    }\n\n    // Itâ€™s not a trail.\n    return nok(code)\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code)\n    return after\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code)\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return (\n    code === codes.eof ||\n    code === codes.leftParenthesis ||\n    code === codes.asterisk ||\n    code === codes.underscore ||\n    code === codes.leftSquareBracket ||\n    code === codes.rightSquareBracket ||\n    code === codes.tilde ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code)\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash â€œinsideâ€ atext.\n  // The reference code is a bit weird, but thatâ€™s what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === codes.slash || gfmAtext(code))\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return (\n    code === codes.plusSign ||\n    code === codes.dash ||\n    code === codes.dot ||\n    code === codes.underscore ||\n    asciiAlphanumeric(code)\n  )\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n\n  while (index--) {\n    const token = events[index][1]\n\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    }\n\n    // If weâ€™ve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // Mark the last token as â€œwalked intoâ€ w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;AAED;AAQA;;;AAEA,MAAM,YAAY;IAAC,UAAU;IAAmB,SAAS;AAAI;AAC7D,MAAM,SAAS;IAAC,UAAU;IAAgB,SAAS;AAAI;AACvD,MAAM,OAAO;IAAC,UAAU;IAAc,SAAS;AAAI;AACnD,MAAM,QAAQ;IAAC,UAAU;IAAe,SAAS;AAAI;AACrD,MAAM,sBAAsB;IAC1B,UAAU;IACV,SAAS;AACX;AAEA,MAAM,cAAc;IAAC,UAAU;IAAqB,UAAU;AAAW;AACzE,MAAM,mBAAmB;IACvB,UAAU;IACV,UAAU;AACZ;AACA,MAAM,gBAAgB;IAAC,UAAU;IAAuB,UAAU;AAAa;AAE/E,4BAA4B,GAC5B,MAAM,OAAO,CAAC;AAUP,MAAM,qBAAqB;IAAC;AAAI;AAEvC,iBAAiB,GACjB,IAAI,OAAO,+NAAA,CAAA,QAAK,CAAC,MAAM;AAEvB,qBAAqB;AACrB,MAAO,OAAO,+NAAA,CAAA,QAAK,CAAC,cAAc,CAAE;IAClC,IAAI,CAAC,KAAK,GAAG;IACb;IACA,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,EAAE,OAAO,+NAAA,CAAA,QAAK,CAAC,UAAU;SAC5C,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,iBAAiB,EAAE,OAAO,+NAAA,CAAA,QAAK,CAAC,UAAU;AACpE;AAEA,IAAI,CAAC,+NAAA,CAAA,QAAK,CAAC,QAAQ,CAAC,GAAG;AACvB,IAAI,CAAC,+NAAA,CAAA,QAAK,CAAC,IAAI,CAAC,GAAG;AACnB,IAAI,CAAC,+NAAA,CAAA,QAAK,CAAC,GAAG,CAAC,GAAG;AAClB,IAAI,CAAC,+NAAA,CAAA,QAAK,CAAC,UAAU,CAAC,GAAG;AACzB,IAAI,CAAC,+NAAA,CAAA,QAAK,CAAC,UAAU,CAAC,GAAG;IAAC;IAAe;CAAiB;AAC1D,IAAI,CAAC,+NAAA,CAAA,QAAK,CAAC,UAAU,CAAC,GAAG;IAAC;IAAe;CAAiB;AAC1D,IAAI,CAAC,+NAAA,CAAA,QAAK,CAAC,UAAU,CAAC,GAAG;IAAC;IAAe;CAAY;AACrD,IAAI,CAAC,+NAAA,CAAA,QAAK,CAAC,UAAU,CAAC,GAAG;IAAC;IAAe;CAAY;AAErD,gEAAgE;AAChE,yDAAyD;AACzD,yEAAyE;AACzE,YAAY;AACZ,gDAAgD;AAEhD;;;;;;;;;;CAUC,GACD,SAAS,sBAAsB,OAAO,EAAE,EAAE,EAAE,GAAG;IAC7C,MAAM,OAAO,IAAI;IACjB,gCAAgC,GAChC,IAAI;IACJ,oBAAoB,GACpB,IAAI;IAEJ,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,MAAM,IAAI;QACjB,IACE,CAAC,SAAS,SACV,CAAC,cAAc,IAAI,CAAC,MAAM,KAAK,QAAQ,KACvC,mBAAmB,KAAK,MAAM,GAC9B;YACA,OAAO,IAAI;QACb;QAEA,QAAQ,KAAK,CAAC;QACd,QAAQ,KAAK,CAAC;QACd,OAAO,MAAM;IACf;IAEA;;;;;;;;;GASC,GACD,SAAS,MAAM,IAAI;QACjB,IAAI,SAAS,OAAO;YAClB,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,MAAM,EAAE;YACzB,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;GAaC,GACD,SAAS,YAAY,IAAI;QACvB,mDAAmD;QACnD,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,EAAE;YACtB,OAAO,QAAQ,KAAK,CAClB,qBACA,kBACA,gBACA;QACJ;QAEA,gCAAgC;QAChC,IACE,SAAS,+NAAA,CAAA,QAAK,CAAC,IAAI,IACnB,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IACzB,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,OAClB;YACA,OAAO;YACP,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,sBAAsB;QAEtB,mEAAmE;QACnE,wEAAwE;QACxE,gEAAgE;QAChE,+BAA+B;QAC/B,OAAO,iBAAiB;IAC1B;IAEA;;;;;;;;;GASC,GACD,SAAS,eAAe,IAAI;QAC1B,QAAQ,OAAO,CAAC;QAChB,MAAM;QACN,OAAO;IACT;IAEA;;;;;;;;;GASC,GACD,SAAS,iBAAiB,IAAI;QAC5B,8EAA8E;QAC9E,yFAAyF;QACzF,IAAI,QAAQ,OAAO,CAAA,GAAA,4OAAA,CAAA,aAAU,AAAD,EAAE,KAAK,QAAQ,GAAG;YAC5C,QAAQ,IAAI,CAAC;YACb,QAAQ,IAAI,CAAC;YACb,OAAO,GAAG;QACZ;QAEA,OAAO,IAAI;IACb;AACF;AAEA;;;;;;;;;;CAUC,GACD,SAAS,oBAAoB,OAAO,EAAE,EAAE,EAAE,GAAG;IAC3C,MAAM,OAAO,IAAI;IAEjB,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,SAAS,IAAI;QACpB,IACE,AAAC,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IACvD,CAAC,YAAY,IAAI,CAAC,MAAM,KAAK,QAAQ,KACrC,mBAAmB,KAAK,MAAM,GAC9B;YACA,OAAO,IAAI;QACb;QAEA,QAAQ,KAAK,CAAC;QACd,QAAQ,KAAK,CAAC;QACd,4DAA4D;QAC5D,wDAAwD;QACxD,OAAO,QAAQ,KAAK,CAClB,WACA,QAAQ,OAAO,CAAC,QAAQ,QAAQ,OAAO,CAAC,MAAM,WAAW,MACzD,KACA;IACJ;IAEA;;;;;;;;;GASC,GACD,SAAS,SAAS,IAAI;QACpB,QAAQ,IAAI,CAAC;QACb,QAAQ,IAAI,CAAC;QACb,OAAO,GAAG;IACZ;AACF;AAEA;;;;;;;;;;CAUC,GACD,SAAS,yBAAyB,OAAO,EAAE,EAAE,EAAE,GAAG;IAChD,MAAM,OAAO,IAAI;IACjB,IAAI,SAAS;IACb,IAAI,OAAO;IAEX,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,cAAc,IAAI;QACzB,IACE,CAAC,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,KACvD,iBAAiB,IAAI,CAAC,MAAM,KAAK,QAAQ,KACzC,CAAC,mBAAmB,KAAK,MAAM,GAC/B;YACA,QAAQ,KAAK,CAAC;YACd,QAAQ,KAAK,CAAC;YACd,UAAU,OAAO,aAAa,CAAC;YAC/B,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,OAAO,IAAI;IACb;IAEA;;;;;;;;;GASC,GACD,SAAS,qBAAqB,IAAI;QAChC,yBAAyB;QACzB,IAAI,CAAA,GAAA,4OAAA,CAAA,aAAU,AAAD,EAAE,SAAS,OAAO,MAAM,GAAG,GAAG;YACzC,uCAAuC;YACvC,UAAU,OAAO,aAAa,CAAC;YAC/B,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,EAAE;YACxB,MAAM,WAAW,OAAO,WAAW;YAEnC,IAAI,aAAa,UAAU,aAAa,SAAS;gBAC/C,QAAQ,OAAO,CAAC;gBAChB,OAAO;YACT;QACF;QAEA,OAAO,IAAI;IACb;IAEA;;;;;;;;;GASC,GACD,SAAS,sBAAsB,IAAI;QACjC,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,EAAE;YACxB,QAAQ,OAAO,CAAC;YAEhB,IAAI,MAAM;gBACR,OAAO;YACT;YAEA,OAAO;YACP,OAAO;QACT;QAEA,OAAO,IAAI;IACb;IAEA;;;;;;;;;GASC,GACD,SAAS,cAAc,IAAI;QACzB,+CAA+C;QAC/C,sIAAsI;QACtI,OAAO,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IACvB,CAAA,GAAA,4OAAA,CAAA,eAAY,AAAD,EAAE,SACb,CAAA,GAAA,4OAAA,CAAA,4BAAyB,AAAD,EAAE,SAC1B,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,SAClB,CAAA,GAAA,4OAAA,CAAA,qBAAkB,AAAD,EAAE,QACjB,IAAI,QACJ,QAAQ,OAAO,CAAC,QAAQ,QAAQ,OAAO,CAAC,MAAM,gBAAgB,KAAK;IACzE;IAEA;;;;;;;;;GASC,GACD,SAAS,cAAc,IAAI;QACzB,QAAQ,IAAI,CAAC;QACb,QAAQ,IAAI,CAAC;QACb,OAAO,GAAG;IACZ;AACF;AAEA;;;;;;;;;;CAUC,GACD,SAAS,kBAAkB,OAAO,EAAE,EAAE,EAAE,GAAG;IACzC,IAAI,OAAO;IAEX,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,gBAAgB,IAAI;QAC3B,IAAI,CAAC,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,KAAK,OAAO,GAAG;YACxE;YACA,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAAI,SAAS,GAAG;YACpC,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,OAAO,IAAI;IACb;IAEA;;;;;;;;;GASC,GACD,SAAS,eAAe,IAAI;QAC1B,uCAAuC;QACvC,OAAO,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,GAAG,IAAI,QAAQ,GAAG;IAC7C;AACF;AAEA;;;;;;;;;;CAUC,GACD,SAAS,eAAe,OAAO,EAAE,EAAE,EAAE,GAAG;IACtC,gCAAgC,GAChC,IAAI;IACJ,gCAAgC,GAChC,IAAI;IACJ,gCAAgC,GAChC,IAAI;IAEJ,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,aAAa,IAAI;QACxB,6DAA6D;QAC7D,iEAAiE;QACjE,sBAAsB;QACtB,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,EAAE;YACnD,OAAO,QAAQ,KAAK,CAAC,OAAO,aAAa,qBAAqB;QAChE;QAEA,0EAA0E;QAC1E,2EAA2E;QAC3E,qBAAqB;QACrB,qEAAqE;QACrE,yEAAyE;QACzE,wFAAwF;QACxF,IACE,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,CAAA,GAAA,4OAAA,CAAA,4BAAyB,AAAD,EAAE,SAC1B,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,SACjB,SAAS,+NAAA,CAAA,QAAK,CAAC,IAAI,IAAI,CAAA,GAAA,4OAAA,CAAA,qBAAkB,AAAD,EAAE,OAC3C;YACA,OAAO,YAAY;QACrB;QAEA,OAAO;QACP,QAAQ,OAAO,CAAC;QAChB,OAAO;IACT;IAEA;;;;;;;;;GASC,GACD,SAAS,oBAAoB,IAAI;QAC/B,2DAA2D;QAC3D,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,EAAE;YAC7B,0BAA0B;QAC5B,OAGK;YACH,8BAA8B;YAC9B,0BAA0B;QAC5B;QAEA,QAAQ,OAAO,CAAC;QAChB,OAAO;IACT;IAEA;;;;;;;;mBAQiB,GACjB,SAAS,YAAY,IAAI;QACvB,2DAA2D;QAC3D,mDAAmD;QACnD,IAAI,+BAA+B,2BAA2B,CAAC,MAAM;YACnE,OAAO,IAAI;QACb;QAEA,OAAO,GAAG;IACZ;AACF;AAEA;;;;;;;;;;CAUC,GACD,SAAS,aAAa,OAAO,EAAE,EAAE;IAC/B,IAAI,WAAW;IACf,IAAI,YAAY;IAEhB,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,WAAW,IAAI;QACtB,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,eAAe,EAAE;YAClC;YACA,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,wCAAwC;QACxC,iEAAiE;QACjE,8BAA8B;QAC9B,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,gBAAgB,IAAI,YAAY,UAAU;YAC3D,OAAO,kBAAkB;QAC3B;QAEA,+DAA+D;QAC/D,uDAAuD;QACvD,aAAa;QACb,IACE,SAAS,+NAAA,CAAA,QAAK,CAAC,eAAe,IAC9B,SAAS,+NAAA,CAAA,QAAK,CAAC,aAAa,IAC5B,SAAS,+NAAA,CAAA,QAAK,CAAC,SAAS,IACxB,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IACzB,SAAS,+NAAA,CAAA,QAAK,CAAC,gBAAgB,IAC/B,SAAS,+NAAA,CAAA,QAAK,CAAC,QAAQ,IACvB,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,IACpB,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,IACpB,SAAS,+NAAA,CAAA,QAAK,CAAC,SAAS,IACxB,SAAS,+NAAA,CAAA,QAAK,CAAC,QAAQ,IACvB,SAAS,+NAAA,CAAA,QAAK,CAAC,YAAY,IAC3B,SAAS,+NAAA,CAAA,QAAK,CAAC,kBAAkB,IACjC,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IACzB,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,EACpB;YACA,OAAO,QAAQ,KAAK,CAAC,OAAO,IAAI,mBAAmB;QACrD;QAEA,IACE,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,CAAA,GAAA,4OAAA,CAAA,4BAAyB,AAAD,EAAE,SAC1B,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,OAClB;YACA,OAAO,GAAG;QACZ;QAEA,QAAQ,OAAO,CAAC;QAChB,OAAO;IACT;IAEA;;;;;;;;;GASC,GACD,SAAS,kBAAkB,IAAI;QAC7B,wBAAwB;QACxB,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,gBAAgB,EAAE;YACnC;QACF;QAEA,QAAQ,OAAO,CAAC;QAChB,OAAO;IACT;AACF;AAEA;;;;;;;;;;;;;;CAcC,GACD,SAAS,cAAc,OAAO,EAAE,EAAE,EAAE,GAAG;IACrC,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,MAAM,IAAI;QACjB,gCAAgC;QAChC,IACE,SAAS,+NAAA,CAAA,QAAK,CAAC,eAAe,IAC9B,SAAS,+NAAA,CAAA,QAAK,CAAC,aAAa,IAC5B,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IACzB,SAAS,+NAAA,CAAA,QAAK,CAAC,gBAAgB,IAC/B,SAAS,+NAAA,CAAA,QAAK,CAAC,QAAQ,IACvB,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,IACpB,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,IACpB,SAAS,+NAAA,CAAA,QAAK,CAAC,SAAS,IACxB,SAAS,+NAAA,CAAA,QAAK,CAAC,YAAY,IAC3B,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IACzB,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,EACpB;YACA,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,+DAA+D;QAC/D,iDAAiD;QACjD,mEAAmE;QACnE,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,SAAS,EAAE;YAC5B,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,yDAAyD;QACzD,oDAAoD;QACpD,+CAA+C;QAC/C,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,kBAAkB,EAAE;YACrC,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,IACE,iBAAiB;QACjB,SAAS,+NAAA,CAAA,QAAK,CAAC,QAAQ,IACvB,oBAAoB;QACpB,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,CAAA,GAAA,4OAAA,CAAA,4BAAyB,AAAD,EAAE,SAC1B,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,OAClB;YACA,OAAO,GAAG;QACZ;QAEA,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;GAYC,GACD,SAAS,kBAAkB,IAAI;QAC7B,+EAA+E;QAC/E,kCAAkC;QAClC,IACE,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,SAAS,+NAAA,CAAA,QAAK,CAAC,eAAe,IAC9B,SAAS,+NAAA,CAAA,QAAK,CAAC,iBAAiB,IAChC,CAAA,GAAA,4OAAA,CAAA,4BAAyB,AAAD,EAAE,SAC1B,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,OAClB;YACA,OAAO,GAAG;QACZ;QAEA,OAAO,MAAM;IACf;IAEA;;;;;;;;;GASC,GACD,SAAS,kBAAkB,IAAI;QAC7B,oCAAoC;QACpC,OAAO,CAAA,GAAA,4OAAA,CAAA,aAAU,AAAD,EAAE,QAAQ,mBAAmB,QAAQ,IAAI;IAC3D;IAEA;;;;;;;;;GASC,GACD,SAAS,mBAAmB,IAAI;QAC9B,+CAA+C;QAC/C,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,SAAS,EAAE;YAC5B,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,IAAI,CAAA,GAAA,4OAAA,CAAA,aAAU,AAAD,EAAE,OAAO;YACpB,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,oBAAoB;QACpB,OAAO,IAAI;IACb;AACF;AAEA;;;;;;;;;;;;;;CAcC,GACD,SAAS,4BAA4B,OAAO,EAAE,EAAE,EAAE,GAAG;IACnD,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,MAAM,IAAI;QACjB,eAAe;QACf,QAAQ,OAAO,CAAC;QAChB,OAAO;IACT;IAEA;;;;;;;;;GASC,GACD,SAAS,MAAM,IAAI;QACjB,+BAA+B;QAC/B,OAAO,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,QAAQ,IAAI,QAAQ,GAAG;IAClD;AACF;AAEA;;;;;CAKC,GACD,SAAS,YAAY,IAAI;IACvB,OACE,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,SAAS,+NAAA,CAAA,QAAK,CAAC,eAAe,IAC9B,SAAS,+NAAA,CAAA,QAAK,CAAC,QAAQ,IACvB,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IACzB,SAAS,+NAAA,CAAA,QAAK,CAAC,iBAAiB,IAChC,SAAS,+NAAA,CAAA,QAAK,CAAC,kBAAkB,IACjC,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,IACpB,CAAA,GAAA,4OAAA,CAAA,4BAAyB,AAAD,EAAE;AAE9B;AAEA;;;;;CAKC,GACD,SAAS,iBAAiB,IAAI;IAC5B,OAAO,CAAC,CAAA,GAAA,4OAAA,CAAA,aAAU,AAAD,EAAE;AACrB;AAEA;;;CAGC,GACD,SAAS,cAAc,IAAI;IACzB,uCAAuC;IACvC,oEAAoE;IACpE,yFAAyF;IACzF,0DAA0D;IAC1D,OAAO,CAAC,CAAC,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,IAAI,SAAS,KAAK;AACjD;AAEA;;;CAGC,GACD,SAAS,SAAS,IAAI;IACpB,OACE,SAAS,+NAAA,CAAA,QAAK,CAAC,QAAQ,IACvB,SAAS,+NAAA,CAAA,QAAK,CAAC,IAAI,IACnB,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IACzB,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE;AAEtB;AAEA;;;CAGC,GACD,SAAS,mBAAmB,MAAM;IAChC,IAAI,QAAQ,OAAO,MAAM;IACzB,IAAI,SAAS;IAEb,MAAO,QAAS;QACd,MAAM,QAAQ,MAAM,CAAC,MAAM,CAAC,EAAE;QAE9B,IACE,CAAC,MAAM,IAAI,KAAK,eAAe,MAAM,IAAI,KAAK,YAAY,KAC1D,CAAC,MAAM,SAAS,EAChB;YACA,SAAS;YACT;QACF;QAEA,2EAA2E;QAC3E,kCAAkC;QAClC,IAAI,MAAM,6BAA6B,EAAE;YACvC,SAAS;YACT;QACF;IACF;IAEA,IAAI,OAAO,MAAM,GAAG,KAAK,CAAC,QAAQ;QAChC,mDAAmD;QACnD,YAAY;QACZ,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,CAAC,EAAE,CAAC,6BAA6B,GAAG;IAC/D;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1230, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-encode%401.1.0/node_modules/micromark-util-encode/index.js"],"sourcesContent":["const characterReferences = {'\"': 'quot', '&': 'amp', '<': 'lt', '>': 'gt'}\n\n/**\n * Encode only the dangerous HTML characters.\n *\n * This ensures that certain characters which have special meaning in HTML are\n * dealt with.\n * Technically, we can skip `>` and `\"` in many cases, but CM includes them.\n *\n * @param {string} value\n *   Value to encode.\n * @returns {string}\n *   Encoded value.\n */\nexport function encode(value) {\n  return value.replace(/[\"&<>]/g, replace)\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  function replace(value) {\n    // @ts-expect-error Hush, itâ€™s fine.\n    return '&' + characterReferences[value] + ';'\n  }\n}\n"],"names":[],"mappings":";;;AAAA,MAAM,sBAAsB;IAAC,KAAK;IAAQ,KAAK;IAAO,KAAK;IAAM,KAAK;AAAI;AAcnE,SAAS,OAAO,KAAK;IAC1B,OAAO,MAAM,OAAO,CAAC,WAAW;;;IAEhC;;;GAGC,GACD,SAAS,QAAQ,KAAK;QACpB,oCAAoC;QACpC,OAAO,MAAM,mBAAmB,CAAC,MAAM,GAAG;IAC5C;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1255, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-symbol%401.1.0/node_modules/micromark-util-symbol/values.js"],"sourcesContent":["/**\n * This module is compiled away!\n *\n * While micromark works based on character codes, this module includes the\n * string versions of â€™em.\n * The C0 block, except for LF, CR, HT, and w/ the replacement character added,\n * are available here.\n */\nexport const values = /** @type {const} */ ({\n  ht: '\\t',\n  lf: '\\n',\n  cr: '\\r',\n  space: ' ',\n  exclamationMark: '!',\n  quotationMark: '\"',\n  numberSign: '#',\n  dollarSign: '$',\n  percentSign: '%',\n  ampersand: '&',\n  apostrophe: \"'\",\n  leftParenthesis: '(',\n  rightParenthesis: ')',\n  asterisk: '*',\n  plusSign: '+',\n  comma: ',',\n  dash: '-',\n  dot: '.',\n  slash: '/',\n  digit0: '0',\n  digit1: '1',\n  digit2: '2',\n  digit3: '3',\n  digit4: '4',\n  digit5: '5',\n  digit6: '6',\n  digit7: '7',\n  digit8: '8',\n  digit9: '9',\n  colon: ':',\n  semicolon: ';',\n  lessThan: '<',\n  equalsTo: '=',\n  greaterThan: '>',\n  questionMark: '?',\n  atSign: '@',\n  uppercaseA: 'A',\n  uppercaseB: 'B',\n  uppercaseC: 'C',\n  uppercaseD: 'D',\n  uppercaseE: 'E',\n  uppercaseF: 'F',\n  uppercaseG: 'G',\n  uppercaseH: 'H',\n  uppercaseI: 'I',\n  uppercaseJ: 'J',\n  uppercaseK: 'K',\n  uppercaseL: 'L',\n  uppercaseM: 'M',\n  uppercaseN: 'N',\n  uppercaseO: 'O',\n  uppercaseP: 'P',\n  uppercaseQ: 'Q',\n  uppercaseR: 'R',\n  uppercaseS: 'S',\n  uppercaseT: 'T',\n  uppercaseU: 'U',\n  uppercaseV: 'V',\n  uppercaseW: 'W',\n  uppercaseX: 'X',\n  uppercaseY: 'Y',\n  uppercaseZ: 'Z',\n  leftSquareBracket: '[',\n  backslash: '\\\\',\n  rightSquareBracket: ']',\n  caret: '^',\n  underscore: '_',\n  graveAccent: '`',\n  lowercaseA: 'a',\n  lowercaseB: 'b',\n  lowercaseC: 'c',\n  lowercaseD: 'd',\n  lowercaseE: 'e',\n  lowercaseF: 'f',\n  lowercaseG: 'g',\n  lowercaseH: 'h',\n  lowercaseI: 'i',\n  lowercaseJ: 'j',\n  lowercaseK: 'k',\n  lowercaseL: 'l',\n  lowercaseM: 'm',\n  lowercaseN: 'n',\n  lowercaseO: 'o',\n  lowercaseP: 'p',\n  lowercaseQ: 'q',\n  lowercaseR: 'r',\n  lowercaseS: 's',\n  lowercaseT: 't',\n  lowercaseU: 'u',\n  lowercaseV: 'v',\n  lowercaseW: 'w',\n  lowercaseX: 'x',\n  lowercaseY: 'y',\n  lowercaseZ: 'z',\n  leftCurlyBrace: '{',\n  verticalBar: '|',\n  rightCurlyBrace: '}',\n  tilde: '~',\n  replacementCharacter: 'ï¿½'\n})\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;AACM,MAAM,SAA+B;IAC1C,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,OAAO;IACP,iBAAiB;IACjB,eAAe;IACf,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,WAAW;IACX,YAAY;IACZ,iBAAiB;IACjB,kBAAkB;IAClB,UAAU;IACV,UAAU;IACV,OAAO;IACP,MAAM;IACN,KAAK;IACL,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,WAAW;IACX,UAAU;IACV,UAAU;IACV,aAAa;IACb,cAAc;IACd,QAAQ;IACR,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,mBAAmB;IACnB,WAAW;IACX,oBAAoB;IACpB,OAAO;IACP,YAAY;IACZ,aAAa;IACb,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,gBAAgB;IAChB,aAAa;IACb,iBAAiB;IACjB,OAAO;IACP,sBAAsB;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1370, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-sanitize-uri%401.2.0/node_modules/micromark-util-sanitize-uri/dev/index.js"],"sourcesContent":["import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {values} from 'micromark-util-symbol/values.js'\n\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri`).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * A regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string | undefined} url\n *   URI to sanitize.\n * @param {RegExp | null | undefined} [protocol]\n *   Allowed protocols.\n * @returns {string}\n *   Sanitized URI.\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n\n  if (!protocol) {\n    return value\n  }\n\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, itâ€™s relative.\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) ||\n    // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n\n/**\n * Normalize a URL.\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n *   URI to normalize.\n * @returns {string}\n *   Normalized URI.\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n    let replace = ''\n\n    // A correct percent encoded value.\n    if (\n      code === codes.percentSign &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    }\n    // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1)\n\n      // A correct surrogate pair.\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      }\n      // Lone surrogate.\n      else {\n        replace = values.replacementCharacter\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n\n  return result.join('') + value.slice(start)\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAwBO,SAAS,YAAY,GAAG,EAAE,QAAQ;IACvC,MAAM,QAAQ,CAAA,GAAA,+NAAA,CAAA,SAAM,AAAD,EAAE,aAAa,OAAO;IAEzC,IAAI,CAAC,UAAU;QACb,OAAO;IACT;IAEA,MAAM,QAAQ,MAAM,OAAO,CAAC;IAC5B,MAAM,eAAe,MAAM,OAAO,CAAC;IACnC,MAAM,aAAa,MAAM,OAAO,CAAC;IACjC,MAAM,QAAQ,MAAM,OAAO,CAAC;IAE5B,IACE,0CAA0C;IAC1C,QAAQ,KAEP,QAAQ,CAAC,KAAK,QAAQ,SACtB,eAAe,CAAC,KAAK,QAAQ,gBAC7B,aAAa,CAAC,KAAK,QAAQ,cAC5B,0CAA0C;IAC1C,SAAS,IAAI,CAAC,MAAM,KAAK,CAAC,GAAG,SAC7B;QACA,OAAO;IACT;IAEA,OAAO;AACT;AAaO,SAAS,aAAa,KAAK;IAChC,0BAA0B,GAC1B,MAAM,SAAS,EAAE;IACjB,IAAI,QAAQ,CAAC;IACb,IAAI,QAAQ;IACZ,IAAI,OAAO;IAEX,MAAO,EAAE,QAAQ,MAAM,MAAM,CAAE;QAC7B,MAAM,OAAO,MAAM,UAAU,CAAC;QAC9B,mBAAmB,GACnB,IAAI,UAAU;QAEd,mCAAmC;QACnC,IACE,SAAS,+NAAA,CAAA,QAAK,CAAC,WAAW,IAC1B,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,MAAM,UAAU,CAAC,QAAQ,OAC3C,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,MAAM,UAAU,CAAC,QAAQ,KAC3C;YACA,OAAO;QACT,OAEK,IAAI,OAAO,KAAK;YACnB,IAAI,CAAC,oBAAoB,IAAI,CAAC,OAAO,YAAY,CAAC,QAAQ;gBACxD,UAAU,OAAO,YAAY,CAAC;YAChC;QACF,OAEK,IAAI,OAAO,SAAS,OAAO,OAAO;YACrC,MAAM,OAAO,MAAM,UAAU,CAAC,QAAQ;YAEtC,4BAA4B;YAC5B,IAAI,OAAO,SAAS,OAAO,SAAS,OAAO,OAAO;gBAChD,UAAU,OAAO,YAAY,CAAC,MAAM;gBACpC,OAAO;YACT,OAEK;gBACH,UAAU,gOAAA,CAAA,SAAM,CAAC,oBAAoB;YACvC;QACF,OAEK;YACH,UAAU,OAAO,YAAY,CAAC;QAChC;QAEA,IAAI,SAAS;YACX,OAAO,IAAI,CAAC,MAAM,KAAK,CAAC,OAAO,QAAQ,mBAAmB;YAC1D,QAAQ,QAAQ,OAAO;YACvB,UAAU;QACZ;QAEA,IAAI,MAAM;YACR,SAAS;YACT,OAAO;QACT;IACF;IAEA,OAAO,OAAO,IAAI,CAAC,MAAM,MAAM,KAAK,CAAC;AACvC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1441, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-autolink-literal%401.0.5/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').Handle} Handle\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n */\n\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\n\n// To do: next major: expose functions that yields extension.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to support\n * GFM autolink literals when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmAutolinkLiteralHtml = {\n  exit: {literalAutolinkEmail, literalAutolinkHttp, literalAutolinkWww}\n}\n\n/**\n * @this {CompileContext}\n * @type {Handle}\n */\nfunction literalAutolinkWww(token) {\n  anchorFromToken.call(this, token, 'http://')\n}\n\n/**\n * @this {CompileContext}\n * @type {Handle}\n */\nfunction literalAutolinkEmail(token) {\n  anchorFromToken.call(this, token, 'mailto:')\n}\n\n/**\n * @this {CompileContext}\n * @type {Handle}\n */\nfunction literalAutolinkHttp(token) {\n  anchorFromToken.call(this, token)\n}\n\n/**\n * @this CompileContext\n * @param {Token} token\n * @param {string | null | undefined} [protocol]\n * @returns {void}\n */\nfunction anchorFromToken(token, protocol) {\n  const url = this.sliceSerialize(token)\n  this.tag('<a href=\"' + sanitizeUri((protocol || '') + url) + '\">')\n  this.raw(this.encode(url))\n  this.tag('</a>')\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;AAED;;AAUO,MAAM,yBAAyB;IACpC,MAAM;QAAC;QAAsB;QAAqB;IAAkB;AACtE;AAEA;;;CAGC,GACD,SAAS,mBAAmB,KAAK;IAC/B,gBAAgB,IAAI,CAAC,IAAI,EAAE,OAAO;AACpC;AAEA;;;CAGC,GACD,SAAS,qBAAqB,KAAK;IACjC,gBAAgB,IAAI,CAAC,IAAI,EAAE,OAAO;AACpC;AAEA;;;CAGC,GACD,SAAS,oBAAoB,KAAK;IAChC,gBAAgB,IAAI,CAAC,IAAI,EAAE;AAC7B;AAEA;;;;;CAKC,GACD,SAAS,gBAAgB,KAAK,EAAE,QAAQ;IACtC,MAAM,MAAM,IAAI,CAAC,cAAc,CAAC;IAChC,IAAI,CAAC,GAAG,CAAC,cAAc,CAAA,GAAA,wPAAA,CAAA,cAAW,AAAD,EAAE,CAAC,YAAY,EAAE,IAAI,OAAO;IAC7D,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC;IACrB,IAAI,CAAC,GAAG,CAAC;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1491, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/dequal%402.0.3/node_modules/dequal/dist/index.mjs"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n"],"names":[],"mappings":";;;AAAA,IAAI,MAAM,OAAO,SAAS,CAAC,cAAc;AAEzC,SAAS,KAAK,IAAI,EAAE,GAAG,EAAE,GAAG;IAC3B,KAAK,OAAO,KAAK,IAAI,GAAI;QACxB,IAAI,OAAO,KAAK,MAAM,OAAO;IAC9B;AACD;AAEO,SAAS,OAAO,GAAG,EAAE,GAAG;IAC9B,IAAI,MAAM,KAAK;IACf,IAAI,QAAQ,KAAK,OAAO;IAExB,IAAI,OAAO,OAAO,CAAC,OAAK,IAAI,WAAW,MAAM,IAAI,WAAW,EAAE;QAC7D,IAAI,SAAS,MAAM,OAAO,IAAI,OAAO,OAAO,IAAI,OAAO;QACvD,IAAI,SAAS,QAAQ,OAAO,IAAI,QAAQ,OAAO,IAAI,QAAQ;QAE3D,IAAI,SAAS,OAAO;YACnB,IAAI,CAAC,MAAI,IAAI,MAAM,MAAM,IAAI,MAAM,EAAE;gBACpC,MAAO,SAAS,OAAO,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI;YAC1C;YACA,OAAO,QAAQ,CAAC;QACjB;QAEA,IAAI,SAAS,KAAK;YACjB,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE;gBAC1B,OAAO;YACR;YACA,KAAK,OAAO,IAAK;gBAChB,MAAM;gBACN,IAAI,OAAO,OAAO,QAAQ,UAAU;oBACnC,MAAM,KAAK,KAAK;oBAChB,IAAI,CAAC,KAAK,OAAO;gBAClB;gBACA,IAAI,CAAC,IAAI,GAAG,CAAC,MAAM,OAAO;YAC3B;YACA,OAAO;QACR;QAEA,IAAI,SAAS,KAAK;YACjB,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE;gBAC1B,OAAO;YACR;YACA,KAAK,OAAO,IAAK;gBAChB,MAAM,GAAG,CAAC,EAAE;gBACZ,IAAI,OAAO,OAAO,QAAQ,UAAU;oBACnC,MAAM,KAAK,KAAK;oBAChB,IAAI,CAAC,KAAK,OAAO;gBAClB;gBACA,IAAI,CAAC,OAAO,GAAG,CAAC,EAAE,EAAE,IAAI,GAAG,CAAC,OAAO;oBAClC,OAAO;gBACR;YACD;YACA,OAAO;QACR;QAEA,IAAI,SAAS,aAAa;YACzB,MAAM,IAAI,WAAW;YACrB,MAAM,IAAI,WAAW;QACtB,OAAO,IAAI,SAAS,UAAU;YAC7B,IAAI,CAAC,MAAI,IAAI,UAAU,MAAM,IAAI,UAAU,EAAE;gBAC5C,MAAO,SAAS,IAAI,OAAO,CAAC,SAAS,IAAI,OAAO,CAAC;YAClD;YACA,OAAO,QAAQ,CAAC;QACjB;QAEA,IAAI,YAAY,MAAM,CAAC,MAAM;YAC5B,IAAI,CAAC,MAAI,IAAI,UAAU,MAAM,IAAI,UAAU,EAAE;gBAC5C,MAAO,SAAS,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI;YACtC;YACA,OAAO,QAAQ,CAAC;QACjB;QAEA,IAAI,CAAC,QAAQ,OAAO,QAAQ,UAAU;YACrC,MAAM;YACN,IAAK,QAAQ,IAAK;gBACjB,IAAI,IAAI,IAAI,CAAC,KAAK,SAAS,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,KAAK,OAAO,OAAO;gBACjE,IAAI,CAAC,CAAC,QAAQ,GAAG,KAAK,CAAC,OAAO,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,KAAK,GAAG,OAAO;YAC7D;YACA,OAAO,OAAO,IAAI,CAAC,KAAK,MAAM,KAAK;QACpC;IACD;IAEA,OAAO,QAAQ,OAAO,QAAQ;AAC/B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1572, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/kleur%404.1.5/node_modules/kleur/index.mjs"],"sourcesContent":["'use strict';\n\nlet FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;\nif (typeof process !== 'undefined') {\n\t({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});\n\tisTTY = process.stdout && process.stdout.isTTY;\n}\n\nconst $ = {\n\tenabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (\n\t\tFORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY\n\t),\n\n\t// modifiers\n\treset: init(0, 0),\n\tbold: init(1, 22),\n\tdim: init(2, 22),\n\titalic: init(3, 23),\n\tunderline: init(4, 24),\n\tinverse: init(7, 27),\n\thidden: init(8, 28),\n\tstrikethrough: init(9, 29),\n\n\t// colors\n\tblack: init(30, 39),\n\tred: init(31, 39),\n\tgreen: init(32, 39),\n\tyellow: init(33, 39),\n\tblue: init(34, 39),\n\tmagenta: init(35, 39),\n\tcyan: init(36, 39),\n\twhite: init(37, 39),\n\tgray: init(90, 39),\n\tgrey: init(90, 39),\n\n\t// background colors\n\tbgBlack: init(40, 49),\n\tbgRed: init(41, 49),\n\tbgGreen: init(42, 49),\n\tbgYellow: init(43, 49),\n\tbgBlue: init(44, 49),\n\tbgMagenta: init(45, 49),\n\tbgCyan: init(46, 49),\n\tbgWhite: init(47, 49)\n};\n\nfunction run(arr, str) {\n\tlet i=0, tmp, beg='', end='';\n\tfor (; i < arr.length; i++) {\n\t\ttmp = arr[i];\n\t\tbeg += tmp.open;\n\t\tend += tmp.close;\n\t\tif (!!~str.indexOf(tmp.close)) {\n\t\t\tstr = str.replace(tmp.rgx, tmp.close + tmp.open);\n\t\t}\n\t}\n\treturn beg + str + end;\n}\n\nfunction chain(has, keys) {\n\tlet ctx = { has, keys };\n\n\tctx.reset = $.reset.bind(ctx);\n\tctx.bold = $.bold.bind(ctx);\n\tctx.dim = $.dim.bind(ctx);\n\tctx.italic = $.italic.bind(ctx);\n\tctx.underline = $.underline.bind(ctx);\n\tctx.inverse = $.inverse.bind(ctx);\n\tctx.hidden = $.hidden.bind(ctx);\n\tctx.strikethrough = $.strikethrough.bind(ctx);\n\n\tctx.black = $.black.bind(ctx);\n\tctx.red = $.red.bind(ctx);\n\tctx.green = $.green.bind(ctx);\n\tctx.yellow = $.yellow.bind(ctx);\n\tctx.blue = $.blue.bind(ctx);\n\tctx.magenta = $.magenta.bind(ctx);\n\tctx.cyan = $.cyan.bind(ctx);\n\tctx.white = $.white.bind(ctx);\n\tctx.gray = $.gray.bind(ctx);\n\tctx.grey = $.grey.bind(ctx);\n\n\tctx.bgBlack = $.bgBlack.bind(ctx);\n\tctx.bgRed = $.bgRed.bind(ctx);\n\tctx.bgGreen = $.bgGreen.bind(ctx);\n\tctx.bgYellow = $.bgYellow.bind(ctx);\n\tctx.bgBlue = $.bgBlue.bind(ctx);\n\tctx.bgMagenta = $.bgMagenta.bind(ctx);\n\tctx.bgCyan = $.bgCyan.bind(ctx);\n\tctx.bgWhite = $.bgWhite.bind(ctx);\n\n\treturn ctx;\n}\n\nfunction init(open, close) {\n\tlet blk = {\n\t\topen: `\\x1b[${open}m`,\n\t\tclose: `\\x1b[${close}m`,\n\t\trgx: new RegExp(`\\\\x1b\\\\[${close}m`, 'g')\n\t};\n\treturn function (txt) {\n\t\tif (this !== void 0 && this.has !== void 0) {\n\t\t\t!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));\n\t\t\treturn txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';\n\t\t}\n\t\treturn txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';\n\t};\n}\n\nexport default $;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1684, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/diff%405.2.0/node_modules/diff/lib/index.mjs"],"sourcesContent":["function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var _options$timeout;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n\n    if (options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n\n    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n    var abortAfterTimestamp = Date.now() + maxExecutionTime;\n    var bestPath = [{\n      oldPos: -1,\n      lastComponent: undefined\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n\n\n    var minDiagonalToConsider = -Infinity,\n        maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.\n\n    function execEditLength() {\n      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n        var basePath = void 0;\n        var removePath = bestPath[diagonalPath - 1],\n            addPath = bestPath[diagonalPath + 1];\n\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = false;\n\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          var addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n\n        var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n        //       and prefer to order removals before insertions.\n\n\n        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {\n          basePath = self.addToPath(addPath, true, undefined, 0);\n        } else {\n          basePath = self.addToPath(removePath, undefined, true, 1);\n        }\n\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  addToPath: function addToPath(path, added, removed, oldPosInc) {\n    var last = path.lastComponent;\n\n    if (last && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: last.count + 1,\n          added: added,\n          removed: removed,\n          previousComponent: last.previousComponent\n        }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: 1,\n          added: added,\n          removed: removed,\n          previousComponent: last\n        }\n      };\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        oldPos = basePath.oldPos,\n        newPos = oldPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.lastComponent = {\n        count: commonCount,\n        previousComponent: basePath.lastComponent\n      };\n    }\n\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  var components = [];\n  var nextComponent;\n\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n\n  components.reverse();\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var finalComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof finalComponent.value === 'string' && (finalComponent.added || finalComponent.removed) && diff.equals('', finalComponent.value)) {\n    components[componentLen - 2].value += finalComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080â€“00FF\n//  - U+00D7  Ã— Multiplication sign\n//  - U+00F7  Ã· Division sign\n// Latin Extended-A, 0100â€“017F\n// Latin Extended-B, 0180â€“024F\n// IPA Extensions, 0250â€“02AF\n// Spacing Modifier Letters, 02B0â€“02FF\n//  - U+02C7  Ë‡ &#711;  Caron\n//  - U+02D8  Ë˜ &#728;  Breve\n//  - U+02D9  Ë™ &#729;  Dot Above\n//  - U+02DA  Ëš &#730;  Ring Above\n//  - U+02DB  Ë› &#731;  Ogonek\n//  - U+02DC  Ëœ &#732;  Small Tilde\n//  - U+02DD  Ë &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00â€“1EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  if (this.options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || '\\n';\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n\n  if (!diff) {\n    return;\n  }\n\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange;\n\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2;\n\n          // Overlapping\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3;\n\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\nfunction formatPatch(diff) {\n  if (Array.isArray(diff)) {\n    return diff.map(formatPatch).join('\\n');\n  }\n\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\nfunction reversePatch(structuredPatch) {\n  if (Array.isArray(structuredPatch)) {\n    return structuredPatch.map(reversePatch).reverse();\n  }\n\n  return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {\n    oldFileName: structuredPatch.newFileName,\n    oldHeader: structuredPatch.newHeader,\n    newFileName: structuredPatch.oldFileName,\n    newHeader: structuredPatch.oldHeader,\n    hunks: structuredPatch.hunks.map(function (hunk) {\n      return {\n        oldLines: hunk.newLines,\n        oldStart: hunk.newStart,\n        newLines: hunk.oldLines,\n        newStart: hunk.oldStart,\n        linedelimiters: hunk.linedelimiters,\n        lines: hunk.lines.map(function (l) {\n          if (l.startsWith('-')) {\n            return \"+\".concat(l.slice(1));\n          }\n\n          if (l.startsWith('+')) {\n            return \"-\".concat(l.slice(1));\n          }\n\n          return l;\n        })\n      };\n    })\n  });\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, formatPatch, merge, parsePatch, reversePatch, structuredPatch };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3030, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/uvu%400.5.6/node_modules/uvu/diff/index.mjs"],"sourcesContent":["import kleur from 'kleur';\nimport * as diff from 'diff';\n\nconst colors = {\n\t'--': kleur.red,\n\t'Â·Â·': kleur.grey,\n\t'++': kleur.green,\n};\n\nconst TITLE = kleur.dim().italic;\nconst TAB=kleur.dim('â†’'), SPACE=kleur.dim('Â·'), NL=kleur.dim('â†µ');\nconst LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + '\\n';\nconst LINE = (num, x) => kleur.dim('L' + String(num).padStart(x, '0') + ' ');\nconst PRETTY = str => str.replace(/[ ]/g, SPACE).replace(/\\t/g, TAB).replace(/(\\r?\\n)/g, NL);\n\nfunction line(obj, prev, pad) {\n\tlet char = obj.removed ? '--' : obj.added ? '++' : 'Â·Â·';\n\tlet arr = obj.value.replace(/\\r?\\n$/, '').split('\\n');\n\tlet i=0, tmp, out='';\n\n\tif (obj.added) out += colors[char]().underline(TITLE('Expected:')) + '\\n';\n\telse if (obj.removed) out += colors[char]().underline(TITLE('Actual:')) + '\\n';\n\n\tfor (; i < arr.length; i++) {\n\t\ttmp = arr[i];\n\t\tif (tmp != null) {\n\t\t\tif (prev) out += LINE(prev + i, pad);\n\t\t\tout += LOG(char, tmp || '\\n');\n\t\t}\n\t}\n\n\treturn out;\n}\n\n// TODO: want better diffing\n//~> complex items bail outright\nexport function arrays(input, expect) {\n\tlet arr = diff.diffArrays(input, expect);\n\tlet i=0, j=0, k=0, tmp, val, char, isObj, str;\n\tlet out = LOG('Â·Â·', '[');\n\n\tfor (; i < arr.length; i++) {\n\t\tchar = (tmp = arr[i]).removed ? '--' : tmp.added ? '++' : 'Â·Â·';\n\n\t\tif (tmp.added) {\n\t\t\tout += colors[char]().underline(TITLE('Expected:')) + '\\n';\n\t\t} else if (tmp.removed) {\n\t\t\tout += colors[char]().underline(TITLE('Actual:')) + '\\n';\n\t\t}\n\n\t\tfor (j=0; j < tmp.value.length; j++) {\n\t\t\tisObj = (tmp.value[j] && typeof tmp.value[j] === 'object');\n\t\t\tval = stringify(tmp.value[j]).split(/\\r?\\n/g);\n\t\t\tfor (k=0; k < val.length;) {\n\t\t\t\tstr = '  ' + val[k++] + (isObj ? '' : ',');\n\t\t\t\tif (isObj && k === val.length && (j + 1) < tmp.value.length) str += ',';\n\t\t\t\tout += LOG(char, str);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out + LOG('Â·Â·', ']');\n}\n\nexport function lines(input, expect, linenum = 0) {\n\tlet i=0, tmp, output='';\n\tlet arr = diff.diffLines(input, expect);\n\tlet pad = String(expect.split(/\\r?\\n/g).length - linenum).length;\n\n\tfor (; i < arr.length; i++) {\n\t\toutput += line(tmp = arr[i], linenum, pad);\n\t\tif (linenum && !tmp.removed) linenum += tmp.count;\n\t}\n\n\treturn output;\n}\n\nexport function chars(input, expect) {\n\tlet arr = diff.diffChars(input, expect);\n\tlet i=0, output='', tmp;\n\n\tlet l1 = input.length;\n\tlet l2 = expect.length;\n\n\tlet p1 = PRETTY(input);\n\tlet p2 = PRETTY(expect);\n\n\ttmp = arr[i];\n\n\tif (l1 === l2) {\n\t\t// no length offsets\n\t} else if (tmp.removed && arr[i + 1]) {\n\t\tlet del = tmp.count - arr[i + 1].count;\n\t\tif (del == 0) {\n\t\t\t// wash~\n\t\t} else if (del > 0) {\n\t\t\texpect = ' '.repeat(del) + expect;\n\t\t\tp2 = ' '.repeat(del) + p2;\n\t\t\tl2 += del;\n\t\t} else if (del < 0) {\n\t\t\tinput = ' '.repeat(-del) + input;\n\t\t\tp1 = ' '.repeat(-del) + p1;\n\t\t\tl1 += -del;\n\t\t}\n\t}\n\n\toutput += direct(p1, p2, l1, l2);\n\n\tif (l1 === l2) {\n\t\tfor (tmp='  '; i < l1; i++) {\n\t\t\ttmp += input[i] === expect[i] ? ' ' : '^';\n\t\t}\n\t} else {\n\t\tfor (tmp='  '; i < arr.length; i++) {\n\t\t\ttmp += ((arr[i].added || arr[i].removed) ? '^' : ' ').repeat(Math.max(arr[i].count, 0));\n\t\t\tif (i + 1 < arr.length && ((arr[i].added && arr[i+1].removed) || (arr[i].removed && arr[i+1].added))) {\n\t\t\t\tarr[i + 1].count -= arr[i].count;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output + kleur.red(tmp);\n}\n\nexport function direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {\n\tlet gutter = 4;\n\tlet lenC = Math.max(lenA, lenB);\n\tlet typeA=typeof input, typeB=typeof expect;\n\n\tif (typeA !== typeB) {\n\t\tgutter = 2;\n\n\t\tlet delA = gutter + lenC - lenA;\n\t\tlet delB = gutter + lenC - lenB;\n\n\t\tinput += ' '.repeat(delA) + kleur.dim(`[${typeA}]`);\n\t\texpect += ' '.repeat(delB) + kleur.dim(`[${typeB}]`);\n\n\t\tlenA += delA + typeA.length + 2;\n\t\tlenB += delB + typeB.length + 2;\n\t\tlenC = Math.max(lenA, lenB);\n\t}\n\n\tlet output = colors['++']('++' + expect + ' '.repeat(gutter + lenC - lenB) + TITLE('(Expected)')) + '\\n';\n\treturn output + colors['--']('--' + input + ' '.repeat(gutter + lenC - lenA) + TITLE('(Actual)')) + '\\n';\n}\n\nexport function sort(input, expect) {\n\tvar k, i=0, tmp, isArr = Array.isArray(input);\n\tvar keys=[], out=isArr ? Array(input.length) : {};\n\n\tif (isArr) {\n\t\tfor (i=0; i < out.length; i++) {\n\t\t\ttmp = input[i];\n\t\t\tif (!tmp || typeof tmp !== 'object') out[i] = tmp;\n\t\t\telse out[i] = sort(tmp, expect[i]); // might not be right\n\t\t}\n\t} else {\n\t\tfor (k in expect)\n\t\t\tkeys.push(k);\n\n\t\tfor (; i < keys.length; i++) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {\n\t\t\t\tif (!(tmp = input[k]) || typeof tmp !== 'object') out[k] = tmp;\n\t\t\t\telse out[k] = sort(tmp, expect[k]);\n\t\t\t}\n\t\t}\n\n\t\tfor (k in input) {\n\t\t\tif (!out.hasOwnProperty(k)) {\n\t\t\t\tout[k] = input[k]; // expect didnt have\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out;\n}\n\nexport function circular() {\n\tvar cache = new Set;\n\treturn function print(key, val) {\n\t\tif (val === void 0) return '[__VOID__]';\n\t\tif (typeof val === 'number' && val !== val) return '[__NAN__]';\n\t\tif (typeof val === 'bigint') return val.toString();\n\t\tif (!val || typeof val !== 'object') return val;\n\t\tif (cache.has(val)) return '[Circular]';\n\t\tcache.add(val); return val;\n\t}\n}\n\nexport function stringify(input) {\n\treturn JSON.stringify(input, circular(), 2).replace(/\"\\[__NAN__\\]\"/g, 'NaN').replace(/\"\\[__VOID__\\]\"/g, 'undefined');\n}\n\nexport function compare(input, expect) {\n\tif (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);\n\tif (expect instanceof RegExp) return chars(''+input, ''+expect);\n\n\tlet isA = input && typeof input == 'object';\n\tlet isB = expect && typeof expect == 'object';\n\n\tif (isA && isB) input = sort(input, expect);\n\tif (isB) expect = stringify(expect);\n\tif (isA) input = stringify(input);\n\n\tif (expect && typeof expect == 'object') {\n\t\tinput = stringify(sort(input, expect));\n\t\texpect = stringify(expect);\n\t}\n\n\tisA = typeof input == 'string';\n\tisB = typeof expect == 'string';\n\n\tif (isA && /\\r?\\n/.test(input)) return lines(input, ''+expect);\n\tif (isB && /\\r?\\n/.test(expect)) return lines(''+input, expect);\n\tif (isA && isB) return chars(input, expect);\n\n\treturn direct(input, expect);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3223, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/uvu%400.5.6/node_modules/uvu/assert/index.mjs"],"sourcesContent":["import { dequalÂ } from 'dequal';\nimport { compare, lines } from 'uvu/diff';\n\nfunction dedent(str) {\n\tstr = str.replace(/\\r?\\n/g, '\\n');\n  let arr = str.match(/^[ \\t]*(?=\\S)/gm);\n  let i = 0, min = 1/0, len = (arr||[]).length;\n  for (; i < len; i++) min = Math.min(min, arr[i].length);\n  return len && min ? str.replace(new RegExp(`^[ \\\\t]{${min}}`, 'gm'), '') : str;\n}\n\nexport class Assertion extends Error {\n\tconstructor(opts={}) {\n\t\tsuper(opts.message);\n\t\tthis.name = 'Assertion';\n\t\tthis.code = 'ERR_ASSERTION';\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, this.constructor);\n\t\t}\n\t\tthis.details = opts.details || false;\n\t\tthis.generated = !!opts.generated;\n\t\tthis.operator = opts.operator;\n\t\tthis.expects = opts.expects;\n\t\tthis.actual = opts.actual;\n\t}\n}\n\nfunction assert(bool, actual, expects, operator, detailer, backup, msg) {\n\tif (bool) return;\n\tlet message = msg || backup;\n\tif (msg instanceof Error) throw msg;\n\tlet details = detailer && detailer(actual, expects);\n\tthrow new Assertion({ actual, expects, operator, message, details, generated: !msg });\n}\n\nexport function ok(val, msg) {\n\tassert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);\n}\n\nexport function is(val, exp, msg) {\n\tassert(val === exp, val, exp, 'is', compare, 'Expected values to be strictly equal:', msg);\n}\n\nexport function equal(val, exp, msg) {\n\tassert(dequal(val, exp), val, exp, 'equal', compare, 'Expected values to be deeply equal:', msg);\n}\n\nexport function unreachable(msg) {\n\tassert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);\n}\n\nexport function type(val, exp, msg) {\n\tlet tmp = typeof val;\n\tassert(tmp === exp, tmp, exp, 'type', false, `Expected \"${tmp}\" to be \"${exp}\"`, msg);\n}\n\nexport function instance(val, exp, msg) {\n\tlet name = '`' + (exp.name || exp.constructor.name) + '`';\n\tassert(val instanceof exp, val, exp, 'instance', false, `Expected value to be an instance of ${name}`, msg);\n}\n\nexport function match(val, exp, msg) {\n\tif (typeof exp === 'string') {\n\t\tassert(val.includes(exp), val, exp, 'match', false, `Expected value to include \"${exp}\" substring`, msg);\n\t} else {\n\t\tassert(exp.test(val), val, exp, 'match', false, `Expected value to match \\`${String(exp)}\\` pattern`, msg);\n\t}\n}\n\nexport function snapshot(val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val === exp, val, exp, 'snapshot', lines, 'Expected value to match snapshot:', msg);\n}\n\nconst lineNums = (x, y) => lines(x, y, 1);\nexport function fixture(val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);\n}\n\nexport function throws(blk, exp, msg) {\n\tif (!msg && typeof exp === 'string') {\n\t\tmsg = exp; exp = null;\n\t}\n\n\ttry {\n\t\tblk();\n\t\tassert(false, false, true, 'throws', false, 'Expected function to throw', msg);\n\t} catch (err) {\n\t\tif (err instanceof Assertion) throw err;\n\n\t\tif (typeof exp === 'function') {\n\t\t\tassert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);\n\t\t} else if (exp instanceof RegExp) {\n\t\t\tassert(exp.test(err.message), false, true, 'throws', false, `Expected function to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n\t\t}\n\t}\n}\n\n// ---\n\nexport function not(val, msg) {\n\tassert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);\n}\n\nnot.ok = not;\n\nis.not = function (val, exp, msg) {\n\tassert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);\n}\n\nnot.equal = function (val, exp, msg) {\n\tassert(!dequal(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);\n}\n\nnot.type = function (val, exp, msg) {\n\tlet tmp = typeof val;\n\tassert(tmp !== exp, tmp, exp, 'not.type', false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg);\n}\n\nnot.instance = function (val, exp, msg) {\n\tlet name = '`' + (exp.name || exp.constructor.name) + '`';\n\tassert(!(val instanceof exp), val, exp, 'not.instance', false, `Expected value not to be an instance of ${name}`, msg);\n}\n\nnot.snapshot = function (val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);\n}\n\nnot.fixture = function (val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);\n}\n\nnot.match = function (val, exp, msg) {\n\tif (typeof exp === 'string') {\n\t\tassert(!val.includes(exp), val, exp, 'not.match', false, `Expected value not to include \"${exp}\" substring`, msg);\n\t} else {\n\t\tassert(!exp.test(val), val, exp, 'not.match', false, `Expected value not to match \\`${String(exp)}\\` pattern`, msg);\n\t}\n}\n\nnot.throws = function (blk, exp, msg) {\n\tif (!msg && typeof exp === 'string') {\n\t\tmsg = exp; exp = null;\n\t}\n\n\ttry {\n\t\tblk();\n\t} catch (err) {\n\t\tif (typeof exp === 'function') {\n\t\t\tassert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);\n\t\t} else if (exp instanceof RegExp) {\n\t\t\tassert(!exp.test(err.message), true, false, 'not.throws', false, `Expected function not to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n\t\t} else if (!exp) {\n\t\t\tassert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3388, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-factory-space%401.1.0/node_modules/micromark-factory-space/dev/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `â‰` represents a tab (plus how much it expands) and `â ` represents a\n * single space.\n *\n * ```markdown\n * â‰\n * â â â â \n * â‰â \n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n\n    effects.exit(type)\n    return ok(code)\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;AAED;;AAoCO,SAAS,aAAa,OAAO,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG;IACjD,MAAM,QAAQ,MAAM,MAAM,IAAI,OAAO,iBAAiB;IACtD,IAAI,OAAO;IAEX,OAAO;;;IAEP,kBAAkB,GAClB,SAAS,MAAM,IAAI;QACjB,IAAI,CAAA,GAAA,4OAAA,CAAA,gBAAa,AAAD,EAAE,OAAO;YACvB,QAAQ,KAAK,CAAC;YACd,OAAO,OAAO;QAChB;QAEA,OAAO,GAAG;IACZ;IAEA,kBAAkB,GAClB,SAAS,OAAO,IAAI;QAClB,IAAI,CAAA,GAAA,4OAAA,CAAA,gBAAa,AAAD,EAAE,SAAS,SAAS,OAAO;YACzC,QAAQ,OAAO,CAAC;YAChB,OAAO;QACT;QAEA,QAAQ,IAAI,CAAC;QACb,OAAO,GAAG;IACZ;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-symbol%401.1.0/node_modules/micromark-util-symbol/types.js"],"sourcesContent":["/**\n * This module is compiled away!\n *\n * Here is the list of all types of tokens exposed by micromark, with a short\n * explanation of what they include and where they are found.\n * In picking names, generally, the rule is to be as explicit as possible\n * instead of reusing names.\n * For example, there is a `definitionDestination` and a `resourceDestination`,\n * instead of one shared name.\n */\n\n// Note: when changing the next record, you must also change `TokenTypeMap`\n// in `micromark-util-types/index.d.ts`.\nexport const types = /** @type {const} */ ({\n  // Generic type for data, such as in a title, a destination, etc.\n  data: 'data',\n\n  // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).\n  // Such as, between a fenced code fence and an info string.\n  whitespace: 'whitespace',\n\n  // Generic type for line endings (line feed, carriage return, carriage return +\n  // line feed).\n  lineEnding: 'lineEnding',\n\n  // A line ending, but ending a blank line.\n  lineEndingBlank: 'lineEndingBlank',\n\n  // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a\n  // line.\n  linePrefix: 'linePrefix',\n\n  // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a\n  // line.\n  lineSuffix: 'lineSuffix',\n\n  // Whole ATX heading:\n  //\n  // ```markdown\n  // #\n  // ## Alpha\n  // ### Bravo ###\n  // ```\n  //\n  // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.\n  atxHeading: 'atxHeading',\n\n  // Sequence of number signs in an ATX heading (`###`).\n  atxHeadingSequence: 'atxHeadingSequence',\n\n  // Content in an ATX heading (`alpha`).\n  // Includes text.\n  atxHeadingText: 'atxHeadingText',\n\n  // Whole autolink (`<https://example.com>` or `<admin@example.com>`)\n  // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.\n  autolink: 'autolink',\n\n  // Email autolink w/o markers (`admin@example.com`)\n  autolinkEmail: 'autolinkEmail',\n\n  // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).\n  autolinkMarker: 'autolinkMarker',\n\n  // Protocol autolink w/o markers (`https://example.com`)\n  autolinkProtocol: 'autolinkProtocol',\n\n  // A whole character escape (`\\-`).\n  // Includes `escapeMarker` and `characterEscapeValue`.\n  characterEscape: 'characterEscape',\n\n  // The escaped character (`-`).\n  characterEscapeValue: 'characterEscapeValue',\n\n  // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).\n  // Includes `characterReferenceMarker`, an optional\n  // `characterReferenceMarkerNumeric`, in which case an optional\n  // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.\n  characterReference: 'characterReference',\n\n  // The start or end marker (`&` or `;`).\n  characterReferenceMarker: 'characterReferenceMarker',\n\n  // Mark reference as numeric (`#`).\n  characterReferenceMarkerNumeric: 'characterReferenceMarkerNumeric',\n\n  // Mark reference as numeric (`x` or `X`).\n  characterReferenceMarkerHexadecimal: 'characterReferenceMarkerHexadecimal',\n\n  // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).\n  characterReferenceValue: 'characterReferenceValue',\n\n  // Whole fenced code:\n  //\n  // ````markdown\n  // ```js\n  // alert(1)\n  // ```\n  // ````\n  codeFenced: 'codeFenced',\n\n  // A fenced code fence, including whitespace, sequence, info, and meta\n  // (` ```js `).\n  codeFencedFence: 'codeFencedFence',\n\n  // Sequence of grave accent or tilde characters (` ``` `) in a fence.\n  codeFencedFenceSequence: 'codeFencedFenceSequence',\n\n  // Info word (`js`) in a fence.\n  // Includes string.\n  codeFencedFenceInfo: 'codeFencedFenceInfo',\n\n  // Meta words (`highlight=\"1\"`) in a fence.\n  // Includes string.\n  codeFencedFenceMeta: 'codeFencedFenceMeta',\n\n  // A line of code.\n  codeFlowValue: 'codeFlowValue',\n\n  // Whole indented code:\n  //\n  // ```markdown\n  //     alert(1)\n  // ```\n  //\n  // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.\n  codeIndented: 'codeIndented',\n\n  // A text code (``` `alpha` ```).\n  // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include\n  // `codeTextPadding`.\n  codeText: 'codeText',\n\n  codeTextData: 'codeTextData',\n\n  // A space or line ending right after or before a tick.\n  codeTextPadding: 'codeTextPadding',\n\n  // A text code fence (` `` `).\n  codeTextSequence: 'codeTextSequence',\n\n  // Whole content:\n  //\n  // ```markdown\n  // [a]: b\n  // c\n  // =\n  // d\n  // ```\n  //\n  // Includes `paragraph` and `definition`.\n  content: 'content',\n  // Whole definition:\n  //\n  // ```markdown\n  // [micromark]: https://github.com/micromark/micromark\n  // ```\n  //\n  // Includes `definitionLabel`, `definitionMarker`, `whitespace`,\n  // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.\n  definition: 'definition',\n\n  // Destination of a definition (`https://github.com/micromark/micromark` or\n  // `<https://github.com/micromark/micromark>`).\n  // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.\n  definitionDestination: 'definitionDestination',\n\n  // Enclosed destination of a definition\n  // (`<https://github.com/micromark/micromark>`).\n  // Includes `definitionDestinationLiteralMarker` and optionally\n  // `definitionDestinationString`.\n  definitionDestinationLiteral: 'definitionDestinationLiteral',\n\n  // Markers of an enclosed definition destination (`<` or `>`).\n  definitionDestinationLiteralMarker: 'definitionDestinationLiteralMarker',\n\n  // Unenclosed destination of a definition\n  // (`https://github.com/micromark/micromark`).\n  // Includes `definitionDestinationString`.\n  definitionDestinationRaw: 'definitionDestinationRaw',\n\n  // Text in an destination (`https://github.com/micromark/micromark`).\n  // Includes string.\n  definitionDestinationString: 'definitionDestinationString',\n\n  // Label of a definition (`[micromark]`).\n  // Includes `definitionLabelMarker` and `definitionLabelString`.\n  definitionLabel: 'definitionLabel',\n\n  // Markers of a definition label (`[` or `]`).\n  definitionLabelMarker: 'definitionLabelMarker',\n\n  // Value of a definition label (`micromark`).\n  // Includes string.\n  definitionLabelString: 'definitionLabelString',\n\n  // Marker between a label and a destination (`:`).\n  definitionMarker: 'definitionMarker',\n\n  // Title of a definition (`\"x\"`, `'y'`, or `(z)`).\n  // Includes `definitionTitleMarker` and optionally `definitionTitleString`.\n  definitionTitle: 'definitionTitle',\n\n  // Marker around a title of a definition (`\"`, `'`, `(`, or `)`).\n  definitionTitleMarker: 'definitionTitleMarker',\n\n  // Data without markers in a title (`z`).\n  // Includes string.\n  definitionTitleString: 'definitionTitleString',\n\n  // Emphasis (`*alpha*`).\n  // Includes `emphasisSequence` and `emphasisText`.\n  emphasis: 'emphasis',\n\n  // Sequence of emphasis markers (`*` or `_`).\n  emphasisSequence: 'emphasisSequence',\n\n  // Emphasis text (`alpha`).\n  // Includes text.\n  emphasisText: 'emphasisText',\n\n  // The character escape marker (`\\`).\n  escapeMarker: 'escapeMarker',\n\n  // A hard break created with a backslash (`\\\\n`).\n  // Note: does not include the line ending.\n  hardBreakEscape: 'hardBreakEscape',\n\n  // A hard break created with trailing spaces (`  \\n`).\n  // Does not include the line ending.\n  hardBreakTrailing: 'hardBreakTrailing',\n\n  // Flow HTML:\n  //\n  // ```markdown\n  // <div\n  // ```\n  //\n  // Inlcudes `lineEnding`, `htmlFlowData`.\n  htmlFlow: 'htmlFlow',\n\n  htmlFlowData: 'htmlFlowData',\n\n  // HTML in text (the tag in `a <i> b`).\n  // Includes `lineEnding`, `htmlTextData`.\n  htmlText: 'htmlText',\n\n  htmlTextData: 'htmlTextData',\n\n  // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or\n  // `![alpha]`).\n  // Includes `label` and an optional `resource` or `reference`.\n  image: 'image',\n\n  // Whole link label (`[*alpha*]`).\n  // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.\n  label: 'label',\n\n  // Text in an label (`*alpha*`).\n  // Includes text.\n  labelText: 'labelText',\n\n  // Start a link label (`[`).\n  // Includes a `labelMarker`.\n  labelLink: 'labelLink',\n\n  // Start an image label (`![`).\n  // Includes `labelImageMarker` and `labelMarker`.\n  labelImage: 'labelImage',\n\n  // Marker of a label (`[` or `]`).\n  labelMarker: 'labelMarker',\n\n  // Marker to start an image (`!`).\n  labelImageMarker: 'labelImageMarker',\n\n  // End a label (`]`).\n  // Includes `labelMarker`.\n  labelEnd: 'labelEnd',\n\n  // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).\n  // Includes `label` and an optional `resource` or `reference`.\n  link: 'link',\n\n  // Whole paragraph:\n  //\n  // ```markdown\n  // alpha\n  // bravo.\n  // ```\n  //\n  // Includes text.\n  paragraph: 'paragraph',\n\n  // A reference (`[alpha]` or `[]`).\n  // Includes `referenceMarker` and an optional `referenceString`.\n  reference: 'reference',\n\n  // A reference marker (`[` or `]`).\n  referenceMarker: 'referenceMarker',\n\n  // Reference text (`alpha`).\n  // Includes string.\n  referenceString: 'referenceString',\n\n  // A resource (`(https://example.com \"alpha\")`).\n  // Includes `resourceMarker`, an optional `resourceDestination` with an optional\n  // `whitespace` and `resourceTitle`.\n  resource: 'resource',\n\n  // A resource destination (`https://example.com`).\n  // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.\n  resourceDestination: 'resourceDestination',\n\n  // A literal resource destination (`<https://example.com>`).\n  // Includes `resourceDestinationLiteralMarker` and optionally\n  // `resourceDestinationString`.\n  resourceDestinationLiteral: 'resourceDestinationLiteral',\n\n  // A resource destination marker (`<` or `>`).\n  resourceDestinationLiteralMarker: 'resourceDestinationLiteralMarker',\n\n  // A raw resource destination (`https://example.com`).\n  // Includes `resourceDestinationString`.\n  resourceDestinationRaw: 'resourceDestinationRaw',\n\n  // Resource destination text (`https://example.com`).\n  // Includes string.\n  resourceDestinationString: 'resourceDestinationString',\n\n  // A resource marker (`(` or `)`).\n  resourceMarker: 'resourceMarker',\n\n  // A resource title (`\"alpha\"`, `'alpha'`, or `(alpha)`).\n  // Includes `resourceTitleMarker` and optionally `resourceTitleString`.\n  resourceTitle: 'resourceTitle',\n\n  // A resource title marker (`\"`, `'`, `(`, or `)`).\n  resourceTitleMarker: 'resourceTitleMarker',\n\n  // Resource destination title (`alpha`).\n  // Includes string.\n  resourceTitleString: 'resourceTitleString',\n\n  // Whole setext heading:\n  //\n  // ```markdown\n  // alpha\n  // bravo\n  // =====\n  // ```\n  //\n  // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and\n  // `setextHeadingLine`.\n  setextHeading: 'setextHeading',\n\n  // Content in a setext heading (`alpha\\nbravo`).\n  // Includes text.\n  setextHeadingText: 'setextHeadingText',\n\n  // Underline in a setext heading, including whitespace suffix (`==`).\n  // Includes `setextHeadingLineSequence`.\n  setextHeadingLine: 'setextHeadingLine',\n\n  // Sequence of equals or dash characters in underline in a setext heading (`-`).\n  setextHeadingLineSequence: 'setextHeadingLineSequence',\n\n  // Strong (`**alpha**`).\n  // Includes `strongSequence` and `strongText`.\n  strong: 'strong',\n\n  // Sequence of strong markers (`**` or `__`).\n  strongSequence: 'strongSequence',\n\n  // Strong text (`alpha`).\n  // Includes text.\n  strongText: 'strongText',\n\n  // Whole thematic break:\n  //\n  // ```markdown\n  // * * *\n  // ```\n  //\n  // Includes `thematicBreakSequence` and `whitespace`.\n  thematicBreak: 'thematicBreak',\n\n  // A sequence of one or more thematic break markers (`***`).\n  thematicBreakSequence: 'thematicBreakSequence',\n\n  // Whole block quote:\n  //\n  // ```markdown\n  // > a\n  // >\n  // > b\n  // ```\n  //\n  // Includes `blockQuotePrefix` and flow.\n  blockQuote: 'blockQuote',\n  // The `>` or `> ` of a block quote.\n  blockQuotePrefix: 'blockQuotePrefix',\n  // The `>` of a block quote prefix.\n  blockQuoteMarker: 'blockQuoteMarker',\n  // The optional ` ` of a block quote prefix.\n  blockQuotePrefixWhitespace: 'blockQuotePrefixWhitespace',\n\n  // Whole unordered list:\n  //\n  // ```markdown\n  // - a\n  //   b\n  // ```\n  //\n  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further\n  // lines.\n  listOrdered: 'listOrdered',\n\n  // Whole ordered list:\n  //\n  // ```markdown\n  // 1. a\n  //    b\n  // ```\n  //\n  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further\n  // lines.\n  listUnordered: 'listUnordered',\n\n  // The indent of further list item lines.\n  listItemIndent: 'listItemIndent',\n\n  // A marker, as in, `*`, `+`, `-`, `.`, or `)`.\n  listItemMarker: 'listItemMarker',\n\n  // The thing that starts a list item, such as `1. `.\n  // Includes `listItemValue` if ordered, `listItemMarker`, and\n  // `listItemPrefixWhitespace` (unless followed by a line ending).\n  listItemPrefix: 'listItemPrefix',\n\n  // The whitespace after a marker.\n  listItemPrefixWhitespace: 'listItemPrefixWhitespace',\n\n  // The numerical value of an ordered item.\n  listItemValue: 'listItemValue',\n\n  // Internal types used for subtokenizers, compiled away\n  chunkDocument: 'chunkDocument',\n  chunkContent: 'chunkContent',\n  chunkFlow: 'chunkFlow',\n  chunkText: 'chunkText',\n  chunkString: 'chunkString'\n})\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3787, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-core-commonmark%401.1.0/node_modules/micromark-core-commonmark/dev/lib/blank-line.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const blankLine = {tokenize: tokenizeBlankLine, partial: true}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of blank line.\n   *\n   * > ðŸ‘‰ **Note**: `â ` represents a space character.\n   *\n   * ```markdown\n   * > | â â âŠ\n   *     ^\n   * > | âŠ\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    return markdownSpace(code)\n      ? factorySpace(effects, after, types.linePrefix)(code)\n      : after(code)\n  }\n\n  /**\n   * At eof/eol, after optional whitespace.\n   *\n   * > ðŸ‘‰ **Note**: `â ` represents a space character.\n   *\n   * ```markdown\n   * > | â â âŠ\n   *       ^\n   * > | âŠ\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;AAED;AACA;AACA;AACA;;;;;AAGO,MAAM,YAAY;IAAC,UAAU;IAAmB,SAAS;AAAI;AAEpE;;;CAGC,GACD,SAAS,kBAAkB,OAAO,EAAE,EAAE,EAAE,GAAG;IACzC,OAAO;;;IAEP;;;;;;;;;;;;;GAaC,GACD,SAAS,MAAM,IAAI;QACjB,OAAO,CAAA,GAAA,4OAAA,CAAA,gBAAa,AAAD,EAAE,QACjB,CAAA,GAAA,0OAAA,CAAA,eAAY,AAAD,EAAE,SAAS,OAAO,+NAAA,CAAA,QAAK,CAAC,UAAU,EAAE,QAC/C,MAAM;IACZ;IAEA;;;;;;;;;;;;;GAaC,GACD,SAAS,MAAM,IAAI;QACjB,OAAO,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAAI,CAAA,GAAA,4OAAA,CAAA,qBAAkB,AAAD,EAAE,QAAQ,GAAG,QAAQ,IAAI;IACzE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3851, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-normalize-identifier%401.1.0/node_modules/micromark-util-normalize-identifier/dev/index.js"],"sourcesContent":["import {values} from 'micromark-util-symbol/values.js'\n\n/**\n * Normalize an identifier (as found in references, definitions).\n *\n * Collapses markdown whitespace, trim, and then lower- and uppercase.\n *\n * Some characters are considered â€œuppercaseâ€, such as U+03F4 (`Ï´`), but if their\n * lowercase counterpart (U+03B8 (`Î¸`)) is uppercased will result in a different\n * uppercase character (U+0398 (`Î˜`)).\n * So, to get a canonical form, we perform both lower- and uppercase.\n *\n * Using uppercase last makes sure keys will never interact with default\n * prototypal values (such as `constructor`): nothing in the prototype of\n * `Object` is uppercase.\n *\n * @param {string} value\n *   Identifier to normalize.\n * @returns {string}\n *   Normalized identifier.\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value\n      // Collapse markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, values.space)\n      // Trim.\n      .replace(/^ | $/g, '')\n      // Some characters are considered â€œuppercaseâ€, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n"],"names":[],"mappings":";;;AAAA;;AAqBO,SAAS,oBAAoB,KAAK;IACvC,OACE,KACE,gCAAgC;KAC/B,OAAO,CAAC,eAAe,gOAAA,CAAA,SAAM,CAAC,KAAK,CACpC,QAAQ;KACP,OAAO,CAAC,UAAU,GACnB,qEAAqE;IACrE,iEAAiE;IACjE,aAAa;IACb,iEAAiE;IACjE,uEAAuE;IACvE,mCAAmC;KAClC,WAAW,GACX,WAAW;AAElB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3871, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-footnote%401.1.2/node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {types} from 'micromark-util-symbol/types.js'\n\nconst indent = {tokenize: tokenizeIndent, partial: true}\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [codes.leftSquareBracket]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {tokenize: tokenizeDefinitionContinuation},\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [codes.leftSquareBracket]: {tokenize: tokenizeGfmFootnoteCall},\n      [codes.rightSquareBracket]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n\n    if (token.type === types.labelImage) {\n      labelStart = token\n      break\n    }\n\n    // Exit if weâ€™ve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === types.labelLink ||\n      token.type === types.label ||\n      token.type === types.image ||\n      token.type === types.link\n    ) {\n      break\n    }\n  }\n\n  return start\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n\n    const id = normalizeIdentifier(\n      self.sliceSerialize({start: labelStart.end, end: self.now()})\n    )\n\n    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token | undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === types.labelImage &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n\n  assert(labelStart, 'expected `labelStart` to resolve')\n\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = types.data\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  /** @type {Token} */\n  const chunk = {\n    type: types.chunkString,\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n\n  events.splice(index, events.length - index + 1, ...replacement)\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We canâ€™t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== codes.caret) return nok(code)\n\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n      // Too long.\n      size > constants.linkReferenceSizeMax ||\n      // Closing brace with nothing.\n      (code === codes.rightSquareBracket && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === codes.eof ||\n      code === codes.leftSquareBracket ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteCallString')\n\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code)\n      }\n\n      effects.enter('gfmFootnoteCallLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteCallLabelMarker')\n      effects.exit('gfmFootnoteCall')\n      return ok\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === codes.backslash ? callEscape : callData\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (\n      code === codes.leftSquareBracket ||\n      code === codes.backslash ||\n      code === codes.rightSquareBracket\n    ) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n\n    return callData(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean | undefined} */\n  let data\n\n  return start\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelAtMarker\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === codes.caret) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      effects.enter('chunkString').contentType = 'string'\n      return labelInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In label.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      // Too long.\n      size > constants.linkReferenceSizeMax ||\n      // Closing brace with nothing.\n      (code === codes.rightSquareBracket && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === codes.eof ||\n      code === codes.leftSquareBracket ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === codes.backslash ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (\n      code === codes.leftSquareBracket ||\n      code === codes.backslash ||\n      code === codes.rightSquareBracket\n    ) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n\n    return labelInside(code)\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === codes.colon) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n\n      if (!defined.includes(identifier)) {\n        defined.push(identifier)\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(\n        effects,\n        whitespaceAfter,\n        'gfmFootnoteDefinitionWhitespace'\n      )\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    constants.tabSize + 1\n  )\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === constants.tabSize\n      ? ok(code)\n      : nok(code)\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4356, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-footnote%401.1.2/node_modules/micromark-extension-gfm-footnote/dev/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @callback BackLabelTemplate\n *   Generate a back label dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   * `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   * `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   * `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Back label to use when linking back from definitions to their reference.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {string} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent them from\n *   *clobbering*.\n *\n *   The default is `'user-content-'`.\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {string} [label='Footnotes']\n *   Textual label to use for the footnotes section.\n *\n *   The default value is `'Footnotes'`.\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different attributes with the `labelAttributes` option.\n * @property {string} [labelAttributes='class=\"sr-only\"']\n *   Attributes to use on the footnote label.\n *\n *   Change it to show the label and add other attributes.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different attributes.\n *\n *   > ðŸ‘‰ **Note**: `id=\"footnote-label\"` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string} [labelTagName='h2']\n *   HTML tag name to use for the footnote label element.\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different attributes with the `labelAttributes` option.\n * @property {BackLabelTemplate | string} [backLabel]\n *   Textual label to describe the backreference back to references.\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *  }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `aria-label` attribute on each backreference\n *   (the `â†©` links).\n *   It affects users of assistive technology.\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Generate the default label that GitHub uses on backreferences.\n *\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Default label.\n */\nexport function defaultBackLabel(referenceIndex, rereferenceIndex) {\n  return (\n    'Back to reference ' +\n    (referenceIndex + 1) +\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n  )\n}\n\n/**\n * Create an extension for `micromark` to support GFM footnotes when\n * serializing to HTML.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM footnotes when serializing to HTML.\n */\nexport function gfmFootnoteHtml(options) {\n  const config = options || emptyOptions\n  const label = config.label || 'Footnotes'\n  const labelTagName = config.labelTagName || 'h2'\n  const labelAttributes =\n    config.labelAttributes === null || config.labelAttributes === undefined\n      ? 'class=\"sr-only\"'\n      : config.labelAttributes\n  const backLabel = config.backLabel || defaultBackLabel\n  const clobberPrefix =\n    config.clobberPrefix === null || config.clobberPrefix === undefined\n      ? 'user-content-'\n      : config.clobberPrefix\n  return {\n    enter: {\n      gfmFootnoteDefinition() {\n        const stack = this.getData('tightStack')\n        stack.push(false)\n      },\n      gfmFootnoteDefinitionLabelString() {\n        this.buffer()\n      },\n      gfmFootnoteCallString() {\n        this.buffer()\n      }\n    },\n    exit: {\n      gfmFootnoteDefinition() {\n        let definitions = this.getData('gfmFootnoteDefinitions')\n        const footnoteStack = this.getData('gfmFootnoteDefinitionStack')\n        assert(footnoteStack, 'expected `footnoteStack`')\n        const tightStack = this.getData('tightStack')\n        const current = footnoteStack.pop()\n        const value = this.resume()\n\n        assert(current, 'expected to be in a footnote')\n\n        if (!definitions) {\n          this.setData('gfmFootnoteDefinitions', (definitions = {}))\n        }\n\n        if (!own.call(definitions, current)) definitions[current] = value\n\n        tightStack.pop()\n        this.setData('slurpOneLineEnding', true)\n        // â€œHackâ€ to prevent a line ending from showing up if weâ€™re in a definition in\n        // an empty list item.\n        this.setData('lastWasTag')\n      },\n      gfmFootnoteDefinitionLabelString(token) {\n        let footnoteStack = /** @type {Array<string>} */ (\n          this.getData('gfmFootnoteDefinitionStack')\n        )\n\n        if (!footnoteStack) {\n          this.setData('gfmFootnoteDefinitionStack', (footnoteStack = []))\n        }\n\n        footnoteStack.push(normalizeIdentifier(this.sliceSerialize(token)))\n        this.resume() // Drop the label.\n        this.buffer() // Get ready for a value.\n      },\n      gfmFootnoteCallString(token) {\n        let calls = this.getData('gfmFootnoteCallOrder')\n        let counts = this.getData('gfmFootnoteCallCounts')\n        const id = normalizeIdentifier(this.sliceSerialize(token))\n        /** @type {number} */\n        let counter\n\n        this.resume()\n\n        if (!calls) this.setData('gfmFootnoteCallOrder', (calls = []))\n        if (!counts) this.setData('gfmFootnoteCallCounts', (counts = {}))\n\n        const index = calls.indexOf(id)\n        const safeId = sanitizeUri(id.toLowerCase())\n\n        if (index === -1) {\n          calls.push(id)\n          counts[id] = 1\n          counter = calls.length\n        } else {\n          counts[id]++\n          counter = index + 1\n        }\n\n        const reuseCounter = counts[id]\n\n        this.tag(\n          '<sup><a href=\"#' +\n            clobberPrefix +\n            'fn-' +\n            safeId +\n            '\" id=\"' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (reuseCounter > 1 ? '-' + reuseCounter : '') +\n            '\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">' +\n            String(counter) +\n            '</a></sup>'\n        )\n      },\n      null() {\n        const calls = /** @type {Array<string>} */ (\n          this.getData('gfmFootnoteCallOrder') || []\n        )\n        const counts = /** @type {Record<string, number>} */ (\n          this.getData('gfmFootnoteCallCounts') || {}\n        )\n        const definitions = /** @type {Record<string, string>} */ (\n          this.getData('gfmFootnoteDefinitions') || {}\n        )\n        let index = -1\n\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded()\n          this.tag(\n            '<section data-footnotes=\"\" class=\"footnotes\"><' +\n              labelTagName +\n              ' id=\"footnote-label\"' +\n              (labelAttributes ? ' ' + labelAttributes : '') +\n              '>'\n          )\n          this.raw(this.encode(label))\n          this.tag('</' + labelTagName + '>')\n          this.lineEndingIfNeeded()\n          this.tag('<ol>')\n        }\n\n        while (++index < calls.length) {\n          // Called definitions are always defined.\n          const id = calls[index]\n          const safeId = sanitizeUri(id.toLowerCase())\n          let referenceIndex = 0\n          /** @type {Array<string>} */\n          const references = []\n\n          while (++referenceIndex <= counts[id]) {\n            references.push(\n              '<a href=\"#' +\n                clobberPrefix +\n                'fnref-' +\n                safeId +\n                (referenceIndex > 1 ? '-' + referenceIndex : '') +\n                '\" data-footnote-backref=\"\" aria-label=\"' +\n                this.encode(\n                  typeof backLabel === 'string'\n                    ? backLabel\n                    : backLabel(index, referenceIndex)\n                ) +\n                '\" class=\"data-footnote-backref\">â†©' +\n                (referenceIndex > 1\n                  ? '<sup>' + referenceIndex + '</sup>'\n                  : '') +\n                '</a>'\n            )\n          }\n\n          const reference = references.join(' ')\n          let injected = false\n\n          this.lineEndingIfNeeded()\n          this.tag('<li id=\"' + clobberPrefix + 'fn-' + safeId + '\">')\n          this.lineEndingIfNeeded()\n          this.tag(\n            definitions[id].replace(\n              /<\\/p>(?:\\r?\\n|\\r)?$/,\n              (/** @type {string} */ $0) => {\n                injected = true\n                return ' ' + reference + $0\n              }\n            )\n          )\n\n          if (!injected) {\n            this.lineEndingIfNeeded()\n            this.tag(reference)\n          }\n\n          this.lineEndingIfNeeded()\n          this.tag('</li>')\n        }\n\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded()\n          this.tag('</ol>')\n          this.lineEndingIfNeeded()\n          this.tag('</section>')\n        }\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4599, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-classify-character%401.1.0/node_modules/micromark-util-classify-character/dev/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\n\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * > ðŸ‘‰ **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === codes.eof ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return constants.characterGroupWhitespace\n  }\n\n  if (unicodePunctuation(code)) {\n    return constants.characterGroupPunctuation\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAED;AAKA;AACA;;;;AAgBO,SAAS,kBAAkB,IAAI;IACpC,IACE,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,IAClB,CAAA,GAAA,4OAAA,CAAA,4BAAyB,AAAD,EAAE,SAC1B,CAAA,GAAA,4OAAA,CAAA,oBAAiB,AAAD,EAAE,OAClB;QACA,OAAO,mOAAA,CAAA,YAAS,CAAC,wBAAwB;IAC3C;IAEA,IAAI,CAAA,GAAA,4OAAA,CAAA,qBAAkB,AAAD,EAAE,OAAO;QAC5B,OAAO,mOAAA,CAAA,YAAS,CAAC,yBAAyB;IAC5C;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4622, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-resolve-all%401.1.0/node_modules/micromark-util-resolve-all/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {Array<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;;;;;CAWC;;;AACM,SAAS,WAAW,UAAU,EAAE,MAAM,EAAE,OAAO;IACpD,4BAA4B,GAC5B,MAAM,SAAS,EAAE;IACjB,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,WAAW,MAAM,CAAE;QAClC,MAAM,UAAU,UAAU,CAAC,MAAM,CAAC,UAAU;QAE5C,IAAI,WAAW,CAAC,OAAO,QAAQ,CAAC,UAAU;YACxC,SAAS,QAAQ,QAAQ;YACzB,OAAO,IAAI,CAAC;QACd;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4656, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-strikethrough%401.0.7/node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde.\n *\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {}\n  let single = options_.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    text: {[codes.tilde]: tokenizer},\n    insideSpan: {null: [tokenizer]},\n    attentionMarkers: {null: [codes.tilde]}\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n\n            const insideSpan = context.parser.constructs.insideSpan.null\n\n            if (insideSpan) {\n              // Between.\n              splice(\n                nextEvents,\n                nextEvents.length,\n                0,\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\n              )\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n\n            splice(events, open - 1, index - open + 3, nextEvents)\n\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = types.data\n      }\n    }\n\n    return events\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(code === codes.tilde, 'expected `~`')\n\n      if (\n        previous === codes.tilde &&\n        events[events.length - 1][1].type !== types.characterEscape\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous)\n\n      if (code === codes.tilde) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open =\n        !after || (after === constants.attentionSideAfter && Boolean(before))\n      token._close =\n        !before || (before === constants.attentionSideAfter && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;CAgBC;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAWO,SAAS,iBAAiB,OAAO;IACtC,MAAM,WAAW,WAAW,CAAC;IAC7B,IAAI,SAAS,SAAS,WAAW;IACjC,MAAM,YAAY;QAChB,UAAU;QACV,YAAY;IACd;IAEA,IAAI,WAAW,QAAQ,WAAW,WAAW;QAC3C,SAAS;IACX;IAEA,OAAO;QACL,MAAM;YAAC,CAAC,+NAAA,CAAA,QAAK,CAAC,KAAK,CAAC,EAAE;QAAS;QAC/B,YAAY;YAAC,MAAM;gBAAC;aAAU;QAAA;QAC9B,kBAAkB;YAAC,MAAM;gBAAC,+NAAA,CAAA,QAAK,CAAC,KAAK;aAAC;QAAA;IACxC;;;IAEA;;;;GAIC,GACD,SAAS,wBAAwB,MAAM,EAAE,OAAO;QAC9C,IAAI,QAAQ,CAAC;QAEb,2BAA2B;QAC3B,MAAO,EAAE,QAAQ,OAAO,MAAM,CAAE;YAC9B,+BAA+B;YAC/B,IACE,MAAM,CAAC,MAAM,CAAC,EAAE,KAAK,WACrB,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,KAAK,oCAC1B,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EACvB;gBACA,IAAI,OAAO;gBAEX,mCAAmC;gBACnC,MAAO,OAAQ;oBACb,yCAAyC;oBACzC,IACE,MAAM,CAAC,KAAK,CAAC,EAAE,KAAK,UACpB,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,oCACzB,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,IACrB,6BAA6B;oBAC7B,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,KACzD,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,EAC3D;wBACA,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,GAAG;wBACxB,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,GAAG;wBAEvB,kBAAkB,GAClB,MAAM,gBAAgB;4BACpB,MAAM;4BACN,OAAO,OAAO,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK;4BAC9C,KAAK,OAAO,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG;wBAC7C;wBAEA,kBAAkB,GAClB,MAAM,OAAO;4BACX,MAAM;4BACN,OAAO,OAAO,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG;4BAC5C,KAAK,OAAO,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK;wBAC/C;wBAEA,WAAW;wBACX,yBAAyB,GACzB,MAAM,aAAa;4BACjB;gCAAC;gCAAS;gCAAe;6BAAQ;4BACjC;gCAAC;gCAAS,MAAM,CAAC,KAAK,CAAC,EAAE;gCAAE;6BAAQ;4BACnC;gCAAC;gCAAQ,MAAM,CAAC,KAAK,CAAC,EAAE;gCAAE;6BAAQ;4BAClC;gCAAC;gCAAS;gCAAM;6BAAQ;yBACzB;wBAED,MAAM,aAAa,QAAQ,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI;wBAE5D,IAAI,YAAY;4BACd,WAAW;4BACX,CAAA,GAAA,wOAAA,CAAA,SAAM,AAAD,EACH,YACA,WAAW,MAAM,EACjB,GACA,CAAA,GAAA,+OAAA,CAAA,aAAU,AAAD,EAAE,YAAY,OAAO,KAAK,CAAC,OAAO,GAAG,QAAQ;wBAE1D;wBAEA,WAAW;wBACX,CAAA,GAAA,wOAAA,CAAA,SAAM,AAAD,EAAE,YAAY,WAAW,MAAM,EAAE,GAAG;4BACvC;gCAAC;gCAAQ;gCAAM;6BAAQ;4BACvB;gCAAC;gCAAS,MAAM,CAAC,MAAM,CAAC,EAAE;gCAAE;6BAAQ;4BACpC;gCAAC;gCAAQ,MAAM,CAAC,MAAM,CAAC,EAAE;gCAAE;6BAAQ;4BACnC;gCAAC;gCAAQ;gCAAe;6BAAQ;yBACjC;wBAED,CAAA,GAAA,wOAAA,CAAA,SAAM,AAAD,EAAE,QAAQ,OAAO,GAAG,QAAQ,OAAO,GAAG;wBAE3C,QAAQ,OAAO,WAAW,MAAM,GAAG;wBACnC;oBACF;gBACF;YACF;QACF;QAEA,QAAQ,CAAC;QAET,MAAO,EAAE,QAAQ,OAAO,MAAM,CAAE;YAC9B,IAAI,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,KAAK,kCAAkC;gBAC9D,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,GAAG,+NAAA,CAAA,QAAK,CAAC,IAAI;YACpC;QACF;QAEA,OAAO;IACT;IAEA;;;GAGC,GACD,SAAS,sBAAsB,OAAO,EAAE,EAAE,EAAE,GAAG;QAC7C,MAAM,WAAW,IAAI,CAAC,QAAQ;QAC9B,MAAM,SAAS,IAAI,CAAC,MAAM;QAC1B,IAAI,OAAO;QAEX,OAAO;;;QAEP,kBAAkB,GAClB,SAAS,MAAM,IAAI;YACjB,CAAA,GAAA,0LAAA,CAAA,KAAM,AAAD,EAAE,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,EAAE;YAE7B,IACE,aAAa,+NAAA,CAAA,QAAK,CAAC,KAAK,IACxB,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,CAAC,EAAE,CAAC,IAAI,KAAK,+NAAA,CAAA,QAAK,CAAC,eAAe,EAC3D;gBACA,OAAO,IAAI;YACb;YAEA,QAAQ,KAAK,CAAC;YACd,OAAO,KAAK;QACd;QAEA,kBAAkB,GAClB,SAAS,KAAK,IAAI;YAChB,MAAM,SAAS,CAAA,GAAA,oQAAA,CAAA,oBAAiB,AAAD,EAAE;YAEjC,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,KAAK,EAAE;gBACxB,qCAAqC;gBACrC,IAAI,OAAO,GAAG,OAAO,IAAI;gBACzB,QAAQ,OAAO,CAAC;gBAChB;gBACA,OAAO;YACT;YAEA,IAAI,OAAO,KAAK,CAAC,QAAQ,OAAO,IAAI;YACpC,MAAM,QAAQ,QAAQ,IAAI,CAAC;YAC3B,MAAM,QAAQ,CAAA,GAAA,oQAAA,CAAA,oBAAiB,AAAD,EAAE;YAChC,MAAM,KAAK,GACT,CAAC,SAAU,UAAU,mOAAA,CAAA,YAAS,CAAC,kBAAkB,IAAI,QAAQ;YAC/D,MAAM,MAAM,GACV,CAAC,UAAW,WAAW,mOAAA,CAAA,YAAS,CAAC,kBAAkB,IAAI,QAAQ;YACjE,OAAO,GAAG;QACZ;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4850, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-strikethrough%401.0.7/node_modules/micromark-extension-gfm-strikethrough/dev/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n// To do: next major: expose function instead of object.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions`, to\n * support GFM strikethrough when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmStrikethroughHtml = {\n  enter: {\n    strikethrough() {\n      this.tag('<del>')\n    }\n  },\n  exit: {\n    strikethrough() {\n      this.tag('</del>')\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED,wDAAwD;AAExD;;;;;CAKC;;;AACM,MAAM,uBAAuB;IAClC,OAAO;QACL;YACE,IAAI,CAAC,GAAG,CAAC;QACX;IACF;IACA,MAAM;QACJ;YACE,IAAI,CAAC,GAAG,CAAC;QACX;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4877, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-table%401.0.7/node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n// Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, itâ€™s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, itâ€™s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */\n\n/**\n * Tracks a bunch of edits.\n */\nexport class EditMap {\n  /**\n   * Create a new edit map.\n   */\n  constructor() {\n    /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */\n    this.map = []\n  }\n\n  /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {void}\n   */\n  add(index, remove, add) {\n    addImpl(this, index, remove, add)\n  }\n\n  // To do: not used here.\n  // /**\n  //  * Create an edit: but insert `add` before existing additions.\n  //  *\n  //  * @param {number} index\n  //  * @param {number} remove\n  //  * @param {Array<Event>} add\n  //  * @returns {void}\n  //  */\n  // addBefore(index, remove, add) {\n  //   addImpl(this, index, remove, add, true)\n  // }\n\n  /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {void}\n   */\n  consume(events) {\n    this.map.sort((a, b) => a[0] - b[0])\n\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n    if (this.map.length === 0) {\n      return\n    }\n\n    // To do: if links are added in events, like they are in `markdown-rs`,\n    // this is needed.\n    // // Calculate jumps: where items in the current list move to.\n    // /** @type {Array<Jump>} */\n    // const jumps = []\n    // let index = 0\n    // let addAcc = 0\n    // let removeAcc = 0\n    // while (index < this.map.length) {\n    //   const [at, remove, add] = this.map[index]\n    //   removeAcc += remove\n    //   addAcc += add.length\n    //   jumps.push([at, removeAcc, addAcc])\n    //   index += 1\n    // }\n    //\n    // . shiftLinks(events, jumps)\n\n    let index = this.map.length\n    /** @type {Array<Array<Event>>} */\n    const vecs = []\n    while (index > 0) {\n      index -= 1\n      vecs.push(events.slice(this.map[index][0] + this.map[index][1]))\n      // eslint-disable-next-line unicorn/no-array-push-push\n      vecs.push(this.map[index][2])\n\n      // Truncate rest.\n      events.length = this.map[index][0]\n    }\n\n    vecs.push([...events])\n    events.length = 0\n\n    let slice = vecs.pop()\n\n    while (slice) {\n      events.push(...slice)\n      slice = vecs.pop()\n    }\n\n    // Truncate everything.\n    this.map.length = 0\n  }\n}\n\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {void}\n */\nfunction addImpl(editMap, at, remove, add) {\n  let index = 0\n\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n  if (remove === 0 && add.length === 0) {\n    return\n  }\n\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      editMap.map[index][1] += remove\n\n      // To do: before not used.\n      // if (before) {\n      //   add.push(...editMap.map[index][2])\n      //   editMap.map[index][2] = add\n      // } else {\n      editMap.map[index][2].push(...add)\n      // }\n\n      return\n    }\n\n    index += 1\n  }\n\n  editMap.map.push([at, remove, add])\n}\n\n// /**\n//  * Shift `previous` and `next` links according to `jumps`.\n//  *\n//  * This fixes links in case there are events removed or added between them.\n//  *\n//  * @param {Array<Event>} events\n//  * @param {Array<Jump>} jumps\n//  */\n// function shiftLinks(events, jumps) {\n//   let jumpIndex = 0\n//   let index = 0\n//   let add = 0\n//   let rm = 0\n\n//   while (index < events.length) {\n//     const rmCurr = rm\n\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n//       add = jumps[jumpIndex][2]\n//       rm = jumps[jumpIndex][1]\n//       jumpIndex += 1\n//     }\n\n//     // Ignore items that will be removed.\n//     if (rm > rmCurr) {\n//       index += rm - rmCurr\n//     } else {\n//       console.log('to do: links?', add, rmCurr)\n//       // ?\n//       // if let Some(link) = &events[index].link {\n//       //     if let Some(next) = link.next {\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n//       //             add = jumps[jumpIndex].2;\n//       //             rm = jumps[jumpIndex].1;\n//       //             jumpIndex += 1;\n//       //         }\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n//       //         index = next;\n//       //         continue;\n//       //     }\n//       // }\n//       index += 1\n//     }\n//   }\n// }\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5059, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-table%401.0.7/node_modules/micromark-extension-gfm-table/dev/lib/infer.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef {'left' | 'center' | 'right' | 'none'} Align\n */\n\nimport {ok as assert} from 'uvu/assert'\n\n/**\n * Figure out the alignment of a GFM table.\n *\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {Array<Align>}\n */\nexport function gfmTableAlign(events, index) {\n  assert(events[index][1].type === 'table', 'expected table')\n  let inDelimiterRow = false\n  /** @type {Array<Align>} */\n  const align = []\n\n  while (index < events.length) {\n    const event = events[index]\n\n    if (inDelimiterRow) {\n      if (event[0] === 'enter') {\n        // Start of alignment value: set a new column.\n        // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n        if (event[1].type === 'tableContent') {\n          align.push(\n            events[index + 1][1].type === 'tableDelimiterMarker'\n              ? 'left'\n              : 'none'\n          )\n        }\n      }\n      // Exits:\n      // End of alignment value: change the column.\n      // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n      else if (event[1].type === 'tableContent') {\n        if (events[index - 1][1].type === 'tableDelimiterMarker') {\n          const alignIndex = align.length - 1\n\n          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right'\n        }\n      }\n      // Done!\n      else if (event[1].type === 'tableDelimiterRow') {\n        break\n      }\n    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {\n      inDelimiterRow = true\n    }\n\n    index += 1\n  }\n\n  return align\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;CAEC;;;AAED;;AASO,SAAS,cAAc,MAAM,EAAE,KAAK;IACzC,CAAA,GAAA,0LAAA,CAAA,KAAM,AAAD,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,KAAK,SAAS;IAC1C,IAAI,iBAAiB;IACrB,yBAAyB,GACzB,MAAM,QAAQ,EAAE;IAEhB,MAAO,QAAQ,OAAO,MAAM,CAAE;QAC5B,MAAM,QAAQ,MAAM,CAAC,MAAM;QAE3B,IAAI,gBAAgB;YAClB,IAAI,KAAK,CAAC,EAAE,KAAK,SAAS;gBACxB,8CAA8C;gBAC9C,uDAAuD;gBACvD,IAAI,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,gBAAgB;oBACpC,MAAM,IAAI,CACR,MAAM,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,IAAI,KAAK,yBAC1B,SACA;gBAER;YACF,OAIK,IAAI,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,gBAAgB;gBACzC,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,IAAI,KAAK,wBAAwB;oBACxD,MAAM,aAAa,MAAM,MAAM,GAAG;oBAElC,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,KAAK,SAAS,WAAW;gBAChE;YACF,OAEK,IAAI,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,qBAAqB;gBAC9C;YACF;QACF,OAAO,IAAI,KAAK,CAAC,EAAE,KAAK,WAAW,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,qBAAqB;YACxE,iBAAiB;QACnB;QAEA,SAAS;IACX;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5100, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-table%401.0.7/node_modules/micromark-extension-gfm-table/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {EditMap} from './edit-map.js'\nimport {gfmTableAlign} from './infer.js'\n\n// To do: next major: expose functions.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * table syntax.\n *\n * @type {Extension}\n */\nexport const gfmTable = {\n  flow: {null: {tokenize: tokenizeTable, resolveAll: resolveTable}}\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  let size = 0\n  let sizeB = 0\n  /** @type {boolean | undefined} */\n  let seen\n\n  return start\n\n  /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length - 1\n\n    while (index > -1) {\n      const type = self.events[index][1].type\n      if (\n        type === types.lineEnding ||\n        // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n        type === types.linePrefix\n      )\n        index--\n      else break\n    }\n\n    const tail = index > -1 ? self.events[index][1].type : null\n\n    const next =\n      tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore\n\n    // Donâ€™t allow lazy body rows.\n    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    return next(code)\n  }\n\n  /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBefore(code) {\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n    return headRowStart(code)\n  }\n\n  /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowStart(code) {\n    if (code === codes.verticalBar) {\n      return headRowBreak(code)\n    }\n\n    // To do: micromark-js should let us parse our own whitespace in extensions,\n    // like `markdown-rs`:\n    //\n    // ```js\n    // // 4+ spaces.\n    // if (markdownSpace(code)) {\n    //   return nok(code)\n    // }\n    // ```\n\n    seen = true\n    // Count the first character, that isnâ€™t a pipe, double.\n    sizeB += 1\n    return headRowBreak(code)\n  }\n\n  /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBreak(code) {\n    if (code === codes.eof) {\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we donâ€˜t.\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      // If anything other than one pipe (ignoring whitespace) was used, itâ€™s fine.\n      if (sizeB > 1) {\n        sizeB = 0\n        // To do: check if this works.\n        // Feel free to interrupt:\n        self.interrupt = true\n        effects.exit('tableRow')\n        effects.enter(types.lineEnding)\n        effects.consume(code)\n        effects.exit(types.lineEnding)\n        return headDelimiterStart\n      }\n\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we donâ€˜t.\n      return nok(code)\n    }\n\n    if (markdownSpace(code)) {\n      // To do: check if this is fine.\n      // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n      // State::Retry(space_or_tab(tokenizer))\n      return factorySpace(effects, headRowBreak, types.whitespace)(code)\n    }\n\n    sizeB += 1\n\n    if (seen) {\n      seen = false\n      // Header cell count.\n      size += 1\n    }\n\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      // Whether a delimiter was seen.\n      seen = true\n      return headRowBreak\n    }\n\n    // Anything else is cell data.\n    effects.enter(types.data)\n    return headRowData(code)\n  }\n\n  /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowData(code) {\n    if (\n      code === codes.eof ||\n      code === codes.verticalBar ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit(types.data)\n      return headRowBreak(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash ? headRowEscape : headRowData\n  }\n\n  /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowEscape(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code)\n      return headRowData\n    }\n\n    return headRowData(code)\n  }\n\n  /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterStart(code) {\n    // Reset `interrupt`.\n    self.interrupt = false\n\n    // Note: in `markdown-rs`, we need to handle piercing here too.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    // Track if weâ€™ve seen a `:` or `|`.\n    seen = false\n\n    if (markdownSpace(code)) {\n      assert(self.parser.constructs.disable.null, 'expected `disabled.null`')\n      return factorySpace(\n        effects,\n        headDelimiterBefore,\n        types.linePrefix,\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : constants.tabSize\n      )(code)\n    }\n\n    return headDelimiterBefore(code)\n  }\n\n  /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterBefore(code) {\n    if (code === codes.dash || code === codes.colon) {\n      return headDelimiterValueBefore(code)\n    }\n\n    if (code === codes.verticalBar) {\n      seen = true\n      // If we start with a pipe, we open a cell marker.\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return headDelimiterCellBefore\n    }\n\n    // More whitespace / empty row not allowed at start.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellBefore(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        headDelimiterValueBefore,\n        types.whitespace\n      )(code)\n    }\n\n    return headDelimiterValueBefore(code)\n  }\n\n  /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterValueBefore(code) {\n    // Align: left.\n    if (code === codes.colon) {\n      sizeB += 1\n      seen = true\n\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterLeftAlignmentAfter\n    }\n\n    // Align: none.\n    if (code === codes.dash) {\n      sizeB += 1\n      // To do: seems weird that this *isnâ€™t* left aligned, but that state is used?\n      return headDelimiterLeftAlignmentAfter(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return headDelimiterCellAfter(code)\n    }\n\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterLeftAlignmentAfter(code) {\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller')\n      return headDelimiterFiller(code)\n    }\n\n    // Anything else is not ok after the left-align colon.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterFiller(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return headDelimiterFiller\n    }\n\n    // Align is `center` if it was `left`, `right` otherwise.\n    if (code === codes.colon) {\n      seen = true\n      effects.exit('tableDelimiterFiller')\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterRightAlignmentAfter\n    }\n\n    effects.exit('tableDelimiterFiller')\n    return headDelimiterRightAlignmentAfter(code)\n  }\n\n  /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterRightAlignmentAfter(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        headDelimiterCellAfter,\n        types.whitespace\n      )(code)\n    }\n\n    return headDelimiterCellAfter(code)\n  }\n\n  /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellAfter(code) {\n    if (code === codes.verticalBar) {\n      return headDelimiterBefore(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      // Exit when:\n      // * there was no `:` or `|` at all (itâ€™s a thematic break or setext\n      //   underline instead)\n      // * the header cell count is not the delimiter cell count\n      if (!seen || size !== sizeB) {\n        return headDelimiterNok(code)\n      }\n\n      // Note: in markdown-rs`, a reset is needed here.\n      effects.exit('tableDelimiterRow')\n      effects.exit('tableHead')\n      // To do: in `markdown-rs`, resolvers need to be registered manually.\n      // effects.register_resolver(ResolveName::GfmTable)\n      return ok(code)\n    }\n\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterNok(code) {\n    // Note: in `markdown-rs`, we need to reset, in `micromark-js` we donâ€˜t.\n    return nok(code)\n  }\n\n  /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowStart(code) {\n    // Note: in `markdown-rs` we need to manually take care of a prefix,\n    // but in `micromark-js` that is done for us, so if weâ€™re here, weâ€™re\n    // never at whitespace.\n    effects.enter('tableRow')\n    return bodyRowBreak(code)\n  }\n\n  /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowBreak(code) {\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return bodyRowBreak\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('tableRow')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, bodyRowBreak, types.whitespace)(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter(types.data)\n    return bodyRowData(code)\n  }\n\n  /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowData(code) {\n    if (\n      code === codes.eof ||\n      code === codes.verticalBar ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit(types.data)\n      return bodyRowBreak(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash ? bodyRowEscape : bodyRowData\n  }\n\n  /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowEscape(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code)\n      return bodyRowData\n    }\n\n    return bodyRowData(code)\n  }\n}\n\n/** @type {Resolver} */\n// eslint-disable-next-line complexity\nfunction resolveTable(events, context) {\n  let index = -1\n  let inFirstCellAwaitingPipe = true\n  /** @type {RowKind} */\n  let rowKind = 0\n  /** @type {Range} */\n  let lastCell = [0, 0, 0, 0]\n  /** @type {Range} */\n  let cell = [0, 0, 0, 0]\n  let afterHeadAwaitingFirstBodyRow = false\n  let lastTableEnd = 0\n  /** @type {Token | undefined} */\n  let currentTable\n  /** @type {Token | undefined} */\n  let currentBody\n  /** @type {Token | undefined} */\n  let currentCell\n\n  const map = new EditMap()\n\n  while (++index < events.length) {\n    const event = events[index]\n    const token = event[1]\n\n    if (event[0] === 'enter') {\n      // Start of head.\n      if (token.type === 'tableHead') {\n        afterHeadAwaitingFirstBodyRow = false\n\n        // Inject previous (body end and) table end.\n        if (lastTableEnd !== 0) {\n          assert(currentTable, 'there should be a table opening')\n          flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n          currentBody = undefined\n          lastTableEnd = 0\n        }\n\n        // Inject table start.\n        currentTable = {\n          type: 'table',\n          start: Object.assign({}, token.start),\n          // Note: correct end is set later.\n          end: Object.assign({}, token.end)\n        }\n        map.add(index, 0, [['enter', currentTable, context]])\n      } else if (\n        token.type === 'tableRow' ||\n        token.type === 'tableDelimiterRow'\n      ) {\n        inFirstCellAwaitingPipe = true\n        currentCell = undefined\n        lastCell = [0, 0, 0, 0]\n        cell = [0, index + 1, 0, 0]\n\n        // Inject table body start.\n        if (afterHeadAwaitingFirstBodyRow) {\n          afterHeadAwaitingFirstBodyRow = false\n          currentBody = {\n            type: 'tableBody',\n            start: Object.assign({}, token.start),\n            // Note: correct end is set later.\n            end: Object.assign({}, token.end)\n          }\n          map.add(index, 0, [['enter', currentBody, context]])\n        }\n\n        rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1\n      }\n      // Cell data.\n      else if (\n        rowKind &&\n        (token.type === types.data ||\n          token.type === 'tableDelimiterMarker' ||\n          token.type === 'tableDelimiterFiller')\n      ) {\n        inFirstCellAwaitingPipe = false\n\n        // First value in cell.\n        if (cell[2] === 0) {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n            lastCell = [0, 0, 0, 0]\n          }\n\n          cell[2] = index\n        }\n      } else if (token.type === 'tableCellDivider') {\n        if (inFirstCellAwaitingPipe) {\n          inFirstCellAwaitingPipe = false\n        } else {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n          }\n\n          lastCell = cell\n          cell = [lastCell[1], index, 0, 0]\n        }\n      }\n    }\n    // Exit events.\n    else if (token.type === 'tableHead') {\n      afterHeadAwaitingFirstBodyRow = true\n      lastTableEnd = index\n    } else if (\n      token.type === 'tableRow' ||\n      token.type === 'tableDelimiterRow'\n    ) {\n      lastTableEnd = index\n\n      if (lastCell[1] !== 0) {\n        cell[0] = cell[1]\n        currentCell = flushCell(\n          map,\n          context,\n          lastCell,\n          rowKind,\n          index,\n          currentCell\n        )\n      } else if (cell[1] !== 0) {\n        currentCell = flushCell(map, context, cell, rowKind, index, currentCell)\n      }\n\n      rowKind = 0\n    } else if (\n      rowKind &&\n      (token.type === types.data ||\n        token.type === 'tableDelimiterMarker' ||\n        token.type === 'tableDelimiterFiller')\n    ) {\n      cell[3] = index\n    }\n  }\n\n  if (lastTableEnd !== 0) {\n    assert(currentTable, 'expected table opening')\n    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n  }\n\n  map.consume(context.events)\n\n  // To do: move this into `html`, when events are exposed there.\n  // Thatâ€™s what `markdown-rs` does.\n  // That needs updates to `mdast-util-gfm-table`.\n  index = -1\n  while (++index < context.events.length) {\n    const event = context.events[index]\n    if (event[0] === 'enter' && event[1].type === 'table') {\n      event[1]._align = gfmTableAlign(context.events, index)\n    }\n  }\n\n  return events\n}\n\n/// Generate a cell.\n/**\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {Range} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */\n// eslint-disable-next-line max-params\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n  const groupName =\n    rowKind === 1\n      ? 'tableHeader'\n      : rowKind === 2\n      ? 'tableDelimiter'\n      : 'tableData'\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n  const valueName = 'tableContent'\n\n  // Insert an exit for the previous cell, if there is one.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //          ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[0] !== 0) {\n    assert(previousCell, 'expected previous cell enter')\n    previousCell.end = Object.assign({}, getPoint(context.events, range[0]))\n    map.add(range[0], 0, [['exit', previousCell, context]])\n  }\n\n  // Insert enter of this cell.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //           ^-- enter\n  //           ^^^^-- this cell\n  // ```\n  const now = getPoint(context.events, range[1])\n  previousCell = {\n    type: groupName,\n    start: Object.assign({}, now),\n    // Note: correct end is set later.\n    end: Object.assign({}, now)\n  }\n  map.add(range[1], 0, [['enter', previousCell, context]])\n\n  // Insert text start at first data start and end at last data end, and\n  // remove events between.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //            ^-- enter\n  //             ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[2] !== 0) {\n    const relatedStart = getPoint(context.events, range[2])\n    const relatedEnd = getPoint(context.events, range[3])\n    /** @type {Token} */\n    const valueToken = {\n      type: valueName,\n      start: Object.assign({}, relatedStart),\n      end: Object.assign({}, relatedEnd)\n    }\n    map.add(range[2], 0, [['enter', valueToken, context]])\n    assert(range[3] !== 0)\n\n    if (rowKind !== 2) {\n      // Fix positional info on remaining events\n      const start = context.events[range[2]]\n      const end = context.events[range[3]]\n      start[1].end = Object.assign({}, end[1].end)\n      start[1].type = types.chunkText\n      start[1].contentType = constants.contentTypeText\n\n      // Remove if needed.\n      if (range[3] > range[2] + 1) {\n        const a = range[2] + 1\n        const b = range[3] - range[2] - 1\n        map.add(a, b, [])\n      }\n    }\n\n    map.add(range[3] + 1, 0, [['exit', valueToken, context]])\n  }\n\n  // Insert an exit for the last cell, if at the row end.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //                    ^-- exit\n  //               ^^^^^^-- this cell (the last one contains two â€œbetweenâ€ parts)\n  // ```\n  if (rowEnd !== undefined) {\n    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd))\n    map.add(rowEnd, 0, [['exit', previousCell, context]])\n    previousCell = undefined\n  }\n\n  return previousCell\n}\n\n/**\n * Generate table end (and table body end).\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */\n// eslint-disable-next-line max-params\nfunction flushTableEnd(map, context, index, table, tableBody) {\n  /** @type {Array<Event>} */\n  const exits = []\n  const related = getPoint(context.events, index)\n\n  if (tableBody) {\n    tableBody.end = Object.assign({}, related)\n    exits.push(['exit', tableBody, context])\n  }\n\n  table.end = Object.assign({}, related)\n  exits.push(['exit', table, context])\n\n  map.add(index + 1, 0, exits)\n}\n\n/**\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {readonly Point}\n */\nfunction getPoint(events, index) {\n  const event = events[index]\n  const side = event[0] === 'enter' ? 'start' : 'end'\n  return event[1][side]\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5934, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-table%401.0.7/node_modules/micromark-extension-gfm-table/dev/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {import('./infer.js').Align} Align\n */\n\nimport {ok as assert} from 'uvu/assert'\n\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}\n\n// To do: next major: expose functions.\n// To do: next major: use `infer` here, when all events are exposed.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to support\n * GFM tables when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmTableHtml = {\n  enter: {\n    table(token) {\n      const tableAlign = token._align\n      assert(tableAlign, 'expected `_align`')\n      this.lineEndingIfNeeded()\n      this.tag('<table>')\n      this.setData('tableAlign', tableAlign)\n    },\n    tableBody() {\n      this.tag('<tbody>')\n    },\n    tableData() {\n      const tableAlign = this.getData('tableAlign')\n      const tableColumn = this.getData('tableColumn')\n      assert(tableAlign, 'expected `tableAlign`')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n      const align = alignment[tableAlign[tableColumn]]\n\n      if (align === undefined) {\n        // Capture results to ignore them.\n        this.buffer()\n      } else {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + align + '>')\n      }\n    },\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('<thead>')\n    },\n    tableHeader() {\n      const tableAlign = this.getData('tableAlign')\n      const tableColumn = this.getData('tableColumn')\n      assert(tableAlign, 'expected `tableAlign`')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n      const align = alignment[tableAlign[tableColumn]]\n      this.lineEndingIfNeeded()\n      this.tag('<th' + align + '>')\n    },\n    tableRow() {\n      this.setData('tableColumn', 0)\n      this.lineEndingIfNeeded()\n      this.tag('<tr>')\n    }\n  },\n  exit: {\n    // Overwrite the default code text data handler to unescape escaped pipes when\n    // they are in tables.\n    codeTextData(token) {\n      let value = this.sliceSerialize(token)\n\n      if (this.getData('tableAlign')) {\n        value = value.replace(/\\\\([\\\\|])/g, replace)\n      }\n\n      this.raw(this.encode(value))\n    },\n    table() {\n      this.setData('tableAlign')\n      // Note: we donâ€™t set `slurpAllLineEndings` anymore, in delimiter rows,\n      // but we do need to reset it to match a funky newline GH generates for\n      // list items combined with tables.\n      this.setData('slurpAllLineEndings')\n      this.lineEndingIfNeeded()\n      this.tag('</table>')\n    },\n    tableBody() {\n      this.lineEndingIfNeeded()\n      this.tag('</tbody>')\n    },\n    tableData() {\n      const tableAlign = this.getData('tableAlign')\n      const tableColumn = this.getData('tableColumn')\n      assert(tableAlign, 'expected `tableAlign`')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n\n      if (tableColumn in tableAlign) {\n        this.tag('</td>')\n        this.setData('tableColumn', tableColumn + 1)\n      } else {\n        // Stop capturing.\n        this.resume()\n      }\n    },\n    tableHead() {\n      this.lineEndingIfNeeded()\n      this.tag('</thead>')\n    },\n    tableHeader() {\n      const tableColumn = this.getData('tableColumn')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n      this.tag('</th>')\n      this.setData('tableColumn', tableColumn + 1)\n    },\n    tableRow() {\n      const tableAlign = this.getData('tableAlign')\n      let tableColumn = this.getData('tableColumn')\n      assert(tableAlign, 'expected `tableAlign`')\n      assert(typeof tableColumn === 'number', 'expected `tableColumn`')\n\n      while (tableColumn < tableAlign.length) {\n        this.lineEndingIfNeeded()\n        this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>')\n        tableColumn++\n      }\n\n      this.setData('tableColumn', tableColumn)\n      this.lineEndingIfNeeded()\n      this.tag('</tr>')\n    }\n  }\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes donâ€™t (but canâ€™t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6068, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-tagfilter%401.0.2/node_modules/micromark-extension-gfm-tagfilter/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n// An opening or closing tag start, followed by a case-insensitive specific tag name,\n// followed by HTML whitespace, a greater than, or a slash.\nconst reFlow =\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi\n\n// As HTML (text) parses tags separately (and very strictly), we donâ€™t need to be\n// global.\nconst reText = new RegExp('^' + reFlow.source, 'i')\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions`, to\n * support GitHubâ€™s weird and useless tagfilter when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmTagfilterHtml = {\n  exit: {\n    htmlFlowData(token) {\n      exitHtmlData.call(this, token, reFlow)\n    },\n    htmlTextData(token) {\n      exitHtmlData.call(this, token, reText)\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @param {Token} token\n * @param {RegExp} filter\n */\nfunction exitHtmlData(token, filter) {\n  let value = this.sliceSerialize(token)\n\n  if (this.options.allowDangerousHtml) {\n    value = value.replace(filter, '&lt;$1$2')\n  }\n\n  this.raw(this.encode(value))\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED,qFAAqF;AACrF,2DAA2D;;;;AAC3D,MAAM,SACJ;AAEF,iFAAiF;AACjF,UAAU;AACV,MAAM,SAAS,IAAI,OAAO,MAAM,OAAO,MAAM,EAAE;AAQxC,MAAM,mBAAmB;IAC9B,MAAM;QACJ,cAAa,KAAK;YAChB,aAAa,IAAI,CAAC,IAAI,EAAE,OAAO;QACjC;QACA,cAAa,KAAK;YAChB,aAAa,IAAI,CAAC,IAAI,EAAE,OAAO;QACjC;IACF;AACF;AAEA;;;;CAIC,GACD,SAAS,aAAa,KAAK,EAAE,MAAM;IACjC,IAAI,QAAQ,IAAI,CAAC,cAAc,CAAC;IAEhC,IAAI,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE;QACnC,QAAQ,MAAM,OAAO,CAAC,QAAQ;IAChC;IAEA,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC;AACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-task-list-item%401.0.5/node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\nconst tasklistCheck = {tokenize: tokenizeTasklistCheck}\n\n// To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions`, to\n * enable GFM task list items syntax.\n *\n * @type {Extension}\n */\nexport const gfmTaskListItem = {\n  text: {[codes.leftSquareBracket]: tasklistCheck}\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n\n  return open\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n\n    if (\n      // Exit if thereâ€™s stuff before.\n      self.previous !== codes.eof ||\n      // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n\n    if (code === codes.uppercaseX || code === codes.lowercaseX) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code)\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check({tokenize: spaceThenNonSpace}, ok, nok)(code)\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, types.whitespace)\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means thereâ€™s content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === codes.eof ? nok(code) : ok(code)\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;AAED;AACA;AACA;AAKA;AACA;;;;;;AAEA,MAAM,gBAAgB;IAAC,UAAU;AAAqB;AAU/C,MAAM,kBAAkB;IAC7B,MAAM;QAAC,CAAC,+NAAA,CAAA,QAAK,CAAC,iBAAiB,CAAC,EAAE;IAAa;AACjD;AAEA;;;CAGC,GACD,SAAS,sBAAsB,OAAO,EAAE,EAAE,EAAE,GAAG;IAC7C,MAAM,OAAO,IAAI;IAEjB,OAAO;;;IAEP;;;;;;;;;GASC,GACD,SAAS,KAAK,IAAI;QAChB,CAAA,GAAA,0LAAA,CAAA,KAAM,AAAD,EAAE,SAAS,+NAAA,CAAA,QAAK,CAAC,iBAAiB,EAAE;QAEzC,IACE,gCAAgC;QAChC,KAAK,QAAQ,KAAK,+NAAA,CAAA,QAAK,CAAC,GAAG,IAC3B,qEAAqE;QACrE,QAAQ;QACR,CAAC,KAAK,kCAAkC,EACxC;YACA,OAAO,IAAI;QACb;QAEA,QAAQ,KAAK,CAAC;QACd,QAAQ,KAAK,CAAC;QACd,QAAQ,OAAO,CAAC;QAChB,QAAQ,IAAI,CAAC;QACb,OAAO;IACT;IAEA;;;;;;;;;GASC,GACD,SAAS,OAAO,IAAI;QAClB,4CAA4C;QAC5C,2EAA2E;QAC3E,gDAAgD;QAChD,IAAI,CAAA,GAAA,4OAAA,CAAA,4BAAyB,AAAD,EAAE,OAAO;YACnC,QAAQ,KAAK,CAAC;YACd,QAAQ,OAAO,CAAC;YAChB,QAAQ,IAAI,CAAC;YACb,OAAO;QACT;QAEA,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,EAAE;YAC1D,QAAQ,KAAK,CAAC;YACd,QAAQ,OAAO,CAAC;YAChB,QAAQ,IAAI,CAAC;YACb,OAAO;QACT;QAEA,OAAO,IAAI;IACb;IAEA;;;;;;;;;GASC,GACD,SAAS,MAAM,IAAI;QACjB,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,kBAAkB,EAAE;YACrC,QAAQ,KAAK,CAAC;YACd,QAAQ,OAAO,CAAC;YAChB,QAAQ,IAAI,CAAC;YACb,QAAQ,IAAI,CAAC;YACb,OAAO;QACT;QAEA,OAAO,IAAI;IACb;IAEA;;GAEC,GACD,SAAS,MAAM,IAAI;QACjB,gEAAgE;QAChE,IAAI,CAAA,GAAA,4OAAA,CAAA,qBAAkB,AAAD,EAAE,OAAO;YAC5B,OAAO,GAAG;QACZ;QAEA,gBAAgB;QAChB,0BAA0B;QAC1B,IAAI,CAAA,GAAA,4OAAA,CAAA,gBAAa,AAAD,EAAE,OAAO;YACvB,OAAO,QAAQ,KAAK,CAAC;gBAAC,UAAU;YAAiB,GAAG,IAAI,KAAK;QAC/D;QAEA,sCAAsC;QACtC,OAAO,IAAI;IACb;AACF;AAEA;;;CAGC,GACD,SAAS,kBAAkB,OAAO,EAAE,EAAE,EAAE,GAAG;IACzC,OAAO,CAAA,GAAA,0OAAA,CAAA,eAAY,AAAD,EAAE,SAAS,OAAO,+NAAA,CAAA,QAAK,CAAC,UAAU;;;IAEpD;;;;;;;;;GASC,GACD,SAAS,MAAM,IAAI;QACjB,uCAAuC;QACvC,+CAA+C;QAC/C,kCAAkC;QAClC,yBAAyB;QACzB,OAAO,SAAS,+NAAA,CAAA,QAAK,CAAC,GAAG,GAAG,IAAI,QAAQ,GAAG;IAC7C;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6255, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm-task-list-item%401.0.5/node_modules/micromark-extension-gfm-task-list-item/dev/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n// To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `htmlExtensions` to\n * support GFM task list items when serializing to HTML.\n *\n * @type {HtmlExtension}\n */\nexport const gfmTaskListItemHtml = {\n  enter: {\n    taskListCheck() {\n      this.tag('<input type=\"checkbox\" disabled=\"\" ')\n    }\n  },\n  exit: {\n    taskListCheck() {\n      this.tag('/>')\n    },\n    taskListCheckValueChecked() {\n      this.tag('checked=\"\" ')\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED,wDAAwD;AAExD;;;;;CAKC;;;AACM,MAAM,sBAAsB;IACjC,OAAO;QACL;YACE,IAAI,CAAC,GAAG,CAAC;QACX;IACF;IACA,MAAM;QACJ;YACE,IAAI,CAAC,GAAG,CAAC;QACX;QACA;YACE,IAAI,CAAC,GAAG,CAAC;QACX;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6285, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-extension-gfm%402.0.3/node_modules/micromark-extension-gfm/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions\n * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\nimport {\n  combineExtensions,\n  combineHtmlExtensions\n} from 'micromark-util-combine-extensions'\nimport {\n  gfmAutolinkLiteral,\n  gfmAutolinkLiteralHtml\n} from 'micromark-extension-gfm-autolink-literal'\nimport {gfmFootnote, gfmFootnoteHtml} from 'micromark-extension-gfm-footnote'\nimport {\n  gfmStrikethrough,\n  gfmStrikethroughHtml\n} from 'micromark-extension-gfm-strikethrough'\nimport {gfmTable, gfmTableHtml} from 'micromark-extension-gfm-table'\nimport {gfmTagfilterHtml} from 'micromark-extension-gfm-tagfilter'\nimport {\n  gfmTaskListItem,\n  gfmTaskListItemHtml\n} from 'micromark-extension-gfm-task-list-item'\n\n/**\n * Create an extension for `micromark` to enable GFM syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n *\n *   Passed to `micromark-extens-gfm-strikethrough`.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   syntax.\n */\nexport function gfm(options) {\n  return combineExtensions([\n    gfmAutolinkLiteral,\n    gfmFootnote(),\n    gfmStrikethrough(options),\n    gfmTable,\n    gfmTaskListItem\n  ])\n}\n\n/**\n * Create an extension for `micromark` to support GFM when serializing to HTML.\n *\n * @param {HtmlOptions | null | undefined} [options]\n *   Configuration.\n *\n *   Passed to `micromark-extens-gfm-footnote`.\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM when serializing to HTML.\n */\nexport function gfmHtml(options) {\n  return combineHtmlExtensions([\n    gfmAutolinkLiteralHtml,\n    gfmFootnoteHtml(options),\n    gfmStrikethroughHtml,\n    gfmTableHtml,\n    gfmTagfilterHtml,\n    gfmTaskListItemHtml\n  ])\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAED;AAIA;AAAA;AAIA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AACA;AAAA;;;;;;;;AAgBO,SAAS,IAAI,OAAO;IACzB,OAAO,CAAA,GAAA,6PAAA,CAAA,oBAAiB,AAAD,EAAE;QACvB,gSAAA,CAAA,qBAAkB;QAClB,CAAA,GAAA,0QAAA,CAAA,cAAW,AAAD;QACV,CAAA,GAAA,oRAAA,CAAA,mBAAgB,AAAD,EAAE;QACjB,oQAAA,CAAA,WAAQ;QACR,kSAAA,CAAA,kBAAe;KAChB;AACH;AAaO,SAAS,QAAQ,OAAO;IAC7B,OAAO,CAAA,GAAA,6PAAA,CAAA,wBAAqB,AAAD,EAAE;QAC3B,8RAAA,CAAA,yBAAsB;QACtB,CAAA,GAAA,wQAAA,CAAA,kBAAe,AAAD,EAAE;QAChB,kRAAA,CAAA,uBAAoB;QACpB,kQAAA,CAAA,eAAY;QACZ,6PAAA,CAAA,mBAAgB;QAChB,gSAAA,CAAA,sBAAmB;KACpB;AACH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6336, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/escape-string-regexp%405.0.0/node_modules/escape-string-regexp/index.js"],"sourcesContent":["export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when itâ€™s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patternsâ€™ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n"],"names":[],"mappings":";;;AAAe,SAAS,mBAAmB,MAAM;IAChD,IAAI,OAAO,WAAW,UAAU;QAC/B,MAAM,IAAI,UAAU;IACrB;IAEA,kFAAkF;IAClF,6JAA6J;IAC7J,OAAO,OACL,OAAO,CAAC,uBAAuB,QAC/B,OAAO,CAAC,MAAM;AACjB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6351, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/unist-util-is%405.2.1/node_modules/unist-util-is/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The nodeâ€™s position in its parent.\n * @param parent\n *   The nodeâ€™s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youâ€™re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6566, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/unist-util-visit-parents%405.1.3/node_modules/unist-util-visit-parents/lib/color.browser.js"],"sourcesContent":["/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;AACM,SAAS,MAAM,CAAC;IACrB,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6579, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/unist-util-visit-parents%405.1.3/node_modules/unist-util-visit-parents/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodeâ€™s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;;;;;;;;;;;;CAkBC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCC,GAED;;;;;;;;;CASC;;;;;;AAED;AACA;;;AAKO,MAAM,WAAW;AAKjB,MAAM,OAAO;AAKb,MAAM,OAAO;AA+Bb,MAAM,eAQT;;;;;;KAMC,GACD,SAAU,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO;IACpC,IAAI,OAAO,SAAS,cAAc,OAAO,YAAY,YAAY;QAC/D,UAAU;QACV,2DAA2D;QAC3D,UAAU;QACV,OAAO;IACT;IAEA,MAAM,KAAK,CAAA,GAAA,sNAAA,CAAA,UAAO,AAAD,EAAE;IACnB,MAAM,OAAO,UAAU,CAAC,IAAI;IAE5B,QAAQ,MAAM,WAAW,EAAE;IAE3B;;;;OAIC,GACD,SAAS,QAAQ,IAAI,EAAE,KAAK,EAAE,OAAO;QACnC,oCAAoC,GACpC,yBAAyB;QACzB,MAAM,QAAQ,QAAQ,OAAO,SAAS,WAAW,OAAO,CAAC;QAEzD,IAAI,OAAO,MAAM,IAAI,KAAK,UAAU;YAClC,MAAM,OACJ,SAAS;YACT,OAAO,MAAM,OAAO,KAAK,WACrB,MAAM,OAAO,GAEf,OAAO,MAAM,IAAI,KAAK,WACpB,MAAM,IAAI,GACV;YAEN,OAAO,cAAc,CAAC,OAAO,QAAQ;gBACnC,OACE,WAAW,CAAA,GAAA,6PAAA,CAAA,QAAK,AAAD,EAAE,KAAK,IAAI,GAAG,CAAC,OAAO,MAAM,OAAO,MAAM,EAAE,KAAK;YACnE;QACF;QAEA,OAAO;;;QAEP,SAAS;YACP,wBAAwB,GACxB,IAAI,SAAS,EAAE;YACf,wBAAwB,GACxB,IAAI;YACJ,mBAAmB,GACnB,IAAI;YACJ,0BAA0B,GAC1B,IAAI;YAEJ,IAAI,CAAC,QAAQ,GAAG,MAAM,OAAO,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAO;gBACjE,SAAS,SAAS,QAAQ,MAAM;gBAEhC,IAAI,MAAM,CAAC,EAAE,KAAK,MAAM;oBACtB,OAAO;gBACT;YACF;YAEA,wCAAwC;YACxC,IAAI,KAAK,QAAQ,IAAI,MAAM,CAAC,EAAE,KAAK,MAAM;gBACvC,wCAAwC;gBACxC,SAAS,CAAC,UAAU,KAAK,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI;gBACjD,wCAAwC;gBACxC,eAAe,QAAQ,MAAM,CAAC;gBAE9B,wCAAwC;gBACxC,MAAO,SAAS,CAAC,KAAK,SAAS,KAAK,QAAQ,CAAC,MAAM,CAAE;oBACnD,wCAAwC;oBACxC,YAAY,QAAQ,KAAK,QAAQ,CAAC,OAAO,EAAE,QAAQ;oBAEnD,IAAI,SAAS,CAAC,EAAE,KAAK,MAAM;wBACzB,OAAO;oBACT;oBAEA,SACE,OAAO,SAAS,CAAC,EAAE,KAAK,WAAW,SAAS,CAAC,EAAE,GAAG,SAAS;gBAC/D;YACF;YAEA,OAAO;QACT;IACF;AACF;AAGJ;;;;;;;CAOC,GACD,SAAS,SAAS,KAAK;IACrB,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,OAAO;IACT;IAEA,IAAI,OAAO,UAAU,UAAU;QAC7B,OAAO;YAAC;YAAU;SAAM;IAC1B;IAEA,OAAO;QAAC;KAAM;AAChB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6747, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-find-and-replace%402.2.2/node_modules/mdast-util-find-and-replace/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {Extract<Node, MdastParent>} Parent\n * @typedef {Exclude<Parent, Root>} ContentParent\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[Root, ...Array<ContentParent>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) â€” whole match\n *   * `...capture` (`Array<string>`) â€” matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) â€” info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * â€¦or when `false`, do not replace at all\n *   * â€¦or when `string`, replace with a text node of that value\n *   * â€¦or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {string | RegExp} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n *   Several find and replaces, in object form.\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n * @typedef {string | ReplaceFunction} Replace\n *   Thing to replace with.\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore.\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param tree\n *   Tree to change.\n * @param find\n *   Patterns to find.\n * @param replace\n *   Things to replace with (when `find` is `Find`) or configuration.\n * @param options\n *   Configuration (when `find` is not `Find`).\n * @returns\n *   Given, modified, tree.\n */\n// To do: next major: remove `find` & `replace` combo, remove schema.\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\n   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\n   * )}\n   **/\n  (\n    /**\n     * @template {Node} Tree\n     * @param {Tree} tree\n     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\n     * @param {Replace | Options | null | undefined} [replace]\n     * @param {Options | null | undefined} [options]\n     * @returns {Tree}\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options | null | undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error donâ€™t expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error donâ€™t expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      // To do next major: donâ€™t return the given tree.\n      return tree\n\n      /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent | undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = parents[index]\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error: TS doesnâ€™t understand but itâ€™s perfect.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, parents)\n        }\n      }\n\n      /**\n       * Handle a text node which is not in an ignored parent.\n       *\n       * @param {Text} node\n       *   Text node.\n       * @param {Array<Parent>} parents\n       *   Parents.\n       * @returns {VisitorResult}\n       *   Result.\n       */\n      function handler(node, parents) {\n        const parent = parents[parents.length - 1]\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        const index = parent.children.indexOf(node)\n        let change = false\n        /** @type {Array<PhrasingContent>} */\n        let nodes = []\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          const position = match.index\n          /** @type {RegExpMatchObject} */\n          const matchObject = {\n            index: match.index,\n            input: match.input,\n            // @ts-expect-error: stack is fine.\n            stack: [...parents, node]\n          }\n          let value = replace(...match, matchObject)\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          // It wasnâ€™t a match after all.\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n            change = true\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (change) {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        } else {\n          nodes = [node]\n        }\n\n        return index + nodes.length\n      }\n    }\n  )\n\n/**\n * Turn a schema into pairs.\n *\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7001, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-gfm-autolink-literal%401.0.3/node_modules/mdast-util-gfm-autolink-literal/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction\n * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject\n */\n\nimport {ccount} from 'ccount'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n// To do: next major: expose functions instead of extensions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM autolink literals.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmAutolinkLiteralFromMarkdown = {\n  transforms: [transformGfmAutolinkLiterals],\n  enter: {\n    literalAutolink: enterLiteralAutolink,\n    literalAutolinkEmail: enterLiteralAutolinkValue,\n    literalAutolinkHttp: enterLiteralAutolinkValue,\n    literalAutolinkWww: enterLiteralAutolinkValue\n  },\n  exit: {\n    literalAutolink: exitLiteralAutolink,\n    literalAutolinkEmail: exitLiteralAutolinkEmail,\n    literalAutolinkHttp: exitLiteralAutolinkHttp,\n    literalAutolinkWww: exitLiteralAutolinkWww\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmAutolinkLiteralToMarkdown = {\n  unsafe: [\n    {\n      character: '@',\n      before: '[+\\\\-.\\\\w]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {\n      character: '.',\n      before: '[Ww]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {character: ':', before: '[ps]', after: '\\\\/', inConstruct, notInConstruct}\n  ]\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = /** @type {Link} */ (this.stack[this.stack.length - 1])\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/g, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Link | Array<PhrasingContent> | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    (!email || code !== 47)\n  )\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7256, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/decode-named-character-reference%401.2.0/node_modules/decode-named-character-reference/index.dom.js"],"sourcesContent":["/// <reference lib=\"dom\" />\n\n/* global document */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string | false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const character = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `Â¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  if (\n    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n    // yield `null`.\n    character.charCodeAt(character.length - 1) === 59 /* `;` */ &&\n    value !== 'semi'\n  ) {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return character === characterReference ? false : character\n}\n"],"names":[],"mappings":"AAAA,2BAA2B;AAE3B,mBAAmB;;;AAEnB,MAAM,UAAU,SAAS,aAAa,CAAC;AAMhC,SAAS,8BAA8B,KAAK;IACjD,MAAM,qBAAqB,MAAM,QAAQ;IACzC,QAAQ,SAAS,GAAG;IACpB,MAAM,YAAY,QAAQ,WAAW;IAErC,uEAAuE;IACvE,8EAA8E;IAC9E,iEAAiE;IACjE,0EAA0E;IAC1E,6EAA6E;IAC7E,6BAA6B;IAC7B,IACE,2EAA2E;IAC3E,gBAAgB;IAChB,UAAU,UAAU,CAAC,UAAU,MAAM,GAAG,OAAO,GAAG,OAAO,OACzD,UAAU,QACV;QACA,OAAO;IACT;IAEA,2EAA2E;IAC3E,aAAa;IACb,2EAA2E;IAC3E,gBAAgB;IAChB,OAAO,cAAc,qBAAqB,QAAQ;AACpD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7286, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-decode-numeric-character-reference%401.1.0/node_modules/micromark-util-decode-numeric-character-reference/dev/index.js"],"sourcesContent":["import {codes} from 'micromark-util-symbol/codes.js'\nimport {values} from 'micromark-util-symbol/values.js'\n\n/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCharCode(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n\n  if (\n    // C0 except for HT, LF, FF, CR, space.\n    code < codes.ht ||\n    code === codes.vt ||\n    (code > codes.cr && code < codes.space) ||\n    // Control character (DEL) of C0, and C1 controls.\n    (code > codes.tilde && code < 160) ||\n    // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) ||\n    // Noncharacters.\n    (code > 64975 && code < 65008) ||\n    /* eslint-disable no-bitwise */\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 ||\n    /* eslint-enable no-bitwise */\n    // Out of range\n    code > 1114111\n  ) {\n    return values.replacementCharacter\n  }\n\n  return String.fromCharCode(code)\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAgBO,SAAS,gCAAgC,KAAK,EAAE,IAAI;IACzD,MAAM,OAAO,OAAO,QAAQ,CAAC,OAAO;IAEpC,IACE,uCAAuC;IACvC,OAAO,+NAAA,CAAA,QAAK,CAAC,EAAE,IACf,SAAS,+NAAA,CAAA,QAAK,CAAC,EAAE,IAChB,OAAO,+NAAA,CAAA,QAAK,CAAC,EAAE,IAAI,OAAO,+NAAA,CAAA,QAAK,CAAC,KAAK,IAErC,OAAO,+NAAA,CAAA,QAAK,CAAC,KAAK,IAAI,OAAO,OAE7B,OAAO,SAAS,OAAO,SAEvB,OAAO,SAAS,OAAO,SACxB,6BAA6B,GAC7B,CAAC,OAAO,KAAK,MAAM,SACnB,CAAC,OAAO,KAAK,MAAM,SACnB,4BAA4B,GAC5B,eAAe;IACf,OAAO,SACP;QACA,OAAO,gOAAA,CAAA,SAAM,CAAC,oBAAoB;IACpC;IAEA,OAAO,OAAO,YAAY,CAAC;AAC7B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7306, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/micromark-util-decode-string%401.1.0/node_modules/micromark-util-decode-string/dev/index.js"],"sourcesContent":["import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\n\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The â€œstringâ€ content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0)\n\n  if (head === codes.numberSign) {\n    const head = $2.charCodeAt(1)\n    const hex = head === codes.lowercaseX || head === codes.uppercaseX\n    return decodeNumericCharacterReference(\n      $2.slice(hex ? 2 : 1),\n      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal\n    )\n  }\n\n  return decodeNamedCharacterReference($2) || $0\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,6BACJ;AAcK,SAAS,aAAa,KAAK;IAChC,OAAO,MAAM,OAAO,CAAC,4BAA4B;AACnD;AAEA;;;;;CAKC,GACD,SAAS,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE;IACxB,IAAI,IAAI;QACN,UAAU;QACV,OAAO;IACT;IAEA,aAAa;IACb,MAAM,OAAO,GAAG,UAAU,CAAC;IAE3B,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,EAAE;QAC7B,MAAM,OAAO,GAAG,UAAU,CAAC;QAC3B,MAAM,MAAM,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU,IAAI,SAAS,+NAAA,CAAA,QAAK,CAAC,UAAU;QAClE,OAAO,CAAA,GAAA,gTAAA,CAAA,kCAA+B,AAAD,EACnC,GAAG,KAAK,CAAC,MAAM,IAAI,IACnB,MAAM,mOAAA,CAAA,YAAS,CAAC,sBAAsB,GAAG,mOAAA,CAAA,YAAS,CAAC,kBAAkB;IAEzE;IAEA,OAAO,CAAA,GAAA,kQAAA,CAAA,gCAA6B,AAAD,EAAE,OAAO;AAC9C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7344, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/association.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references donâ€™t work in this\n * matching: `&copy;` does not match `Â©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how weâ€™re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAED;;AAsBO,SAAS,YAAY,IAAI;IAC9B,IAAI,KAAK,KAAK,IAAI,CAAC,KAAK,UAAU,EAAE;QAClC,OAAO,KAAK,KAAK,IAAI;IACvB;IAEA,OAAO,CAAA,GAAA,0PAAA,CAAA,eAAY,AAAD,EAAE,KAAK,UAAU;AACrC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7361, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/container-flow.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAED;;;;;;;;;CASC;;;AACM,SAAS,cAAc,MAAM,EAAE,KAAK,EAAE,IAAI;IAC/C,MAAM,aAAa,MAAM,UAAU;IACnC,MAAM,WAAW,OAAO,QAAQ,IAAI,EAAE;IACtC,MAAM,UAAU,MAAM,aAAa,CAAC;IACpC,0BAA0B,GAC1B,MAAM,UAAU,EAAE;IAClB,IAAI,QAAQ,CAAC;IAEb,WAAW,IAAI,CAAC,CAAC;IAEjB,MAAO,EAAE,QAAQ,SAAS,MAAM,CAAE;QAChC,MAAM,QAAQ,QAAQ,CAAC,MAAM;QAE7B,UAAU,CAAC,WAAW,MAAM,GAAG,EAAE,GAAG;QAEpC,QAAQ,IAAI,CACV,QAAQ,IAAI,CACV,MAAM,MAAM,CAAC,OAAO,QAAQ,OAAO;YACjC,QAAQ;YACR,OAAO;YACP,GAAG,QAAQ,OAAO,EAAE;QACtB;QAIJ,IAAI,MAAM,IAAI,KAAK,QAAQ;YACzB,MAAM,cAAc,GAAG;QACzB;QAEA,IAAI,QAAQ,SAAS,MAAM,GAAG,GAAG;YAC/B,QAAQ,IAAI,CACV,QAAQ,IAAI,CAAC,QAAQ,OAAO,QAAQ,CAAC,QAAQ,EAAE,EAAE,QAAQ;QAE7D;IACF;IAEA,WAAW,GAAG;IAEd,OAAO,QAAQ,IAAI,CAAC;AACtB;AAEA;;;;;;CAMC,GACD,SAAS,QAAQ,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK;IACzC,IAAI,QAAQ,MAAM,IAAI,CAAC,MAAM;IAE7B,MAAO,QAAS;QACd,MAAM,SAAS,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,OAAO,QAAQ;QAEtD,IAAI,WAAW,QAAQ,WAAW,GAAG;YACnC;QACF;QAEA,IAAI,OAAO,WAAW,UAAU;YAC9B,OAAO,KAAK,MAAM,CAAC,IAAI;QACzB;QAEA,IAAI,WAAW,OAAO;YACpB,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7430, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;AAED,MAAM,MAAM;AAKL,SAAS,YAAY,KAAK,EAAE,GAAG;IACpC,0BAA0B,GAC1B,MAAM,SAAS,EAAE;IACjB,IAAI,QAAQ;IACZ,IAAI,OAAO;IACX,mCAAmC,GACnC,IAAI;IAEJ,MAAQ,QAAQ,IAAI,IAAI,CAAC,OAAS;QAChC,IAAI,MAAM,KAAK,CAAC,OAAO,MAAM,KAAK;QAClC,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;QACpB,QAAQ,MAAM,KAAK,GAAG,KAAK,CAAC,EAAE,CAAC,MAAM;QACrC;IACF;IAEA,IAAI,MAAM,KAAK,CAAC;IAEhB,OAAO,OAAO,IAAI,CAAC;;;IAEnB;;GAEC,GACD,SAAS,IAAI,KAAK;QAChB,OAAO,IAAI,CAAC,IAAI,OAAO,MAAM,CAAC;IAChC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7461, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;CAGC;;;AACM,SAAS,eAAe,OAAO;IACpC,IAAI,CAAC,QAAQ,SAAS,EAAE;QACtB,MAAM,SACJ,CAAC,QAAQ,OAAO,GAAG,oBAAoB,EAAE,IACzC,CAAC,QAAQ,MAAM,GAAG,QAAQ,QAAQ,MAAM,GAAG,MAAM,EAAE;QAErD,QAAQ,SAAS,GAAG,IAAI,OACtB,CAAC,SAAS,MAAM,SAAS,MAAM,EAAE,IAC/B,CAAC,sBAAsB,IAAI,CAAC,QAAQ,SAAS,IAAI,OAAO,EAAE,IAC1D,QAAQ,SAAS,GACjB,CAAC,QAAQ,KAAK,GAAG,QAAQ,QAAQ,KAAK,GAAG,MAAM,EAAE,GACnD;IAEJ;IAEA,OAAO,QAAQ,SAAS;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7480, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;;CAIC;;;AACM,SAAS,eAAe,KAAK,EAAE,OAAO;IAC3C,OACE,YAAY,OAAO,QAAQ,WAAW,EAAE,SACxC,CAAC,YAAY,OAAO,QAAQ,cAAc,EAAE;AAEhD;AAEA;;;;;CAKC,GACD,SAAS,YAAY,KAAK,EAAE,IAAI,EAAE,IAAI;IACpC,IAAI,OAAO,SAAS,UAAU;QAC5B,OAAO;YAAC;SAAK;IACf;IAEA,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;QAC9B,OAAO;IACT;IAEA,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,KAAK,MAAM,CAAE;QAC5B,IAAI,MAAM,QAAQ,CAAC,IAAI,CAAC,MAAM,GAAG;YAC/B,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7519, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/safe.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What â€œconstructsâ€ we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7633, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/track.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED;;;;CAIC;;;AACM,SAAS,MAAM,MAAM;IAC1B,6EAA6E;IAC7E,aAAa;IACb,oBAAoB,GACpB,MAAM,UAAU,UAAU,CAAC;IAC3B,MAAM,MAAM,QAAQ,GAAG,IAAI,CAAC;IAC5B,IAAI,YAAY,QAAQ,SAAS,IAAI;IACrC,IAAI,OAAO,IAAI,IAAI,IAAI;IACvB,IAAI,SAAS,IAAI,MAAM,IAAI;IAE3B,OAAO;QAAC;QAAM;QAAS;IAAK;;;IAE5B;;;;GAIC,GACD,SAAS;QACP,OAAO;YAAC,KAAK;gBAAC;gBAAM;YAAM;YAAG;QAAS;IACxC;IAEA;;;;GAIC,GACD,SAAS,MAAM,KAAK;QAClB,aAAa;IACf;IAEA;;;;GAIC,GACD,SAAS,KAAK,KAAK;QACjB,6DAA6D;QAC7D,MAAM,QAAQ,SAAS;QACvB,MAAM,SAAS,MAAM,KAAK,CAAC;QAC3B,MAAM,OAAO,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE;QACtC,QAAQ,OAAO,MAAM,GAAG;QACxB,SACE,OAAO,MAAM,KAAK,IAAI,SAAS,KAAK,MAAM,GAAG,IAAI,KAAK,MAAM,GAAG;QACjE,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7698, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-gfm-footnote%401.0.2/node_modules/mdast-util-gfm-footnote/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n// To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use\n// utilities on `state`.\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown() {\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteReference')\n  const subexit = context.enter('reference')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteDefinition} node\n */\nfunction footnoteDefinition(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteDefinition')\n  const subexit = context.enter('label')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  value += tracker.move(\n    ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n  )\n  tracker.shift(4)\n  value += tracker.move(\n    indentLines(containerFlow(node, context, tracker.current()), map)\n  )\n  exit()\n\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, index, blank) {\n  if (index === 0) {\n    return line\n  }\n\n  return (blank ? '' : '    ') + line\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7873, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, itâ€™s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, itâ€™s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When weâ€™d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we canâ€™t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAED;;;;;;;;;;;;;CAaC;;;AACM,SAAS,kBAAkB,MAAM,EAAE,KAAK,EAAE,IAAI;IACnD,MAAM,aAAa,MAAM,UAAU;IACnC,MAAM,WAAW,OAAO,QAAQ,IAAI,EAAE;IACtC,0BAA0B,GAC1B,MAAM,UAAU,EAAE;IAClB,IAAI,QAAQ,CAAC;IACb,IAAI,SAAS,KAAK,MAAM;IAExB,WAAW,IAAI,CAAC,CAAC;IACjB,IAAI,UAAU,MAAM,aAAa,CAAC;IAElC,MAAO,EAAE,QAAQ,SAAS,MAAM,CAAE;QAChC,MAAM,QAAQ,QAAQ,CAAC,MAAM;QAC7B,mBAAmB,GACnB,IAAI;QAEJ,UAAU,CAAC,WAAW,MAAM,GAAG,EAAE,GAAG;QAEpC,IAAI,QAAQ,IAAI,SAAS,MAAM,EAAE;YAC/B,mBAAmB,GACnB,oDAAoD;YACpD,IAAI,SAAS,MAAM,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC;YAC5D,mBAAmB,GACnB,oDAAoD;YACpD,IAAI,UAAU,OAAO,IAAI,EAAE,SAAS,OAAO,IAAI;YAC/C,QAAQ,SACJ,OAAO,QAAQ,CAAC,QAAQ,EAAE,EAAE,QAAQ,OAAO;gBACzC,QAAQ;gBACR,OAAO;gBACP,GAAG,QAAQ,OAAO,EAAE;YACtB,GAAG,MAAM,CAAC,KACV;QACN,OAAO;YACL,QAAQ,KAAK,KAAK;QACpB;QAEA,0EAA0E;QAC1E,qEAAqE;QACrE,UAAU;QACV,4EAA4E;QAC5E,sDAAsD;QACtD,yEAAyE;QACzE,IACE,QAAQ,MAAM,GAAG,KACjB,CAAC,WAAW,QAAQ,WAAW,IAAI,KACnC,MAAM,IAAI,KAAK,QACf;YACA,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,GAAG,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,CAAC,OAAO,CAC/D,eACA;YAEF,SAAS;YAET,0CAA0C;YAC1C,UAAU,MAAM,aAAa,CAAC;YAC9B,QAAQ,IAAI,CAAC,QAAQ,IAAI,CAAC;QAC5B;QAEA,QAAQ,IAAI,CACV,QAAQ,IAAI,CACV,MAAM,MAAM,CAAC,OAAO,QAAQ,OAAO;YACjC,GAAG,QAAQ,OAAO,EAAE;YACpB;YACA;QACF;QAIJ,SAAS,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;IAC9C;IAEA,WAAW,GAAG;IAEd,OAAO,QAAQ,IAAI,CAAC;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7947, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-gfm-strikethrough%401.0.3/node_modules/mdast-util-gfm-strikethrough/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: expose functions.\n// To do: next major: use `state`, state utilities.\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [\n    {\n      character: '~',\n      inConstruct: 'phrasing',\n      notInConstruct: constructsWithoutStrikethrough\n    }\n  ],\n  handlers: {delete: handleDelete}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;CAUC;;;;AAED;AACA;;;AAEA,uCAAuC;AACvC,mDAAmD;AAEnD;;;;;;;;;CASC,GACD,MAAM,iCAAiC;IACrC;IACA;IACA;IACA;IACA;IACA;CACD;AAED,aAAa,IAAI,GAAG;AAOb,MAAM,+BAA+B;IAC1C,gBAAgB;QAAC;KAAS;IAC1B,OAAO;QAAC,eAAe;IAAkB;IACzC,MAAM;QAAC,eAAe;IAAiB;AACzC;AAOO,MAAM,6BAA6B;IACxC,QAAQ;QACN;YACE,WAAW;YACX,aAAa;YACb,gBAAgB;QAClB;KACD;IACD,UAAU;QAAC,QAAQ;IAAY;AACjC;AAEA;;;CAGC,GACD,SAAS,mBAAmB,KAAK;IAC/B,IAAI,CAAC,KAAK,CAAC;QAAC,MAAM;QAAU,UAAU,EAAE;IAAA,GAAG;AAC7C;AAEA;;;CAGC,GACD,SAAS,kBAAkB,KAAK;IAC9B,IAAI,CAAC,IAAI,CAAC;AACZ;AAEA;;;CAGC,GACD,SAAS,aAAa,IAAI,EAAE,CAAC,EAAE,OAAO,EAAE,WAAW;IACjD,MAAM,UAAU,CAAA,GAAA,sPAAA,CAAA,QAAK,AAAD,EAAE;IACtB,MAAM,OAAO,QAAQ,KAAK,CAAC;IAC3B,IAAI,QAAQ,QAAQ,IAAI,CAAC;IACzB,SAAS,CAAA,GAAA,sQAAA,CAAA,oBAAiB,AAAD,EAAE,MAAM,SAAS;QACxC,GAAG,QAAQ,OAAO,EAAE;QACpB,QAAQ;QACR,OAAO;IACT;IACA,SAAS,QAAQ,IAAI,CAAC;IACtB;IACA,OAAO;AACT;AAEA,6BAA6B,GAC7B,SAAS;IACP,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8046, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"],"sourcesContent":["/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs donâ€™t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We canâ€™t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;AAED;;AAEA,WAAW,IAAI,GAAG;AAQX,SAAS,WAAW,IAAI,EAAE,CAAC,EAAE,KAAK;IACvC,IAAI,QAAQ,KAAK,KAAK,IAAI;IAC1B,IAAI,WAAW;IACf,IAAI,QAAQ,CAAC;IAEb,2EAA2E;IAC3E,OAAO;IACP,sCAAsC;IACtC,MAAO,IAAI,OAAO,aAAa,WAAW,YAAY,IAAI,CAAC,OAAQ;QACjE,YAAY;IACd;IAEA,wEAAwE;IACxE,2EAA2E;IAC3E,IACE,WAAW,IAAI,CAAC,UAChB,CAAC,AAAC,WAAW,IAAI,CAAC,UAAU,WAAW,IAAI,CAAC,UAAW,QAAQ,IAAI,CAAC,MAAM,GAC1E;QACA,QAAQ,MAAM,QAAQ;IACxB;IAEA,6EAA6E;IAC7E,qBAAqB;IACrB,yEAAyE;IACzE,4BAA4B;IAC5B,mEAAmE;IACnE,6EAA6E;IAC7E,YAAY;IACZ,MAAO,EAAE,QAAQ,MAAM,MAAM,CAAC,MAAM,CAAE;QACpC,MAAM,UAAU,MAAM,MAAM,CAAC,MAAM;QACnC,MAAM,aAAa,CAAA,GAAA,mQAAA,CAAA,iBAAc,AAAD,EAAE;QAClC,mCAAmC,GACnC,IAAI;QAEJ,4BAA4B;QAC5B,yEAAyE;QACzE,MAAM;QACN,IAAI,CAAC,QAAQ,OAAO,EAAE;QAEtB,MAAQ,QAAQ,WAAW,IAAI,CAAC,OAAS;YACvC,IAAI,WAAW,MAAM,KAAK;YAE1B,+DAA+D;YAC/D,IACE,MAAM,UAAU,CAAC,cAAc,GAAG,QAAQ,OAC1C,MAAM,UAAU,CAAC,WAAW,OAAO,GAAG,QAAQ,KAC9C;gBACA;YACF;YAEA,QAAQ,MAAM,KAAK,CAAC,GAAG,YAAY,MAAM,MAAM,KAAK,CAAC,MAAM,KAAK,GAAG;QACrE;IACF;IAEA,OAAO,WAAW,QAAQ;AAC5B;AAEA;;CAEC,GACD,SAAS;IACP,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/markdown-table%403.0.4/node_modules/markdown-table/index.js"],"sourcesContent":["// To do: next major: remove.\n/**\n * @typedef {Options} MarkdownTableOptions\n *   Configuration.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [alignDelimiters=true]\n *   Whether to align the delimiters (default: `true`);\n *   they are aligned by default:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {ReadonlyArray<string | null | undefined> | string | null | undefined} [align]\n *   How to align columns (default: `''`);\n *   one style for all columns or styles for their respective columns;\n *   each style is either `'l'` (left), `'r'` (right), or `'c'` (center);\n *   other values are treated as `''`, which doesnâ€™t place the colon in the\n *   alignment row but does align left;\n *   *only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean | null | undefined} [delimiterEnd=true]\n *   Whether to end each row with the delimiter (default: `true`).\n *\n *   > ðŸ‘‰ **Note**: please donâ€™t use this: it could create fragile structures\n *   > that arenâ€™t understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean | null | undefined} [delimiterStart=true]\n *   Whether to begin each row with the delimiter (default: `true`).\n *\n *   > ðŸ‘‰ **Note**: please donâ€™t use this: it could create fragile structures\n *   > that arenâ€™t understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean | null | undefined} [padding=true]\n *   Whether to add a space of padding between delimiters and cells\n *   (default: `true`).\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {((value: string) => number) | null | undefined} [stringLength]\n *   Function to detect the length of table cell content (optional);\n *   this is used when aligning the delimiters (`|`) between table cells;\n *   full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source;\n *   to fix this, you can pass this function,\n *   which receives the cell content and returns its â€œvisibleâ€ size;\n *   note that what is and isnâ€™t visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['ä¸­æ–‡', 'Charlie'],\n *     ['ðŸ‘©â€â¤ï¸â€ðŸ‘©', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   | ä¸­æ–‡ | Charlie |\n *   | ðŸ‘©â€â¤ï¸â€ðŸ‘© | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['ä¸­æ–‡', 'Charlie'],\n *       ['ðŸ‘©â€â¤ï¸â€ðŸ‘©', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   | ä¸­æ–‡  | Charlie |\n *   | ðŸ‘©â€â¤ï¸â€ðŸ‘©    | Delta   |\n *   ```\n */\n\n/**\n * @param {string} value\n *   Cell value.\n * @returns {number}\n *   Cell size.\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * Generate a markdown\n * ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables))\n * table.\n *\n * @param {ReadonlyArray<ReadonlyArray<string | null | undefined>>} table\n *   Table data (matrix of strings).\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Result.\n */\nexport function markdownTable(table, options) {\n  const settings = options || {}\n  // To do: next major: change to spread.\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we donâ€™t align delimiters, but otherwise weâ€™d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (settings.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Donâ€™t add the opening space if weâ€™re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string | null | undefined} [value]\n *   Value to serialize.\n * @returns {string}\n *   Result.\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string | null | undefined} value\n *   Value.\n * @returns {number}\n *   Alignment.\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n      ? 108 /* `l` */\n      : code === 82 /* `R` */ || code === 114 /* `r` */\n        ? 114 /* `r` */\n        : 0\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8412, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-gfm-table%401.0.7/node_modules/mdast-util-gfm-table/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n *\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells.\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters.\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\n// To do: next major: use `defaultHandlers.inlineCode`.\n// To do: next major: expose functions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes donâ€™t (but canâ€™t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      node.align\n    )\n  }\n\n  /**\n   * This function isnâ€™t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8682, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;CAGC;;;AACM,SAAS,YAAY,KAAK;IAC/B,MAAM,SAAS,MAAM,OAAO,CAAC,MAAM,IAAI;IAEvC,IAAI,WAAW,OAAO,WAAW,OAAO,WAAW,KAAK;QACtD,MAAM,IAAI,MACR,kCACE,SACA;IAEN;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8702, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;CAGC;;;AACM,SAAS,oBAAoB,KAAK;IACvC,MAAM,QAAQ,MAAM,OAAO,CAAC,cAAc,IAAI;IAE9C,4BAA4B;IAC5B,gCAAgC;IAChC,IAAI,UAAU,KAAK,UAAU,KAAK;QAChC,OAAO;IACT;IAEA,IAAI,UAAU,SAAS,UAAU,SAAS,UAAU,SAAS;QAC3D,MAAM,IAAI,MACR,kCACE,QACA;IAEN;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8727, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-to-markdown%401.5.0/node_modules/mdast-util-to-markdown/lib/handle/list-item.js"],"sourcesContent":["/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAED;AACA;;;AASO,SAAS,SAAS,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI;IAChD,MAAM,iBAAiB,CAAA,GAAA,gRAAA,CAAA,sBAAmB,AAAD,EAAE;IAC3C,IAAI,SAAS,MAAM,aAAa,IAAI,CAAA,GAAA,gQAAA,CAAA,cAAW,AAAD,EAAE;IAEhD,0CAA0C;IAC1C,IAAI,UAAU,OAAO,IAAI,KAAK,UAAU,OAAO,OAAO,EAAE;QACtD,SACE,CAAC,OAAO,OAAO,KAAK,KAAK,YAAY,OAAO,KAAK,GAAG,CAAC,IACjD,OAAO,KAAK,GACZ,CAAC,IACL,CAAC,MAAM,OAAO,CAAC,mBAAmB,KAAK,QACnC,IACA,OAAO,QAAQ,CAAC,OAAO,CAAC,KAAK,IACjC;IACJ;IAEA,IAAI,OAAO,OAAO,MAAM,GAAG;IAE3B,IACE,mBAAmB,SAClB,mBAAmB,WAClB,CAAC,AAAC,UAAU,OAAO,IAAI,KAAK,UAAU,OAAO,MAAM,IAAK,KAAK,MAAM,GACrE;QACA,OAAO,KAAK,IAAI,CAAC,OAAO,KAAK;IAC/B;IAEA,MAAM,UAAU,MAAM,aAAa,CAAC;IACpC,QAAQ,IAAI,CAAC,SAAS,IAAI,MAAM,CAAC,OAAO,OAAO,MAAM;IACrD,QAAQ,KAAK,CAAC;IACd,MAAM,OAAO,MAAM,KAAK,CAAC;IACzB,MAAM,QAAQ,MAAM,WAAW,CAC7B,MAAM,aAAa,CAAC,MAAM,QAAQ,OAAO,KACzC;IAEF;IAEA,OAAO;;;IAEP,gBAAgB,GAChB,SAAS,IAAI,IAAI,EAAE,KAAK,EAAE,KAAK;QAC7B,IAAI,OAAO;YACT,OAAO,CAAC,QAAQ,KAAK,IAAI,MAAM,CAAC,KAAK,IAAI;QAC3C;QAEA,OAAO,CAAC,QAAQ,SAAS,SAAS,IAAI,MAAM,CAAC,OAAO,OAAO,MAAM,CAAC,IAAI;IACxE;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8771, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-gfm-task-list-item%401.0.2/node_modules/mdast-util-gfm-task-list-item/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // Weâ€™re always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;CAWC,GAED;;CAEC;;;;AAED;AACA;;;AAYO,MAAM,8BAA8B;IACzC,MAAM;QACJ,2BAA2B;QAC3B,6BAA6B;QAC7B,WAAW;IACb;AACF;AAOO,MAAM,4BAA4B;IACvC,QAAQ;QAAC;YAAC,SAAS;YAAM,WAAW;YAAK,OAAO;QAAO;KAAE;IACzD,UAAU;QAAC,UAAU;IAAwB;AAC/C;AAEA;;;CAGC,GACD,SAAS,UAAU,KAAK;IACtB,MAAM,OAAgC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,EAAE;IACvE,+CAA+C;IAC/C,KAAK,OAAO,GAAG,MAAM,IAAI,KAAK;AAChC;AAEA;;;CAGC,GACD,SAAS,8BAA8B,KAAK;IAC1C,MAAM,SAAiC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,EAAE;IAExE,IACE,UACA,OAAO,IAAI,KAAK,cAChB,OAAO,OAAO,OAAO,KAAK,WAC1B;QACA,MAAM,OAAiC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,EAAE;QACxE,MAAM,OAAO,KAAK,QAAQ,CAAC,EAAE;QAE7B,IAAI,QAAQ,KAAK,IAAI,KAAK,QAAQ;YAChC,MAAM,WAAW,OAAO,QAAQ;YAChC,IAAI,QAAQ,CAAC;YACb,kCAAkC,GAClC,IAAI;YAEJ,MAAO,EAAE,QAAQ,SAAS,MAAM,CAAE;gBAChC,MAAM,UAAU,QAAQ,CAAC,MAAM;gBAC/B,IAAI,QAAQ,IAAI,KAAK,aAAa;oBAChC,kBAAkB;oBAClB;gBACF;YACF;YAEA,IAAI,oBAAoB,MAAM;gBAC5B,oCAAoC;gBACpC,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC,KAAK,CAAC;gBAE9B,IAAI,KAAK,KAAK,CAAC,MAAM,KAAK,GAAG;oBAC3B,KAAK,QAAQ,CAAC,KAAK;gBACrB,OAAO,IACL,KAAK,QAAQ,IACb,KAAK,QAAQ,IACb,OAAO,KAAK,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,UACtC;oBACA,KAAK,QAAQ,CAAC,KAAK,CAAC,MAAM;oBAC1B,KAAK,QAAQ,CAAC,KAAK,CAAC,MAAM;oBAC1B,KAAK,QAAQ,CAAC,KAAK,GAAG,OAAO,MAAM,CAAC,CAAC,GAAG,KAAK,QAAQ,CAAC,KAAK;gBAC7D;YACF;QACF;IACF;IAEA,IAAI,CAAC,IAAI,CAAC;AACZ;AAEA;;;CAGC,GACD,SAAS,yBAAyB,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,WAAW;IAClE,MAAM,OAAO,KAAK,QAAQ,CAAC,EAAE;IAC7B,MAAM,YACJ,OAAO,KAAK,OAAO,KAAK,aAAa,QAAQ,KAAK,IAAI,KAAK;IAC7D,MAAM,WAAW,MAAM,CAAC,KAAK,OAAO,GAAG,MAAM,GAAG,IAAI;IACpD,MAAM,UAAU,CAAA,GAAA,sPAAA,CAAA,QAAK,AAAD,EAAE;IAEtB,IAAI,WAAW;QACb,QAAQ,IAAI,CAAC;IACf;IAEA,IAAI,QAAQ,CAAA,GAAA,+PAAA,CAAA,WAAQ,AAAD,EAAE,MAAM,QAAQ,SAAS;QAC1C,GAAG,WAAW;QACd,GAAG,QAAQ,OAAO,EAAE;IACtB;IAEA,IAAI,WAAW;QACb,QAAQ,MAAM,OAAO,CAAC,mCAAmC;IAC3D;IAEA,OAAO;;;IAEP;;;GAGC,GACD,SAAS,MAAM,EAAE;QACf,OAAO,KAAK;IACd;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8885, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/mdast-util-gfm%402.0.2/node_modules/mdast-util-gfm/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * @typedef {import('mdast-util-gfm-table').Options} Options\n *   Configuration.\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;CAGC;;;;AAED;AAIA;AAIA;AAIA;AACA;;;;;;AAaO,SAAS;IACd,OAAO;QACL,sQAAA,CAAA,iCAA8B;QAC9B,CAAA,GAAA,gPAAA,CAAA,0BAAuB,AAAD;QACtB,0PAAA,CAAA,+BAA4B;QAC5B,0OAAA,CAAA,uBAAoB;QACpB,wQAAA,CAAA,8BAA2B;KAC5B;AACH;AAYO,SAAS,cAAc,OAAO;IACnC,OAAO;QACL,YAAY;YACV,sQAAA,CAAA,+BAA4B;YAC5B,CAAA,GAAA,gPAAA,CAAA,wBAAqB,AAAD;YACpB,0PAAA,CAAA,6BAA0B;YAC1B,CAAA,GAAA,0OAAA,CAAA,qBAAkB,AAAD,EAAE;YACnB,wQAAA,CAAA,4BAAyB;SAC1B;IACH;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8929, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/remark-gfm%403.0.1/node_modules/remark-gfm/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options\n */\n\nimport {gfm} from 'micromark-extension-gfm'\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\n\n/**\n * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\nexport default function remarkGfm(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', gfm(options))\n  add('fromMarkdownExtensions', gfmFromMarkdown())\n  add('toMarkdownExtensions', gfmToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;AAED;AACA;;;AAOe,SAAS;QAAU,UAAA,iEAAU,CAAC;IAC3C,MAAM,OAAO,IAAI,CAAC,IAAI;IAEtB,IAAI,uBAAuB,CAAA,GAAA,mOAAA,CAAA,MAAG,AAAD,EAAE;IAC/B,IAAI,0BAA0B,CAAA,GAAA,wNAAA,CAAA,kBAAe,AAAD;IAC5C,IAAI,wBAAwB,CAAA,GAAA,wNAAA,CAAA,gBAAa,AAAD,EAAE;IAE1C;;;GAGC,GACD,SAAS,IAAI,KAAK,EAAE,KAAK;QACvB,MAAM,OACJ,mBAAmB;QACnB,oBAAoB,GACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,GAAI,IAAI,CAAC,MAAM,GAAG,EAAE;QAG/C,KAAK,IAAI,CAAC;IACZ;AACF","ignoreList":[0],"debugId":null}}]
}