(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * This module is compiled away!
 *
 * Parsing markdown comes with a couple of constants, such as minimum or maximum
 * sizes of certain sequences.
 * Additionally, there are a couple symbols used inside micromark.
 * These are all defined here, but compiled away by scripts.
 */ __turbopack_context__.s({
    "constants": ()=>constants
});
const constants = {
    attentionSideBefore: 1,
    attentionSideAfter: 2,
    atxHeadingOpeningFenceSizeMax: 6,
    autolinkDomainSizeMax: 63,
    autolinkSchemeSizeMax: 32,
    cdataOpeningString: 'CDATA[',
    characterGroupWhitespace: 1,
    characterGroupPunctuation: 2,
    characterReferenceDecimalSizeMax: 7,
    characterReferenceHexadecimalSizeMax: 6,
    characterReferenceNamedSizeMax: 31,
    codeFencedSequenceSizeMin: 3,
    contentTypeDocument: 'document',
    contentTypeFlow: 'flow',
    contentTypeContent: 'content',
    contentTypeString: 'string',
    contentTypeText: 'text',
    hardBreakPrefixSizeMin: 2,
    htmlRaw: 1,
    htmlComment: 2,
    htmlInstruction: 3,
    htmlDeclaration: 4,
    htmlCdata: 5,
    htmlBasic: 6,
    htmlComplete: 7,
    htmlRawSizeMax: 8,
    linkResourceDestinationBalanceMax: 32,
    linkReferenceSizeMax: 999,
    listItemValueSizeMax: 10,
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 0x10,
    tabSize: 4,
    thematicBreakMarkerCountMin: 3,
    v8MaxSafeChunkSize: 10000 // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
};
}),
"[project]/node_modules/.pnpm/micromark-util-chunked@1.1.0/node_modules/micromark-util-chunked/dev/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "push": ()=>push,
    "splice": ()=>splice
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/constants.js [app-client] (ecmascript)");
;
function splice(list, start, remove, items) {
    const end = list.length;
    let chunkStart = 0;
    /** @type {Array<unknown>} */ let parameters;
    // Make start between zero and `end` (included).
    if (start < 0) {
        start = -start > end ? 0 : end + start;
    } else {
        start = start > end ? end : start;
    }
    remove = remove > 0 ? remove : 0;
    // No need to chunk the items if there’s only a couple (10k) items.
    if (items.length < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].v8MaxSafeChunkSize) {
        parameters = Array.from(items);
        parameters.unshift(start, remove);
        // @ts-expect-error Hush, it’s fine.
        list.splice(...parameters);
    } else {
        // Delete `remove` items starting from `start`
        if (remove) list.splice(start, remove);
        // Insert the items in chunks to not cause stack overflows.
        while(chunkStart < items.length){
            parameters = items.slice(chunkStart, chunkStart + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].v8MaxSafeChunkSize);
            parameters.unshift(start, 0);
            // @ts-expect-error Hush, it’s fine.
            list.splice(...parameters);
            chunkStart += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].v8MaxSafeChunkSize;
            start += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].v8MaxSafeChunkSize;
        }
    }
}
function push(list, items) {
    if (list.length > 0) {
        splice(list, list.length, 0, items);
        return list;
    }
    return items;
}
}),
"[project]/node_modules/.pnpm/micromark-util-combine-extensions@1.1.0/node_modules/micromark-util-combine-extensions/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Handles} Handles
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension
 */ __turbopack_context__.s({
    "combineExtensions": ()=>combineExtensions,
    "combineHtmlExtensions": ()=>combineHtmlExtensions
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$chunked$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$chunked$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-chunked@1.1.0/node_modules/micromark-util-chunked/dev/index.js [app-client] (ecmascript)");
;
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
    /** @type {NormalizedExtension} */ const all = {};
    let index = -1;
    while(++index < extensions.length){
        syntaxExtension(all, extensions[index]);
    }
    return all;
}
/**
 * Merge `extension` into `all`.
 *
 * @param {NormalizedExtension} all
 *   Extension to merge into.
 * @param {Extension} extension
 *   Extension to merge.
 * @returns {void}
 */ function syntaxExtension(all, extension) {
    /** @type {keyof Extension} */ let hook;
    for(hook in extension){
        const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;
        /** @type {Record<string, unknown>} */ const left = maybe || (all[hook] = {});
        /** @type {Record<string, unknown> | undefined} */ const right = extension[hook];
        /** @type {string} */ let code;
        if (right) {
            for(code in right){
                if (!hasOwnProperty.call(left, code)) left[code] = [];
                const value = right[code];
                constructs(// @ts-expect-error Looks like a list.
                left[code], Array.isArray(value) ? value : value ? [
                    value
                ] : []);
            }
        }
    }
}
/**
 * Merge `list` into `existing` (both lists of constructs).
 * Mutates `existing`.
 *
 * @param {Array<unknown>} existing
 * @param {Array<unknown>} list
 * @returns {void}
 */ function constructs(existing, list) {
    let index = -1;
    /** @type {Array<unknown>} */ const before = [];
    while(++index < list.length){
        // @ts-expect-error Looks like an object.
        ;
        (list[index].add === 'after' ? existing : before).push(list[index]);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$chunked$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$chunked$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splice"])(existing, 0, 0, before);
}
function combineHtmlExtensions(htmlExtensions) {
    /** @type {HtmlExtension} */ const handlers = {};
    let index = -1;
    while(++index < htmlExtensions.length){
        htmlExtension(handlers, htmlExtensions[index]);
    }
    return handlers;
}
/**
 * Merge `extension` into `all`.
 *
 * @param {HtmlExtension} all
 *   Extension to merge into.
 * @param {HtmlExtension} extension
 *   Extension to merge.
 * @returns {void}
 */ function htmlExtension(all, extension) {
    /** @type {keyof HtmlExtension} */ let hook;
    for(hook in extension){
        const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;
        const left = maybe || (all[hook] = {});
        const right = extension[hook];
        /** @type {keyof Handles} */ let type;
        if (right) {
            for(type in right){
                // @ts-expect-error assume document vs regular handler are managed correctly.
                left[type] = right[type];
            }
        }
    }
}
}),
"[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Character codes.
 *
 * This module is compiled away!
 *
 * micromark works based on character codes.
 * This module contains constants for the ASCII block and the replacement
 * character.
 * A couple of them are handled in a special way, such as the line endings
 * (CR, LF, and CR+LF, commonly known as end-of-line: EOLs), the tab (horizontal
 * tab) and its expansion based on what column it’s at (virtual space),
 * and the end-of-file (eof) character.
 * As values are preprocessed before handling them, the actual characters LF,
 * CR, HT, and NUL (which is present as the replacement character), are
 * guaranteed to not exist.
 *
 * Unicode basic latin block.
 */ __turbopack_context__.s({
    "codes": ()=>codes
});
const codes = {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    lf: 10,
    vt: 11,
    ff: 12,
    cr: 13,
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    quotationMark: 34,
    numberSign: 35,
    dollarSign: 36,
    percentSign: 37,
    ampersand: 38,
    apostrophe: 39,
    leftParenthesis: 40,
    rightParenthesis: 41,
    asterisk: 42,
    plusSign: 43,
    comma: 44,
    dash: 45,
    dot: 46,
    slash: 47,
    digit0: 48,
    digit1: 49,
    digit2: 50,
    digit3: 51,
    digit4: 52,
    digit5: 53,
    digit6: 54,
    digit7: 55,
    digit8: 56,
    digit9: 57,
    colon: 58,
    semicolon: 59,
    lessThan: 60,
    equalsTo: 61,
    greaterThan: 62,
    questionMark: 63,
    atSign: 64,
    uppercaseA: 65,
    uppercaseB: 66,
    uppercaseC: 67,
    uppercaseD: 68,
    uppercaseE: 69,
    uppercaseF: 70,
    uppercaseG: 71,
    uppercaseH: 72,
    uppercaseI: 73,
    uppercaseJ: 74,
    uppercaseK: 75,
    uppercaseL: 76,
    uppercaseM: 77,
    uppercaseN: 78,
    uppercaseO: 79,
    uppercaseP: 80,
    uppercaseQ: 81,
    uppercaseR: 82,
    uppercaseS: 83,
    uppercaseT: 84,
    uppercaseU: 85,
    uppercaseV: 86,
    uppercaseW: 87,
    uppercaseX: 88,
    uppercaseY: 89,
    uppercaseZ: 90,
    leftSquareBracket: 91,
    backslash: 92,
    rightSquareBracket: 93,
    caret: 94,
    underscore: 95,
    graveAccent: 96,
    lowercaseA: 97,
    lowercaseB: 98,
    lowercaseC: 99,
    lowercaseD: 100,
    lowercaseE: 101,
    lowercaseF: 102,
    lowercaseG: 103,
    lowercaseH: 104,
    lowercaseI: 105,
    lowercaseJ: 106,
    lowercaseK: 107,
    lowercaseL: 108,
    lowercaseM: 109,
    lowercaseN: 110,
    lowercaseO: 111,
    lowercaseP: 112,
    lowercaseQ: 113,
    lowercaseR: 114,
    lowercaseS: 115,
    lowercaseT: 116,
    lowercaseU: 117,
    lowercaseV: 118,
    lowercaseW: 119,
    lowercaseX: 120,
    lowercaseY: 121,
    lowercaseZ: 122,
    leftCurlyBrace: 123,
    verticalBar: 124,
    rightCurlyBrace: 125,
    tilde: 126,
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533 // `�`
};
}),
"[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// This module is generated by `script/`.
//
// CommonMark handles attention (emphasis, strong) markers based on what comes
// before or after them.
// One such difference is if those characters are Unicode punctuation.
// This script is generated from the Unicode data.
/**
 * Regular expression that matches a unicode punctuation character.
 */ __turbopack_context__.s({
    "unicodePunctuationRegex": ()=>unicodePunctuationRegex
});
const unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
}),
"[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Code} Code
 */ __turbopack_context__.s({
    "asciiAlpha": ()=>asciiAlpha,
    "asciiAlphanumeric": ()=>asciiAlphanumeric,
    "asciiAtext": ()=>asciiAtext,
    "asciiControl": ()=>asciiControl,
    "asciiDigit": ()=>asciiDigit,
    "asciiHexDigit": ()=>asciiHexDigit,
    "asciiPunctuation": ()=>asciiPunctuation,
    "markdownLineEnding": ()=>markdownLineEnding,
    "markdownLineEndingOrSpace": ()=>markdownLineEndingOrSpace,
    "markdownSpace": ()=>markdownSpace,
    "unicodePunctuation": ()=>unicodePunctuation,
    "unicodeWhitespace": ()=>unicodeWhitespace
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$lib$2f$unicode$2d$punctuation$2d$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js [app-client] (ecmascript)");
;
;
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code) {
    return(// Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code !== null && (code < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].space || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].del));
}
const asciiDigit = regexCheck(/\d/);
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code) {
    return code !== null && code < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].horizontalTab;
}
function markdownLineEndingOrSpace(code) {
    return code !== null && (code < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].nul || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].space);
}
function markdownSpace(code) {
    return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].horizontalTab || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].virtualSpace || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].space;
}
const unicodePunctuation = regexCheck(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$lib$2f$unicode$2d$punctuation$2d$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodePunctuationRegex"]);
const unicodeWhitespace = regexCheck(/\s/);
/**
 * Create a code check from a regex.
 *
 * @param {RegExp} regex
 * @returns {(code: Code) => boolean}
 */ function regexCheck(regex) {
    return check;
    //TURBOPACK unreachable
    ;
    /**
   * Check whether a code matches the bound regex.
   *
   * @param {Code} code
   *   Character code.
   * @returns {boolean}
   *   Whether the character code matches the bound regex.
   */ function check(code) {
        return code !== null && regex.test(String.fromCharCode(code));
    }
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Previous} Previous
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ __turbopack_context__.s({
    "gfmAutolinkLiteral": ()=>gfmAutolinkLiteral
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
;
;
const wwwPrefix = {
    tokenize: tokenizeWwwPrefix,
    partial: true
};
const domain = {
    tokenize: tokenizeDomain,
    partial: true
};
const path = {
    tokenize: tokenizePath,
    partial: true
};
const trail = {
    tokenize: tokenizeTrail,
    partial: true
};
const emailDomainDotTrail = {
    tokenize: tokenizeEmailDomainDotTrail,
    partial: true
};
const wwwAutolink = {
    tokenize: tokenizeWwwAutolink,
    previous: previousWww
};
const protocolAutolink = {
    tokenize: tokenizeProtocolAutolink,
    previous: previousProtocol
};
const emailAutolink = {
    tokenize: tokenizeEmailAutolink,
    previous: previousEmail
};
/** @type {ConstructRecord} */ const text = {};
const gfmAutolinkLiteral = {
    text
};
/** @type {Code} */ let code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].digit0;
// Add alphanumerics.
while(code < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftCurlyBrace){
    text[code] = emailAutolink;
    code++;
    if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].colon) code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].uppercaseA;
    else if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket) code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lowercaseA;
}
text[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].plusSign] = emailAutolink;
text[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dash] = emailAutolink;
text[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dot] = emailAutolink;
text[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].underscore] = emailAutolink;
text[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].uppercaseH] = [
    emailAutolink,
    protocolAutolink
];
text[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lowercaseH] = [
    emailAutolink,
    protocolAutolink
];
text[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].uppercaseW] = [
    emailAutolink,
    wwwAutolink
];
text[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lowercaseW] = [
    emailAutolink,
    wwwAutolink
];
// To do: perform email autolink literals on events, afterwards.
// That’s where `markdown-rs` and `cmark-gfm` perform it.
// It should look for `@`, then for atext backwards, and then for a label
// forwards.
// To do: `mailto:`, `xmpp:` protocol as prefix.
/**
 * Email autolink literal.
 *
 * ```markdown
 * > | a contact@example.org b
 *       ^^^^^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeEmailAutolink(effects, ok, nok) {
    const self = this;
    /** @type {boolean | undefined} */ let dot;
    /** @type {boolean} */ let data;
    return start;
    //TURBOPACK unreachable
    ;
    /**
   * Start of email autolink literal.
   *
   * ```markdown
   * > | a contact@example.org b
   *       ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {
            return nok(code);
        }
        effects.enter('literalAutolink');
        effects.enter('literalAutolinkEmail');
        return atext(code);
    }
    /**
   * In email atext.
   *
   * ```markdown
   * > | a contact@example.org b
   *       ^
   * ```
   *
   * @type {State}
   */ function atext(code) {
        if (gfmAtext(code)) {
            effects.consume(code);
            return atext;
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].atSign) {
            effects.consume(code);
            return emailDomain;
        }
        return nok(code);
    }
    /**
   * In email domain.
   *
   * The reference code is a bit overly complex as it handles the `@`, of which
   * there may be just one.
   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>
   *
   * ```markdown
   * > | a contact@example.org b
   *               ^
   * ```
   *
   * @type {State}
   */ function emailDomain(code) {
        // Dot followed by alphanumerical (not `-` or `_`).
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dot) {
            return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);
        }
        // Alphanumerical, `-`, and `_`.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dash || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].underscore || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlphanumeric"])(code)) {
            data = true;
            effects.consume(code);
            return emailDomain;
        }
        // To do: `/` if xmpp.
        // Note: normally we’d truncate trailing punctuation from the link.
        // However, email autolink literals cannot contain any of those markers,
        // except for `.`, but that can only occur if it isn’t trailing.
        // So we can ignore truncating!
        return emailDomainAfter(code);
    }
    /**
   * In email domain, on dot that is not a trail.
   *
   * ```markdown
   * > | a contact@example.org b
   *                      ^
   * ```
   *
   * @type {State}
   */ function emailDomainDot(code) {
        effects.consume(code);
        dot = true;
        return emailDomain;
    }
    /**
   * After email domain.
   *
   * ```markdown
   * > | a contact@example.org b
   *                          ^
   * ```
   *
   * @type {State}
   */ function emailDomainAfter(code) {
        // Domain must not be empty, must include a dot, and must end in alphabetical.
        // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.
        if (data && dot && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlpha"])(self.previous)) {
            effects.exit('literalAutolinkEmail');
            effects.exit('literalAutolink');
            return ok(code);
        }
        return nok(code);
    }
}
/**
 * `www` autolink literal.
 *
 * ```markdown
 * > | a www.example.org b
 *       ^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeWwwAutolink(effects, ok, nok) {
    const self = this;
    return wwwStart;
    //TURBOPACK unreachable
    ;
    /**
   * Start of www autolink literal.
   *
   * ```markdown
   * > | www.example.com/a?b#c
   *     ^
   * ```
   *
   * @type {State}
   */ function wwwStart(code) {
        if (code !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].uppercaseW && code !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lowercaseW || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {
            return nok(code);
        }
        effects.enter('literalAutolink');
        effects.enter('literalAutolinkWww');
        // Note: we *check*, so we can discard the `www.` we parsed.
        // If it worked, we consider it as a part of the domain.
        return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);
    }
    /**
   * After a www autolink literal.
   *
   * ```markdown
   * > | www.example.com/a?b#c
   *                          ^
   * ```
   *
   * @type {State}
   */ function wwwAfter(code) {
        effects.exit('literalAutolinkWww');
        effects.exit('literalAutolink');
        return ok(code);
    }
}
/**
 * Protocol autolink literal.
 *
 * ```markdown
 * > | a https://example.org b
 *       ^^^^^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeProtocolAutolink(effects, ok, nok) {
    const self = this;
    let buffer = '';
    let seen = false;
    return protocolStart;
    //TURBOPACK unreachable
    ;
    /**
   * Start of protocol autolink literal.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *     ^
   * ```
   *
   * @type {State}
   */ function protocolStart(code) {
        if ((code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].uppercaseH || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lowercaseH) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {
            effects.enter('literalAutolink');
            effects.enter('literalAutolinkHttp');
            buffer += String.fromCodePoint(code);
            effects.consume(code);
            return protocolPrefixInside;
        }
        return nok(code);
    }
    /**
   * In protocol.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *     ^^^^^
   * ```
   *
   * @type {State}
   */ function protocolPrefixInside(code) {
        // `5` is size of `https`
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlpha"])(code) && buffer.length < 5) {
            // @ts-expect-error: definitely number.
            buffer += String.fromCodePoint(code);
            effects.consume(code);
            return protocolPrefixInside;
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].colon) {
            const protocol = buffer.toLowerCase();
            if (protocol === 'http' || protocol === 'https') {
                effects.consume(code);
                return protocolSlashesInside;
            }
        }
        return nok(code);
    }
    /**
   * In slashes.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *           ^^
   * ```
   *
   * @type {State}
   */ function protocolSlashesInside(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].slash) {
            effects.consume(code);
            if (seen) {
                return afterProtocol;
            }
            seen = true;
            return protocolSlashesInside;
        }
        return nok(code);
    }
    /**
   * After protocol, before domain.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *             ^
   * ```
   *
   * @type {State}
   */ function afterProtocol(code) {
        // To do: this is different from `markdown-rs`:
        // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182
        return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiControl"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodeWhitespace"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodePunctuation"])(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);
    }
    /**
   * After a protocol autolink literal.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *                              ^
   * ```
   *
   * @type {State}
   */ function protocolAfter(code) {
        effects.exit('literalAutolinkHttp');
        effects.exit('literalAutolink');
        return ok(code);
    }
}
/**
 * `www` prefix.
 *
 * ```markdown
 * > | a www.example.org b
 *       ^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeWwwPrefix(effects, ok, nok) {
    let size = 0;
    return wwwPrefixInside;
    //TURBOPACK unreachable
    ;
    /**
   * In www prefix.
   *
   * ```markdown
   * > | www.example.com
   *     ^^^^
   * ```
   *
   * @type {State}
   */ function wwwPrefixInside(code) {
        if ((code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].uppercaseW || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lowercaseW) && size < 3) {
            size++;
            effects.consume(code);
            return wwwPrefixInside;
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dot && size === 3) {
            effects.consume(code);
            return wwwPrefixAfter;
        }
        return nok(code);
    }
    /**
   * After www prefix.
   *
   * ```markdown
   * > | www.example.com
   *         ^
   * ```
   *
   * @type {State}
   */ function wwwPrefixAfter(code) {
        // If there is *anything*, we can link.
        return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof ? nok(code) : ok(code);
    }
}
/**
 * Domain.
 *
 * ```markdown
 * > | a https://example.org b
 *               ^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeDomain(effects, ok, nok) {
    /** @type {boolean | undefined} */ let underscoreInLastSegment;
    /** @type {boolean | undefined} */ let underscoreInLastLastSegment;
    /** @type {boolean | undefined} */ let seen;
    return domainInside;
    //TURBOPACK unreachable
    ;
    /**
   * In domain.
   *
   * ```markdown
   * > | https://example.com/a
   *             ^^^^^^^^^^^
   * ```
   *
   * @type {State}
   */ function domainInside(code) {
        // Check whether this marker, which is a trailing punctuation
        // marker, optionally followed by more trailing markers, and then
        // followed by an end.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dot || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].underscore) {
            return effects.check(trail, domainAfter, domainAtPunctuation)(code);
        }
        // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can
        // occur, which sounds like ASCII only, but they also support `www.點看.com`,
        // so that’s Unicode.
        // Instead of some new production for Unicode alphanumerics, markdown
        // already has that for Unicode punctuation and whitespace, so use those.
        // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodeWhitespace"])(code) || code !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dash && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodePunctuation"])(code)) {
            return domainAfter(code);
        }
        seen = true;
        effects.consume(code);
        return domainInside;
    }
    /**
   * In domain, at potential trailing punctuation, that was not trailing.
   *
   * ```markdown
   * > | https://example.com
   *                    ^
   * ```
   *
   * @type {State}
   */ function domainAtPunctuation(code) {
        // There is an underscore in the last segment of the domain
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].underscore) {
            underscoreInLastSegment = true;
        } else {
            underscoreInLastLastSegment = underscoreInLastSegment;
            underscoreInLastSegment = undefined;
        }
        effects.consume(code);
        return domainInside;
    }
    /**
   * After domain.
   *
   * ```markdown
   * > | https://example.com/a
   *                        ^
   * ```
   *
   * @type {State} */ function domainAfter(code) {
        // Note: that’s GH says a dot is needed, but it’s not true:
        // <https://github.com/github/cmark-gfm/issues/279>
        if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
            return nok(code);
        }
        return ok(code);
    }
}
/**
 * Path.
 *
 * ```markdown
 * > | a https://example.org/stuff b
 *                          ^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizePath(effects, ok) {
    let sizeOpen = 0;
    let sizeClose = 0;
    return pathInside;
    //TURBOPACK unreachable
    ;
    /**
   * In path.
   *
   * ```markdown
   * > | https://example.com/a
   *                        ^^
   * ```
   *
   * @type {State}
   */ function pathInside(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftParenthesis) {
            sizeOpen++;
            effects.consume(code);
            return pathInside;
        }
        // To do: `markdown-rs` also needs this.
        // If this is a paren, and there are less closings than openings,
        // we don’t check for a trail.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightParenthesis && sizeClose < sizeOpen) {
            return pathAtPunctuation(code);
        }
        // Check whether this trailing punctuation marker is optionally
        // followed by more trailing markers, and then followed
        // by an end.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].exclamationMark || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].quotationMark || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].ampersand || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].apostrophe || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightParenthesis || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].asterisk || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].comma || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dot || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].colon || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].semicolon || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lessThan || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].questionMark || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].underscore || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde) {
            return effects.check(trail, ok, pathAtPunctuation)(code);
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodeWhitespace"])(code)) {
            return ok(code);
        }
        effects.consume(code);
        return pathInside;
    }
    /**
   * In path, at potential trailing punctuation, that was not trailing.
   *
   * ```markdown
   * > | https://example.com/a"b
   *                          ^
   * ```
   *
   * @type {State}
   */ function pathAtPunctuation(code) {
        // Count closing parens.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightParenthesis) {
            sizeClose++;
        }
        effects.consume(code);
        return pathInside;
    }
}
/**
 * Trail.
 *
 * This calls `ok` if this *is* the trail, followed by an end, which means
 * the entire trail is not part of the link.
 * It calls `nok` if this *is* part of the link.
 *
 * ```markdown
 * > | https://example.com").
 *                        ^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeTrail(effects, ok, nok) {
    return trail;
    //TURBOPACK unreachable
    ;
    /**
   * In trail of domain or path.
   *
   * ```markdown
   * > | https://example.com").
   *                        ^
   * ```
   *
   * @type {State}
   */ function trail(code) {
        // Regular trailing punctuation.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].exclamationMark || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].quotationMark || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].apostrophe || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightParenthesis || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].asterisk || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].comma || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dot || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].colon || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].semicolon || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].questionMark || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].underscore || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde) {
            effects.consume(code);
            return trail;
        }
        // `&` followed by one or more alphabeticals and then a `;`, is
        // as a whole considered as trailing punctuation.
        // In all other cases, it is considered as continuation of the URL.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].ampersand) {
            effects.consume(code);
            return trailCharRefStart;
        }
        // Needed because we allow literals after `[`, as we fix:
        // <https://github.com/github/cmark-gfm/issues/278>.
        // Check that it is not followed by `(` or `[`.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket) {
            effects.consume(code);
            return trailBracketAfter;
        }
        if (// `<` is an end.
        code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lessThan || // So is whitespace.
        code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodeWhitespace"])(code)) {
            return ok(code);
        }
        return nok(code);
    }
    /**
   * In trail, after `]`.
   *
   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.
   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.
   *
   * ```markdown
   * > | https://example.com](
   *                         ^
   * ```
   *
   * @type {State}
   */ function trailBracketAfter(code) {
        // Whitespace or something that could start a resource or reference is the end.
        // Switch back to trail otherwise.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftParenthesis || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodeWhitespace"])(code)) {
            return ok(code);
        }
        return trail(code);
    }
    /**
   * In character-reference like trail, after `&`.
   *
   * ```markdown
   * > | https://example.com&amp;).
   *                         ^
   * ```
   *
   * @type {State}
   */ function trailCharRefStart(code) {
        // When non-alpha, it’s not a trail.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlpha"])(code) ? trailCharRefInside(code) : nok(code);
    }
    /**
   * In character-reference like trail.
   *
   * ```markdown
   * > | https://example.com&amp;).
   *                         ^
   * ```
   *
   * @type {State}
   */ function trailCharRefInside(code) {
        // Switch back to trail if this is well-formed.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].semicolon) {
            effects.consume(code);
            return trail;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlpha"])(code)) {
            effects.consume(code);
            return trailCharRefInside;
        }
        // It’s not a trail.
        return nok(code);
    }
}
/**
 * Dot in email domain trail.
 *
 * This calls `ok` if this *is* the trail, followed by an end, which means
 * the trail is not part of the link.
 * It calls `nok` if this *is* part of the link.
 *
 * ```markdown
 * > | contact@example.org.
 *                        ^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeEmailDomainDotTrail(effects, ok, nok) {
    return start;
    //TURBOPACK unreachable
    ;
    /**
   * Dot.
   *
   * ```markdown
   * > | contact@example.org.
   *                    ^   ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        // Must be dot.
        effects.consume(code);
        return after;
    }
    /**
   * After dot.
   *
   * ```markdown
   * > | contact@example.org.
   *                     ^   ^
   * ```
   *
   * @type {State}
   */ function after(code) {
        // Not a trail if alphanumeric.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlphanumeric"])(code) ? nok(code) : ok(code);
    }
}
/**
 * See:
 * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.
 *
 * @type {Previous}
 */ function previousWww(code) {
    return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftParenthesis || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].asterisk || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].underscore || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code);
}
/**
 * See:
 * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.
 *
 * @type {Previous}
 */ function previousProtocol(code) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlpha"])(code);
}
/**
 * @this {TokenizeContext}
 * @type {Previous}
 */ function previousEmail(code) {
    // Do not allow a slash “inside” atext.
    // The reference code is a bit weird, but that’s what it results in.
    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.
    // Other than slash, every preceding character is allowed.
    return !(code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].slash || gfmAtext(code));
}
/**
 * @param {Code} code
 * @returns {boolean}
 */ function gfmAtext(code) {
    return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].plusSign || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dash || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dot || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].underscore || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlphanumeric"])(code);
}
/**
 * @param {Array<Event>} events
 * @returns {boolean}
 */ function previousUnbalanced(events) {
    let index = events.length;
    let result = false;
    while(index--){
        const token = events[index][1];
        if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {
            result = true;
            break;
        }
        // If we’ve seen this token, and it was marked as not having any unbalanced
        // bracket before it, we can exit.
        if (token._gfmAutolinkLiteralWalkedInto) {
            result = false;
            break;
        }
    }
    if (events.length > 0 && !result) {
        // Mark the last token as “walked into” w/o finding
        // anything.
        events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
    }
    return result;
}
}),
"[project]/node_modules/.pnpm/micromark-util-encode@1.1.0/node_modules/micromark-util-encode/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "encode": ()=>encode
});
const characterReferences = {
    '"': 'quot',
    '&': 'amp',
    '<': 'lt',
    '>': 'gt'
};
function encode(value) {
    return value.replace(/["&<>]/g, replace);
    //TURBOPACK unreachable
    ;
    /**
   * @param {string} value
   * @returns {string}
   */ function replace(value) {
        // @ts-expect-error Hush, it’s fine.
        return '&' + characterReferences[value] + ';';
    }
}
}),
"[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/values.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * This module is compiled away!
 *
 * While micromark works based on character codes, this module includes the
 * string versions of ’em.
 * The C0 block, except for LF, CR, HT, and w/ the replacement character added,
 * are available here.
 */ __turbopack_context__.s({
    "values": ()=>values
});
const values = {
    ht: '\t',
    lf: '\n',
    cr: '\r',
    space: ' ',
    exclamationMark: '!',
    quotationMark: '"',
    numberSign: '#',
    dollarSign: '$',
    percentSign: '%',
    ampersand: '&',
    apostrophe: "'",
    leftParenthesis: '(',
    rightParenthesis: ')',
    asterisk: '*',
    plusSign: '+',
    comma: ',',
    dash: '-',
    dot: '.',
    slash: '/',
    digit0: '0',
    digit1: '1',
    digit2: '2',
    digit3: '3',
    digit4: '4',
    digit5: '5',
    digit6: '6',
    digit7: '7',
    digit8: '8',
    digit9: '9',
    colon: ':',
    semicolon: ';',
    lessThan: '<',
    equalsTo: '=',
    greaterThan: '>',
    questionMark: '?',
    atSign: '@',
    uppercaseA: 'A',
    uppercaseB: 'B',
    uppercaseC: 'C',
    uppercaseD: 'D',
    uppercaseE: 'E',
    uppercaseF: 'F',
    uppercaseG: 'G',
    uppercaseH: 'H',
    uppercaseI: 'I',
    uppercaseJ: 'J',
    uppercaseK: 'K',
    uppercaseL: 'L',
    uppercaseM: 'M',
    uppercaseN: 'N',
    uppercaseO: 'O',
    uppercaseP: 'P',
    uppercaseQ: 'Q',
    uppercaseR: 'R',
    uppercaseS: 'S',
    uppercaseT: 'T',
    uppercaseU: 'U',
    uppercaseV: 'V',
    uppercaseW: 'W',
    uppercaseX: 'X',
    uppercaseY: 'Y',
    uppercaseZ: 'Z',
    leftSquareBracket: '[',
    backslash: '\\',
    rightSquareBracket: ']',
    caret: '^',
    underscore: '_',
    graveAccent: '`',
    lowercaseA: 'a',
    lowercaseB: 'b',
    lowercaseC: 'c',
    lowercaseD: 'd',
    lowercaseE: 'e',
    lowercaseF: 'f',
    lowercaseG: 'g',
    lowercaseH: 'h',
    lowercaseI: 'i',
    lowercaseJ: 'j',
    lowercaseK: 'k',
    lowercaseL: 'l',
    lowercaseM: 'm',
    lowercaseN: 'n',
    lowercaseO: 'o',
    lowercaseP: 'p',
    lowercaseQ: 'q',
    lowercaseR: 'r',
    lowercaseS: 's',
    lowercaseT: 't',
    lowercaseU: 'u',
    lowercaseV: 'v',
    lowercaseW: 'w',
    lowercaseX: 'x',
    lowercaseY: 'y',
    lowercaseZ: 'z',
    leftCurlyBrace: '{',
    verticalBar: '|',
    rightCurlyBrace: '}',
    tilde: '~',
    replacementCharacter: '�'
};
}),
"[project]/node_modules/.pnpm/micromark-util-sanitize-uri@1.2.0/node_modules/micromark-util-sanitize-uri/dev/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "normalizeUri": ()=>normalizeUri,
    "sanitizeUri": ()=>sanitizeUri
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$encode$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$encode$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-encode@1.1.0/node_modules/micromark-util-encode/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/values.js [app-client] (ecmascript)");
;
;
;
;
function sanitizeUri(url, protocol) {
    const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$encode$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$encode$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])(normalizeUri(url || ''));
    if (!protocol) {
        return value;
    }
    const colon = value.indexOf(':');
    const questionMark = value.indexOf('?');
    const numberSign = value.indexOf('#');
    const slash = value.indexOf('/');
    if (// If there is no protocol, it’s relative.
    colon < 0 || slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.
    protocol.test(value.slice(0, colon))) {
        return value;
    }
    return '';
}
function normalizeUri(value) {
    /** @type {Array<string>} */ const result = [];
    let index = -1;
    let start = 0;
    let skip = 0;
    while(++index < value.length){
        const code = value.charCodeAt(index);
        /** @type {string} */ let replace = '';
        // A correct percent encoded value.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].percentSign && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlphanumeric"])(value.charCodeAt(index + 1)) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asciiAlphanumeric"])(value.charCodeAt(index + 2))) {
            skip = 2;
        } else if (code < 128) {
            if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {
                replace = String.fromCharCode(code);
            }
        } else if (code > 55295 && code < 57344) {
            const next = value.charCodeAt(index + 1);
            // A correct surrogate pair.
            if (code < 56320 && next > 56319 && next < 57344) {
                replace = String.fromCharCode(code, next);
                skip = 1;
            } else {
                replace = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["values"].replacementCharacter;
            }
        } else {
            replace = String.fromCharCode(code);
        }
        if (replace) {
            result.push(value.slice(start, index), encodeURIComponent(replace));
            start = index + skip + 1;
            replace = '';
        }
        if (skip) {
            index += skip;
            skip = 0;
        }
    }
    return result.join('') + value.slice(start);
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').CompileContext} CompileContext
 * @typedef {import('micromark-util-types').Handle} Handle
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 * @typedef {import('micromark-util-types').Token} Token
 */ __turbopack_context__.s({
    "gfmAutolinkLiteralHtml": ()=>gfmAutolinkLiteralHtml
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$sanitize$2d$uri$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$sanitize$2d$uri$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-sanitize-uri@1.2.0/node_modules/micromark-util-sanitize-uri/dev/index.js [app-client] (ecmascript)");
;
const gfmAutolinkLiteralHtml = {
    exit: {
        literalAutolinkEmail,
        literalAutolinkHttp,
        literalAutolinkWww
    }
};
/**
 * @this {CompileContext}
 * @type {Handle}
 */ function literalAutolinkWww(token) {
    anchorFromToken.call(this, token, 'http://');
}
/**
 * @this {CompileContext}
 * @type {Handle}
 */ function literalAutolinkEmail(token) {
    anchorFromToken.call(this, token, 'mailto:');
}
/**
 * @this {CompileContext}
 * @type {Handle}
 */ function literalAutolinkHttp(token) {
    anchorFromToken.call(this, token);
}
/**
 * @this CompileContext
 * @param {Token} token
 * @param {string | null | undefined} [protocol]
 * @returns {void}
 */ function anchorFromToken(token, protocol) {
    const url = this.sliceSerialize(token);
    this.tag('<a href="' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$sanitize$2d$uri$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$sanitize$2d$uri$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sanitizeUri"])((protocol || '') + url) + '">');
    this.raw(this.encode(url));
    this.tag('</a>');
}
}),
"[project]/node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "dequal": ()=>dequal
});
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
    for (key of iter.keys()){
        if (dequal(key, tar)) return key;
    }
}
function dequal(foo, bar) {
    var ctor, len, tmp;
    if (foo === bar) return true;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
        if (ctor === Date) return foo.getTime() === bar.getTime();
        if (ctor === RegExp) return foo.toString() === bar.toString();
        if (ctor === Array) {
            if ((len = foo.length) === bar.length) {
                while(len-- && dequal(foo[len], bar[len]));
            }
            return len === -1;
        }
        if (ctor === Set) {
            if (foo.size !== bar.size) {
                return false;
            }
            for (len of foo){
                tmp = len;
                if (tmp && typeof tmp === 'object') {
                    tmp = find(bar, tmp);
                    if (!tmp) return false;
                }
                if (!bar.has(tmp)) return false;
            }
            return true;
        }
        if (ctor === Map) {
            if (foo.size !== bar.size) {
                return false;
            }
            for (len of foo){
                tmp = len[0];
                if (tmp && typeof tmp === 'object') {
                    tmp = find(bar, tmp);
                    if (!tmp) return false;
                }
                if (!dequal(len[1], bar.get(tmp))) {
                    return false;
                }
            }
            return true;
        }
        if (ctor === ArrayBuffer) {
            foo = new Uint8Array(foo);
            bar = new Uint8Array(bar);
        } else if (ctor === DataView) {
            if ((len = foo.byteLength) === bar.byteLength) {
                while(len-- && foo.getInt8(len) === bar.getInt8(len));
            }
            return len === -1;
        }
        if (ArrayBuffer.isView(foo)) {
            if ((len = foo.byteLength) === bar.byteLength) {
                while(len-- && foo[len] === bar[len]);
            }
            return len === -1;
        }
        if (!ctor || typeof foo === 'object') {
            len = 0;
            for(ctor in foo){
                if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
                if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
            }
            return Object.keys(bar).length === len;
        }
    }
    return foo !== foo && bar !== bar;
}
}),
"[project]/node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$5_$40$babel$2b$core$40$7$2e$2_ed7b963b8b79c6973a19a9ac5bbdca45$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/.pnpm/next@15.4.5_@babel+core@7.2_ed7b963b8b79c6973a19a9ac5bbdca45/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY = true;
if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$5_$40$babel$2b$core$40$7$2e$2_ed7b963b8b79c6973a19a9ac5bbdca45$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined') {
    ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$5_$40$babel$2b$core$40$7$2e$2_ed7b963b8b79c6973a19a9ac5bbdca45$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env || {});
    isTTY = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$5_$40$babel$2b$core$40$7$2e$2_ed7b963b8b79c6973a19a9ac5bbdca45$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdout && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$15$2e$4$2e$5_$40$babel$2b$core$40$7$2e$2_ed7b963b8b79c6973a19a9ac5bbdca45$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdout.isTTY;
}
const $ = {
    enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY),
    // modifiers
    reset: init(0, 0),
    bold: init(1, 22),
    dim: init(2, 22),
    italic: init(3, 23),
    underline: init(4, 24),
    inverse: init(7, 27),
    hidden: init(8, 28),
    strikethrough: init(9, 29),
    // colors
    black: init(30, 39),
    red: init(31, 39),
    green: init(32, 39),
    yellow: init(33, 39),
    blue: init(34, 39),
    magenta: init(35, 39),
    cyan: init(36, 39),
    white: init(37, 39),
    gray: init(90, 39),
    grey: init(90, 39),
    // background colors
    bgBlack: init(40, 49),
    bgRed: init(41, 49),
    bgGreen: init(42, 49),
    bgYellow: init(43, 49),
    bgBlue: init(44, 49),
    bgMagenta: init(45, 49),
    bgCyan: init(46, 49),
    bgWhite: init(47, 49)
};
function run(arr, str) {
    let i = 0, tmp, beg = '', end = '';
    for(; i < arr.length; i++){
        tmp = arr[i];
        beg += tmp.open;
        end += tmp.close;
        if (!!~str.indexOf(tmp.close)) {
            str = str.replace(tmp.rgx, tmp.close + tmp.open);
        }
    }
    return beg + str + end;
}
function chain(has, keys) {
    let ctx = {
        has,
        keys
    };
    ctx.reset = $.reset.bind(ctx);
    ctx.bold = $.bold.bind(ctx);
    ctx.dim = $.dim.bind(ctx);
    ctx.italic = $.italic.bind(ctx);
    ctx.underline = $.underline.bind(ctx);
    ctx.inverse = $.inverse.bind(ctx);
    ctx.hidden = $.hidden.bind(ctx);
    ctx.strikethrough = $.strikethrough.bind(ctx);
    ctx.black = $.black.bind(ctx);
    ctx.red = $.red.bind(ctx);
    ctx.green = $.green.bind(ctx);
    ctx.yellow = $.yellow.bind(ctx);
    ctx.blue = $.blue.bind(ctx);
    ctx.magenta = $.magenta.bind(ctx);
    ctx.cyan = $.cyan.bind(ctx);
    ctx.white = $.white.bind(ctx);
    ctx.gray = $.gray.bind(ctx);
    ctx.grey = $.grey.bind(ctx);
    ctx.bgBlack = $.bgBlack.bind(ctx);
    ctx.bgRed = $.bgRed.bind(ctx);
    ctx.bgGreen = $.bgGreen.bind(ctx);
    ctx.bgYellow = $.bgYellow.bind(ctx);
    ctx.bgBlue = $.bgBlue.bind(ctx);
    ctx.bgMagenta = $.bgMagenta.bind(ctx);
    ctx.bgCyan = $.bgCyan.bind(ctx);
    ctx.bgWhite = $.bgWhite.bind(ctx);
    return ctx;
}
function init(open, close) {
    let blk = {
        open: "\x1b[".concat(open, "m"),
        close: "\x1b[".concat(close, "m"),
        rgx: new RegExp("\\x1b\\[".concat(close, "m"), 'g')
    };
    return function(txt) {
        if (this !== void 0 && this.has !== void 0) {
            !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
            return txt === void 0 ? this : $.enabled ? run(this.keys, txt + '') : txt + '';
        }
        return txt === void 0 ? chain([
            open
        ], [
            blk
        ]) : $.enabled ? run([
            blk
        ], txt + '') : txt + '';
    };
}
const __TURBOPACK__default__export__ = $;
}),
"[project]/node_modules/.pnpm/diff@5.2.0/node_modules/diff/lib/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Diff": ()=>Diff,
    "applyPatch": ()=>applyPatch,
    "applyPatches": ()=>applyPatches,
    "canonicalize": ()=>canonicalize,
    "convertChangesToDMP": ()=>convertChangesToDMP,
    "convertChangesToXML": ()=>convertChangesToXML,
    "createPatch": ()=>createPatch,
    "createTwoFilesPatch": ()=>createTwoFilesPatch,
    "diffArrays": ()=>diffArrays,
    "diffChars": ()=>diffChars,
    "diffCss": ()=>diffCss,
    "diffJson": ()=>diffJson,
    "diffLines": ()=>diffLines,
    "diffSentences": ()=>diffSentences,
    "diffTrimmedLines": ()=>diffTrimmedLines,
    "diffWords": ()=>diffWords,
    "diffWordsWithSpace": ()=>diffWordsWithSpace,
    "formatPatch": ()=>formatPatch,
    "merge": ()=>merge,
    "parsePatch": ()=>parsePatch,
    "reversePatch": ()=>reversePatch,
    "structuredPatch": ()=>structuredPatch
});
function Diff() {}
Diff.prototype = {
    diff: function diff(oldString, newString) {
        var _options$timeout;
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        this.options = options;
        var self = this;
        function done(value) {
            if (callback) {
                setTimeout(function() {
                    callback(undefined, value);
                }, 0);
                return true;
            } else {
                return value;
            }
        } // Allow subclasses to massage the input prior to running
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        if (options.maxEditLength) {
            maxEditLength = Math.min(maxEditLength, options.maxEditLength);
        }
        var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
        var abortAfterTimestamp = Date.now() + maxExecutionTime;
        var bestPath = [
            {
                oldPos: -1,
                lastComponent: undefined
            }
        ]; // Seed editLength = 0, i.e. the content starts with the same values
        var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
            // Identity per the equality and tokenizer
            return done([
                {
                    value: this.join(newString),
                    count: newString.length
                }
            ]);
        } // Once we hit the right edge of the edit graph on some diagonal k, we can
        // definitely reach the end of the edit graph in no more than k edits, so
        // there's no point in considering any moves to diagonal k+1 any more (from
        // which we're guaranteed to need at least k+1 more edits).
        // Similarly, once we've reached the bottom of the edit graph, there's no
        // point considering moves to lower diagonals.
        // We record this fact by setting minDiagonalToConsider and
        // maxDiagonalToConsider to some finite value once we've hit the edge of
        // the edit graph.
        // This optimization is not faithful to the original algorithm presented in
        // Myers's paper, which instead pointlessly extends D-paths off the end of
        // the edit graph - see page 7 of Myers's paper which notes this point
        // explicitly and illustrates it with a diagram. This has major performance
        // implications for some common scenarios. For instance, to compute a diff
        // where the new text simply appends d characters on the end of the
        // original text of length n, the true Myers algorithm will take O(n+d^2)
        // time while this optimization needs only O(n+d) time.
        var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.
        function execEditLength() {
            for(var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2){
                var basePath = void 0;
                var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
                if (removePath) {
                    // No one else is going to attempt to use this value, clear it
                    bestPath[diagonalPath - 1] = undefined;
                }
                var canAdd = false;
                if (addPath) {
                    // what newPos will be after we do an insertion:
                    var addPathNewPos = addPath.oldPos - diagonalPath;
                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
                }
                var canRemove = removePath && removePath.oldPos + 1 < oldLen;
                if (!canAdd && !canRemove) {
                    // If this path is a terminal then prune
                    bestPath[diagonalPath] = undefined;
                    continue;
                } // Select the diagonal that we want to branch from. We select the prior
                // path whose position in the old string is the farthest from the origin
                // and does not pass the bounds of the diff graph
                // TODO: Remove the `+ 1` here to make behavior match Myers algorithm
                //       and prefer to order removals before insertions.
                if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
                    basePath = self.addToPath(addPath, true, undefined, 0);
                } else {
                    basePath = self.addToPath(removePath, undefined, true, 1);
                }
                newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
                    // If we have hit the end of both strings, then we are done
                    return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
                } else {
                    bestPath[diagonalPath] = basePath;
                    if (basePath.oldPos + 1 >= oldLen) {
                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
                    }
                    if (newPos + 1 >= newLen) {
                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
                    }
                }
            }
            editLength++;
        } // Performs the length of edit iteration. Is a bit fugly as this has to support the
        // sync and async mode which is never fun. Loops over execEditLength until a value
        // is produced, or until the edit length exceeds options.maxEditLength (if given),
        // in which case it will return undefined.
        if (callback) {
            (function exec() {
                setTimeout(function() {
                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
                        return callback();
                    }
                    if (!execEditLength()) {
                        exec();
                    }
                }, 0);
            })();
        } else {
            while(editLength <= maxEditLength && Date.now() <= abortAfterTimestamp){
                var ret = execEditLength();
                if (ret) {
                    return ret;
                }
            }
        }
    },
    addToPath: function addToPath(path, added, removed, oldPosInc) {
        var last = path.lastComponent;
        if (last && last.added === added && last.removed === removed) {
            return {
                oldPos: path.oldPos + oldPosInc,
                lastComponent: {
                    count: last.count + 1,
                    added: added,
                    removed: removed,
                    previousComponent: last.previousComponent
                }
            };
        } else {
            return {
                oldPos: path.oldPos + oldPosInc,
                lastComponent: {
                    count: 1,
                    added: added,
                    removed: removed,
                    previousComponent: last
                }
            };
        }
    },
    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
        while(newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])){
            newPos++;
            oldPos++;
            commonCount++;
        }
        if (commonCount) {
            basePath.lastComponent = {
                count: commonCount,
                previousComponent: basePath.lastComponent
            };
        }
        basePath.oldPos = oldPos;
        return newPos;
    },
    equals: function equals(left, right) {
        if (this.options.comparator) {
            return this.options.comparator(left, right);
        } else {
            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
    },
    removeEmpty: function removeEmpty(array) {
        var ret = [];
        for(var i = 0; i < array.length; i++){
            if (array[i]) {
                ret.push(array[i]);
            }
        }
        return ret;
    },
    castInput: function castInput(value) {
        return value;
    },
    tokenize: function tokenize(value) {
        return value.split('');
    },
    join: function join(chars) {
        return chars.join('');
    }
};
function buildValues(diff, lastComponent, newString, oldString, useLongestToken) {
    // First we convert our linked list of components in reverse order to an
    // array in the right order:
    var components = [];
    var nextComponent;
    while(lastComponent){
        components.push(lastComponent);
        nextComponent = lastComponent.previousComponent;
        delete lastComponent.previousComponent;
        lastComponent = nextComponent;
    }
    components.reverse();
    var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
    for(; componentPos < componentLen; componentPos++){
        var component = components[componentPos];
        if (!component.removed) {
            if (!component.added && useLongestToken) {
                var value = newString.slice(newPos, newPos + component.count);
                value = value.map(function(value, i) {
                    var oldValue = oldString[oldPos + i];
                    return oldValue.length > value.length ? oldValue : value;
                });
                component.value = diff.join(value);
            } else {
                component.value = diff.join(newString.slice(newPos, newPos + component.count));
            }
            newPos += component.count; // Common case
            if (!component.added) {
                oldPos += component.count;
            }
        } else {
            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
            oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
            // The diffing algorithm is tied to add then remove output and this is the simplest
            // route to get the desired output with minimal overhead.
            if (componentPos && components[componentPos - 1].added) {
                var tmp = components[componentPos - 1];
                components[componentPos - 1] = components[componentPos];
                components[componentPos] = tmp;
            }
        }
    } // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.
    var finalComponent = components[componentLen - 1];
    if (componentLen > 1 && typeof finalComponent.value === 'string' && (finalComponent.added || finalComponent.removed) && diff.equals('', finalComponent.value)) {
        components[componentLen - 2].value += finalComponent.value;
        components.pop();
    }
    return components;
}
var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
    return characterDiff.diff(oldStr, newStr, options);
}
function generateOptions(options, defaults) {
    if (typeof options === 'function') {
        defaults.callback = options;
    } else if (options) {
        for(var name in options){
            /* istanbul ignore else */ if (options.hasOwnProperty(name)) {
                defaults[name] = options[name];
            }
        }
    }
    return defaults;
}
//
// Ranges and exceptions:
// Latin-1 Supplement, 0080–00FF
//  - U+00D7  × Multiplication sign
//  - U+00F7  ÷ Division sign
// Latin Extended-A, 0100–017F
// Latin Extended-B, 0180–024F
// IPA Extensions, 0250–02AF
// Spacing Modifier Letters, 02B0–02FF
//  - U+02C7  ˇ &#711;  Caron
//  - U+02D8  ˘ &#728;  Breve
//  - U+02D9  ˙ &#729;  Dot Above
//  - U+02DA  ˚ &#730;  Ring Above
//  - U+02DB  ˛ &#731;  Ogonek
//  - U+02DC  ˜ &#732;  Small Tilde
//  - U+02DD  ˝ &#733;  Double Acute Accent
// Latin Extended Additional, 1E00–1EFF
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left, right) {
    if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
    }
    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function(value) {
    // All whitespace symbols except newline group into one token, each newline - in separate token
    var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
    for(var i = 0; i < tokens.length - 1; i++){
        // If we have an empty string in the next field and we have only word chars before and after, merge
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
            tokens[i] += tokens[i + 2];
            tokens.splice(i + 1, 2);
            i--;
        }
    }
    return tokens;
};
function diffWords(oldStr, newStr, options) {
    options = generateOptions(options, {
        ignoreWhitespace: true
    });
    return wordDiff.diff(oldStr, newStr, options);
}
function diffWordsWithSpace(oldStr, newStr, options) {
    return wordDiff.diff(oldStr, newStr, options);
}
var lineDiff = new Diff();
lineDiff.tokenize = function(value) {
    if (this.options.stripTrailingCr) {
        // remove one \r before \n to match GNU diff's --strip-trailing-cr behavior
        value = value.replace(/\r\n/g, '\n');
    }
    var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line
    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
    } // Merge the content and line separators into single tokens
    for(var i = 0; i < linesAndNewlines.length; i++){
        var line = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
            retLines[retLines.length - 1] += line;
        } else {
            if (this.options.ignoreWhitespace) {
                line = line.trim();
            }
            retLines.push(line);
        }
    }
    return retLines;
};
function diffLines(oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback);
}
function diffTrimmedLines(oldStr, newStr, callback) {
    var options = generateOptions(callback, {
        ignoreWhitespace: true
    });
    return lineDiff.diff(oldStr, newStr, options);
}
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
function diffSentences(oldStr, newStr, callback) {
    return sentenceDiff.diff(oldStr, newStr, callback);
}
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
    return value.split(/([{}:;,]|\s+)/);
};
function diffCss(oldStr, newStr, callback) {
    return cssDiff.diff(oldStr, newStr, callback);
}
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value) {
    var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
        return typeof v === 'undefined' ? undefinedReplacement : v;
    } : _this$options$stringi;
    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};
jsonDiff.equals = function(left, right) {
    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
};
function diffJson(oldObj, newObj, options) {
    return jsonDiff.diff(oldObj, newObj, options);
} // This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed. Accepts an optional replacer
function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [];
    replacementStack = replacementStack || [];
    if (replacer) {
        obj = replacer(key, obj);
    }
    var i;
    for(i = 0; i < stack.length; i += 1){
        if (stack[i] === obj) {
            return replacementStack[i];
        }
    }
    var canonicalizedObj;
    if ('[object Array]' === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for(i = 0; i < obj.length; i += 1){
            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
    }
    if (obj && obj.toJSON) {
        obj = obj.toJSON();
    }
    if (_typeof(obj) === 'object' && obj !== null) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [], _key;
        for(_key in obj){
            /* istanbul ignore else */ if (obj.hasOwnProperty(_key)) {
                sortedKeys.push(_key);
            }
        }
        sortedKeys.sort();
        for(i = 0; i < sortedKeys.length; i += 1){
            _key = sortedKeys[i];
            canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
        }
        stack.pop();
        replacementStack.pop();
    } else {
        canonicalizedObj = obj;
    }
    return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
    return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
    return value;
};
function diffArrays(oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback);
}
function parsePatch(uniDiff) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
    function parseIndex() {
        var index = {};
        list.push(index); // Parse diff metadata
        while(i < diffstr.length){
            var line = diffstr[i]; // File header found, end parsing diff metadata
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
                break;
            } // Diff index
            var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
            if (header) {
                index.index = header[1];
            }
            i++;
        } // Parse file headers if they are defined. Unified diff requires them, but
        // there's no technical issues to have an isolated hunk without file header
        parseFileHeader(index);
        parseFileHeader(index); // Parse hunks
        index.hunks = [];
        while(i < diffstr.length){
            var _line = diffstr[i];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
                break;
            } else if (/^@@/.test(_line)) {
                index.hunks.push(parseHunk());
            } else if (_line && options.strict) {
                // Ignore unexpected content unless in strict mode
                throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
            } else {
                i++;
            }
        }
    } // Parses the --- and +++ headers, if none are found, no lines
    // are consumed.
    function parseFileHeader(index) {
        var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
        if (fileHeader) {
            var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
            var data = fileHeader[2].split('\t', 2);
            var fileName = data[0].replace(/\\\\/g, '\\');
            if (/^".*"$/.test(fileName)) {
                fileName = fileName.substr(1, fileName.length - 2);
            }
            index[keyPrefix + 'FileName'] = fileName;
            index[keyPrefix + 'Header'] = (data[1] || '').trim();
            i++;
        }
    } // Parses a hunk
    // This assumes that we are at the start of a hunk.
    function parseHunk() {
        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
        var hunk = {
            oldStart: +chunkHeader[1],
            oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],
            newStart: +chunkHeader[3],
            newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],
            lines: [],
            linedelimiters: []
        }; // Unified Diff Format quirk: If the chunk size is 0,
        // the first number is one lower than one would expect.
        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293
        if (hunk.oldLines === 0) {
            hunk.oldStart += 1;
        }
        if (hunk.newLines === 0) {
            hunk.newStart += 1;
        }
        var addCount = 0, removeCount = 0;
        for(; i < diffstr.length; i++){
            // Lines starting with '---' could be mistaken for the "remove line" operation
            // But they could be the header for the next file. Therefore prune such cases out.
            if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
                break;
            }
            var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];
            if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
                hunk.lines.push(diffstr[i]);
                hunk.linedelimiters.push(delimiters[i] || '\n');
                if (operation === '+') {
                    addCount++;
                } else if (operation === '-') {
                    removeCount++;
                } else if (operation === ' ') {
                    addCount++;
                    removeCount++;
                }
            } else {
                break;
            }
        } // Handle the empty block count case
        if (!addCount && hunk.newLines === 1) {
            hunk.newLines = 0;
        }
        if (!removeCount && hunk.oldLines === 1) {
            hunk.oldLines = 0;
        } // Perform optional sanity checking
        if (options.strict) {
            if (addCount !== hunk.newLines) {
                throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
            }
            if (removeCount !== hunk.oldLines) {
                throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
            }
        }
        return hunk;
    }
    while(i < diffstr.length){
        parseIndex();
    }
    return list;
}
// Iterator that traverses in the range of [min, max], stepping
// by distance from a given start position. I.e. for [0, 4], with
// start of 2, this will iterate 2, 3, 1, 4, 0.
function distanceIterator(start, minLine, maxLine) {
    var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
    return function iterator() {
        if (wantForward && !forwardExhausted) {
            if (backwardExhausted) {
                localOffset++;
            } else {
                wantForward = false;
            } // Check if trying to fit beyond text length, and if not, check it fits
            // after offset location (or desired location on first iteration)
            if (start + localOffset <= maxLine) {
                return localOffset;
            }
            forwardExhausted = true;
        }
        if (!backwardExhausted) {
            if (!forwardExhausted) {
                wantForward = true;
            } // Check if trying to fit before text beginning, and if not, check it fits
            // before offset location
            if (minLine <= start - localOffset) {
                return -localOffset++;
            }
            backwardExhausted = true;
            return iterator();
        } // We tried to fit hunk before text beginning and beyond text length, then
    // hunk can't fit on the text. Return undefined
    };
}
function applyPatch(source, uniDiff) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (typeof uniDiff === 'string') {
        uniDiff = parsePatch(uniDiff);
    }
    if (Array.isArray(uniDiff)) {
        if (uniDiff.length > 1) {
            throw new Error('applyPatch only works with a single input.');
        }
        uniDiff = uniDiff[0];
    } // Apply the diff to the input
    var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {
        return line === patchContent;
    }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
    /**
   * Checks if the hunk exactly fits on the provided location
   */ function hunkFits(hunk, toPos) {
        for(var j = 0; j < hunk.lines.length; j++){
            var line = hunk.lines[j], operation = line.length > 0 ? line[0] : ' ', content = line.length > 0 ? line.substr(1) : line;
            if (operation === ' ' || operation === '-') {
                // Context sanity check
                if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
                    errorCount++;
                    if (errorCount > fuzzFactor) {
                        return false;
                    }
                }
                toPos++;
            }
        }
        return true;
    } // Search best fit offsets for each hunk based on the previous ones
    for(var i = 0; i < hunks.length; i++){
        var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
        var iterator = distanceIterator(toPos, minLine, maxLine);
        for(; localOffset !== undefined; localOffset = iterator()){
            if (hunkFits(hunk, toPos + localOffset)) {
                hunk.offset = offset += localOffset;
                break;
            }
        }
        if (localOffset === undefined) {
            return false;
        } // Set lower text limit to end of the current hunk, so next ones don't try
        // to fit over already patched text
        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
    } // Apply patch hunks
    var diffOffset = 0;
    for(var _i = 0; _i < hunks.length; _i++){
        var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
        diffOffset += _hunk.newLines - _hunk.oldLines;
        for(var j = 0; j < _hunk.lines.length; j++){
            var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : ' ', content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || '\n';
            if (operation === ' ') {
                _toPos++;
            } else if (operation === '-') {
                lines.splice(_toPos, 1);
                delimiters.splice(_toPos, 1);
            /* istanbul ignore else */ } else if (operation === '+') {
                lines.splice(_toPos, 0, content);
                delimiters.splice(_toPos, 0, delimiter);
                _toPos++;
            } else if (operation === '\\') {
                var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
                if (previousOperation === '+') {
                    removeEOFNL = true;
                } else if (previousOperation === '-') {
                    addEOFNL = true;
                }
            }
        }
    } // Handle EOFNL insertion/removal
    if (removeEOFNL) {
        while(!lines[lines.length - 1]){
            lines.pop();
            delimiters.pop();
        }
    } else if (addEOFNL) {
        lines.push('');
        delimiters.push('\n');
    }
    for(var _k = 0; _k < lines.length - 1; _k++){
        lines[_k] = lines[_k] + delimiters[_k];
    }
    return lines.join('');
} // Wrapper that supports multiple file patches via callbacks.
function applyPatches(uniDiff, options) {
    if (typeof uniDiff === 'string') {
        uniDiff = parsePatch(uniDiff);
    }
    var currentIndex = 0;
    function processIndex() {
        var index = uniDiff[currentIndex++];
        if (!index) {
            return options.complete();
        }
        options.loadFile(index, function(err, data) {
            if (err) {
                return options.complete(err);
            }
            var updatedContent = applyPatch(data, index, options);
            options.patched(index, updatedContent, function(err) {
                if (err) {
                    return options.complete(err);
                }
                processIndex();
            });
        });
    }
    processIndex();
}
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    if (!options) {
        options = {};
    }
    if (typeof options.context === 'undefined') {
        options.context = 4;
    }
    var diff = diffLines(oldStr, newStr, options);
    if (!diff) {
        return;
    }
    diff.push({
        value: '',
        lines: []
    }); // Append an empty value to make cleanup easier
    function contextLines(lines) {
        return lines.map(function(entry) {
            return ' ' + entry;
        });
    }
    var hunks = [];
    var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    var _loop = function _loop(i) {
        var current = diff[i], lines = current.lines || current.value.replace(/\n$/, '').split('\n');
        current.lines = lines;
        if (current.added || current.removed) {
            var _curRange;
            // If we have previous context, start with that
            if (!oldRangeStart) {
                var prev = diff[i - 1];
                oldRangeStart = oldLine;
                newRangeStart = newLine;
                if (prev) {
                    curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
                    oldRangeStart -= curRange.length;
                    newRangeStart -= curRange.length;
                }
            } // Output our changes
            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
                return (current.added ? '+' : '-') + entry;
            }))); // Track the updated file position
            if (current.added) {
                newLine += lines.length;
            } else {
                oldLine += lines.length;
            }
        } else {
            // Identical context lines. Track line changes
            if (oldRangeStart) {
                // Close out any changes that have been output (or join overlapping)
                if (lines.length <= options.context * 2 && i < diff.length - 2) {
                    var _curRange2;
                    // Overlapping
                    (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
                } else {
                    var _curRange3;
                    // end the range and output
                    var contextSize = Math.min(lines.length, options.context);
                    (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
                    var hunk = {
                        oldStart: oldRangeStart,
                        oldLines: oldLine - oldRangeStart + contextSize,
                        newStart: newRangeStart,
                        newLines: newLine - newRangeStart + contextSize,
                        lines: curRange
                    };
                    if (i >= diff.length - 2 && lines.length <= options.context) {
                        // EOF is inside this hunk
                        var oldEOFNewline = /\n$/.test(oldStr);
                        var newEOFNewline = /\n$/.test(newStr);
                        var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                        if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
                            // special case: old has no eol and no trailing context; no-nl can end up before adds
                            // however, if the old file is empty, do not output the no-nl line
                            curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
                        }
                        if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                            curRange.push('\\ No newline at end of file');
                        }
                    }
                    hunks.push(hunk);
                    oldRangeStart = 0;
                    newRangeStart = 0;
                    curRange = [];
                }
            }
            oldLine += lines.length;
            newLine += lines.length;
        }
    };
    for(var i = 0; i < diff.length; i++){
        _loop(i);
    }
    return {
        oldFileName: oldFileName,
        newFileName: newFileName,
        oldHeader: oldHeader,
        newHeader: newHeader,
        hunks: hunks
    };
}
function formatPatch(diff) {
    if (Array.isArray(diff)) {
        return diff.map(formatPatch).join('\n');
    }
    var ret = [];
    if (diff.oldFileName == diff.newFileName) {
        ret.push('Index: ' + diff.oldFileName);
    }
    ret.push('===================================================================');
    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));
    for(var i = 0; i < diff.hunks.length; i++){
        var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,
        // the first number is one lower than one would expect.
        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293
        if (hunk.oldLines === 0) {
            hunk.oldStart -= 1;
        }
        if (hunk.newLines === 0) {
            hunk.newStart -= 1;
        }
        ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
        ret.push.apply(ret, hunk.lines);
    }
    return ret.join('\n') + '\n';
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
}
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}
function arrayEqual(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    return arrayStartsWith(a, b);
}
function arrayStartsWith(array, start) {
    if (start.length > array.length) {
        return false;
    }
    for(var i = 0; i < start.length; i++){
        if (start[i] !== array[i]) {
            return false;
        }
    }
    return true;
}
function calcLineCount(hunk) {
    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
    if (oldLines !== undefined) {
        hunk.oldLines = oldLines;
    } else {
        delete hunk.oldLines;
    }
    if (newLines !== undefined) {
        hunk.newLines = newLines;
    } else {
        delete hunk.newLines;
    }
}
function merge(mine, theirs, base) {
    mine = loadPatch(mine, base);
    theirs = loadPatch(theirs, base);
    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
    // Leaving sanity checks on this to the API consumer that may know more about the
    // meaning in their own context.
    if (mine.index || theirs.index) {
        ret.index = mine.index || theirs.index;
    }
    if (mine.newFileName || theirs.newFileName) {
        if (!fileNameChanged(mine)) {
            // No header or no change in ours, use theirs (and ours if theirs does not exist)
            ret.oldFileName = theirs.oldFileName || mine.oldFileName;
            ret.newFileName = theirs.newFileName || mine.newFileName;
            ret.oldHeader = theirs.oldHeader || mine.oldHeader;
            ret.newHeader = theirs.newHeader || mine.newHeader;
        } else if (!fileNameChanged(theirs)) {
            // No header or no change in theirs, use ours
            ret.oldFileName = mine.oldFileName;
            ret.newFileName = mine.newFileName;
            ret.oldHeader = mine.oldHeader;
            ret.newHeader = mine.newHeader;
        } else {
            // Both changed... figure it out
            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
        }
    }
    ret.hunks = [];
    var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
    while(mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length){
        var mineCurrent = mine.hunks[mineIndex] || {
            oldStart: Infinity
        }, theirsCurrent = theirs.hunks[theirsIndex] || {
            oldStart: Infinity
        };
        if (hunkBefore(mineCurrent, theirsCurrent)) {
            // This patch does not overlap with any of the others, yay.
            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
            mineIndex++;
            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
        } else if (hunkBefore(theirsCurrent, mineCurrent)) {
            // This patch does not overlap with any of the others, yay.
            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
            theirsIndex++;
            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
        } else {
            // Overlap, merge as best we can
            var mergedHunk = {
                oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
                oldLines: 0,
                newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
                newLines: 0,
                lines: []
            };
            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
            theirsIndex++;
            mineIndex++;
            ret.hunks.push(mergedHunk);
        }
    }
    return ret;
}
function loadPatch(param, base) {
    if (typeof param === 'string') {
        if (/^@@/m.test(param) || /^Index:/m.test(param)) {
            return parsePatch(param)[0];
        }
        if (!base) {
            throw new Error('Must provide a base reference or pass in a patch');
        }
        return structuredPatch(undefined, undefined, base, param);
    }
    return param;
}
function fileNameChanged(patch) {
    return patch.newFileName && patch.newFileName !== patch.oldFileName;
}
function selectField(index, mine, theirs) {
    if (mine === theirs) {
        return mine;
    } else {
        index.conflict = true;
        return {
            mine: mine,
            theirs: theirs
        };
    }
}
function hunkBefore(test, check) {
    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}
function cloneHunk(hunk, offset) {
    return {
        oldStart: hunk.oldStart,
        oldLines: hunk.oldLines,
        newStart: hunk.newStart + offset,
        newLines: hunk.newLines,
        lines: hunk.lines
    };
}
function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
    // This will generally result in a conflicted hunk, but there are cases where the context
    // is the only overlap where we can successfully merge the content here.
    var mine = {
        offset: mineOffset,
        lines: mineLines,
        index: 0
    }, their = {
        offset: theirOffset,
        lines: theirLines,
        index: 0
    }; // Handle any leading content
    insertLeading(hunk, mine, their);
    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.
    while(mine.index < mine.lines.length && their.index < their.lines.length){
        var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
        if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
            // Both modified ...
            mutualChange(hunk, mine, their);
        } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
            var _hunk$lines;
            // Mine inserted
            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
        } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
            var _hunk$lines2;
            // Theirs inserted
            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
        } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
            // Mine removed or edited
            removal(hunk, mine, their);
        } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
            // Their removed or edited
            removal(hunk, their, mine, true);
        } else if (mineCurrent === theirCurrent) {
            // Context identity
            hunk.lines.push(mineCurrent);
            mine.index++;
            their.index++;
        } else {
            // Context mismatch
            conflict(hunk, collectChange(mine), collectChange(their));
        }
    } // Now push anything that may be remaining
    insertTrailing(hunk, mine);
    insertTrailing(hunk, their);
    calcLineCount(hunk);
}
function mutualChange(hunk, mine, their) {
    var myChanges = collectChange(mine), theirChanges = collectChange(their);
    if (allRemoves(myChanges) && allRemoves(theirChanges)) {
        // Special case for remove changes that are supersets of one another
        if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
            var _hunk$lines3;
            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
            return;
        } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
            var _hunk$lines4;
            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
            return;
        }
    } else if (arrayEqual(myChanges, theirChanges)) {
        var _hunk$lines5;
        (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
        return;
    }
    conflict(hunk, myChanges, theirChanges);
}
function removal(hunk, mine, their, swap) {
    var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
    if (theirChanges.merged) {
        var _hunk$lines6;
        (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
    } else {
        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
    }
}
function conflict(hunk, mine, their) {
    hunk.conflict = true;
    hunk.lines.push({
        conflict: true,
        mine: mine,
        theirs: their
    });
}
function insertLeading(hunk, insert, their) {
    while(insert.offset < their.offset && insert.index < insert.lines.length){
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
        insert.offset++;
    }
}
function insertTrailing(hunk, insert) {
    while(insert.index < insert.lines.length){
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
    }
}
function collectChange(state) {
    var ret = [], operation = state.lines[state.index][0];
    while(state.index < state.lines.length){
        var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.
        if (operation === '-' && line[0] === '+') {
            operation = '+';
        }
        if (operation === line[0]) {
            ret.push(line);
            state.index++;
        } else {
            break;
        }
    }
    return ret;
}
function collectContext(state, matchChanges) {
    var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
    while(matchIndex < matchChanges.length && state.index < state.lines.length){
        var change = state.lines[state.index], match = matchChanges[matchIndex]; // Once we've hit our add, then we are done
        if (match[0] === '+') {
            break;
        }
        contextChanges = contextChanges || change[0] !== ' ';
        merged.push(match);
        matchIndex++; // Consume any additions in the other block as a conflict to attempt
        // to pull in the remaining context after this
        if (change[0] === '+') {
            conflicted = true;
            while(change[0] === '+'){
                changes.push(change);
                change = state.lines[++state.index];
            }
        }
        if (match.substr(1) === change.substr(1)) {
            changes.push(change);
            state.index++;
        } else {
            conflicted = true;
        }
    }
    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
        conflicted = true;
    }
    if (conflicted) {
        return changes;
    }
    while(matchIndex < matchChanges.length){
        merged.push(matchChanges[matchIndex++]);
    }
    return {
        merged: merged,
        changes: changes
    };
}
function allRemoves(changes) {
    return changes.reduce(function(prev, change) {
        return prev && change[0] === '-';
    }, true);
}
function skipRemoveSuperset(state, removeChanges, delta) {
    for(var i = 0; i < delta; i++){
        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
        if (state.lines[state.index + i] !== ' ' + changeContent) {
            return false;
        }
    }
    state.index += delta;
    return true;
}
function calcOldNewLineCount(lines) {
    var oldLines = 0;
    var newLines = 0;
    lines.forEach(function(line) {
        if (typeof line !== 'string') {
            var myCount = calcOldNewLineCount(line.mine);
            var theirCount = calcOldNewLineCount(line.theirs);
            if (oldLines !== undefined) {
                if (myCount.oldLines === theirCount.oldLines) {
                    oldLines += myCount.oldLines;
                } else {
                    oldLines = undefined;
                }
            }
            if (newLines !== undefined) {
                if (myCount.newLines === theirCount.newLines) {
                    newLines += myCount.newLines;
                } else {
                    newLines = undefined;
                }
            }
        } else {
            if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
                newLines++;
            }
            if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
                oldLines++;
            }
        }
    });
    return {
        oldLines: oldLines,
        newLines: newLines
    };
}
function reversePatch(structuredPatch) {
    if (Array.isArray(structuredPatch)) {
        return structuredPatch.map(reversePatch).reverse();
    }
    return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {
        oldFileName: structuredPatch.newFileName,
        oldHeader: structuredPatch.newHeader,
        newFileName: structuredPatch.oldFileName,
        newHeader: structuredPatch.oldHeader,
        hunks: structuredPatch.hunks.map(function(hunk) {
            return {
                oldLines: hunk.newLines,
                oldStart: hunk.newStart,
                newLines: hunk.oldLines,
                newStart: hunk.oldStart,
                linedelimiters: hunk.linedelimiters,
                lines: hunk.lines.map(function(l) {
                    if (l.startsWith('-')) {
                        return "+".concat(l.slice(1));
                    }
                    if (l.startsWith('+')) {
                        return "-".concat(l.slice(1));
                    }
                    return l;
                })
            };
        })
    });
}
// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
    var ret = [], change, operation;
    for(var i = 0; i < changes.length; i++){
        change = changes[i];
        if (change.added) {
            operation = 1;
        } else if (change.removed) {
            operation = -1;
        } else {
            operation = 0;
        }
        ret.push([
            operation,
            change.value
        ]);
    }
    return ret;
}
function convertChangesToXML(changes) {
    var ret = [];
    for(var i = 0; i < changes.length; i++){
        var change = changes[i];
        if (change.added) {
            ret.push('<ins>');
        } else if (change.removed) {
            ret.push('<del>');
        }
        ret.push(escapeHTML(change.value));
        if (change.added) {
            ret.push('</ins>');
        } else if (change.removed) {
            ret.push('</del>');
        }
    }
    return ret.join('');
}
function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, '&amp;');
    n = n.replace(/</g, '&lt;');
    n = n.replace(/>/g, '&gt;');
    n = n.replace(/"/g, '&quot;');
    return n;
}
;
}),
"[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/diff/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "arrays": ()=>arrays,
    "chars": ()=>chars,
    "circular": ()=>circular,
    "compare": ()=>compare,
    "direct": ()=>direct,
    "lines": ()=>lines,
    "sort": ()=>sort,
    "stringify": ()=>stringify
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$diff$40$5$2e$2$2e$0$2f$node_modules$2f$diff$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/diff@5.2.0/node_modules/diff/lib/index.mjs [app-client] (ecmascript)");
;
;
const colors = {
    '--': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].red,
    '··': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].grey,
    '++': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].green
};
const TITLE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dim().italic;
const TAB = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dim('→'), SPACE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dim('·'), NL = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dim('↵');
const LOG = (sym, str)=>colors[sym](sym + PRETTY(str)) + '\n';
const LINE = (num, x)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dim('L' + String(num).padStart(x, '0') + ' ');
const PRETTY = (str)=>str.replace(/[ ]/g, SPACE).replace(/\t/g, TAB).replace(/(\r?\n)/g, NL);
function line(obj, prev, pad) {
    let char = obj.removed ? '--' : obj.added ? '++' : '··';
    let arr = obj.value.replace(/\r?\n$/, '').split('\n');
    let i = 0, tmp, out = '';
    if (obj.added) out += colors[char]().underline(TITLE('Expected:')) + '\n';
    else if (obj.removed) out += colors[char]().underline(TITLE('Actual:')) + '\n';
    for(; i < arr.length; i++){
        tmp = arr[i];
        if (tmp != null) {
            if (prev) out += LINE(prev + i, pad);
            out += LOG(char, tmp || '\n');
        }
    }
    return out;
}
function arrays(input, expect) {
    let arr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$diff$40$5$2e$2$2e$0$2f$node_modules$2f$diff$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["diffArrays"](input, expect);
    let i = 0, j = 0, k = 0, tmp, val, char, isObj, str;
    let out = LOG('··', '[');
    for(; i < arr.length; i++){
        char = (tmp = arr[i]).removed ? '--' : tmp.added ? '++' : '··';
        if (tmp.added) {
            out += colors[char]().underline(TITLE('Expected:')) + '\n';
        } else if (tmp.removed) {
            out += colors[char]().underline(TITLE('Actual:')) + '\n';
        }
        for(j = 0; j < tmp.value.length; j++){
            isObj = tmp.value[j] && typeof tmp.value[j] === 'object';
            val = stringify(tmp.value[j]).split(/\r?\n/g);
            for(k = 0; k < val.length;){
                str = '  ' + val[k++] + (isObj ? '' : ',');
                if (isObj && k === val.length && j + 1 < tmp.value.length) str += ',';
                out += LOG(char, str);
            }
        }
    }
    return out + LOG('··', ']');
}
function lines(input, expect) {
    let linenum = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let i = 0, tmp, output = '';
    let arr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$diff$40$5$2e$2$2e$0$2f$node_modules$2f$diff$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["diffLines"](input, expect);
    let pad = String(expect.split(/\r?\n/g).length - linenum).length;
    for(; i < arr.length; i++){
        output += line(tmp = arr[i], linenum, pad);
        if (linenum && !tmp.removed) linenum += tmp.count;
    }
    return output;
}
function chars(input, expect) {
    let arr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$diff$40$5$2e$2$2e$0$2f$node_modules$2f$diff$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["diffChars"](input, expect);
    let i = 0, output = '', tmp;
    let l1 = input.length;
    let l2 = expect.length;
    let p1 = PRETTY(input);
    let p2 = PRETTY(expect);
    tmp = arr[i];
    if (l1 === l2) {
    // no length offsets
    } else if (tmp.removed && arr[i + 1]) {
        let del = tmp.count - arr[i + 1].count;
        if (del == 0) {
        // wash~
        } else if (del > 0) {
            expect = ' '.repeat(del) + expect;
            p2 = ' '.repeat(del) + p2;
            l2 += del;
        } else if (del < 0) {
            input = ' '.repeat(-del) + input;
            p1 = ' '.repeat(-del) + p1;
            l1 += -del;
        }
    }
    output += direct(p1, p2, l1, l2);
    if (l1 === l2) {
        for(tmp = '  '; i < l1; i++){
            tmp += input[i] === expect[i] ? ' ' : '^';
        }
    } else {
        for(tmp = '  '; i < arr.length; i++){
            tmp += (arr[i].added || arr[i].removed ? '^' : ' ').repeat(Math.max(arr[i].count, 0));
            if (i + 1 < arr.length && (arr[i].added && arr[i + 1].removed || arr[i].removed && arr[i + 1].added)) {
                arr[i + 1].count -= arr[i].count;
            }
        }
    }
    return output + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].red(tmp);
}
function direct(input, expect) {
    let lenA = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : String(input).length, lenB = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : String(expect).length;
    let gutter = 4;
    let lenC = Math.max(lenA, lenB);
    let typeA = typeof input, typeB = typeof expect;
    if (typeA !== typeB) {
        gutter = 2;
        let delA = gutter + lenC - lenA;
        let delB = gutter + lenC - lenB;
        input += ' '.repeat(delA) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dim("[".concat(typeA, "]"));
        expect += ' '.repeat(delB) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$kleur$40$4$2e$1$2e$5$2f$node_modules$2f$kleur$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].dim("[".concat(typeB, "]"));
        lenA += delA + typeA.length + 2;
        lenB += delB + typeB.length + 2;
        lenC = Math.max(lenA, lenB);
    }
    let output = colors['++']('++' + expect + ' '.repeat(gutter + lenC - lenB) + TITLE('(Expected)')) + '\n';
    return output + colors['--']('--' + input + ' '.repeat(gutter + lenC - lenA) + TITLE('(Actual)')) + '\n';
}
function sort(input, expect) {
    var k, i = 0, tmp, isArr = Array.isArray(input);
    var keys = [], out = isArr ? Array(input.length) : {};
    if (isArr) {
        for(i = 0; i < out.length; i++){
            tmp = input[i];
            if (!tmp || typeof tmp !== 'object') out[i] = tmp;
            else out[i] = sort(tmp, expect[i]); // might not be right
        }
    } else {
        for(k in expect)keys.push(k);
        for(; i < keys.length; i++){
            if (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {
                if (!(tmp = input[k]) || typeof tmp !== 'object') out[k] = tmp;
                else out[k] = sort(tmp, expect[k]);
            }
        }
        for(k in input){
            if (!out.hasOwnProperty(k)) {
                out[k] = input[k]; // expect didnt have
            }
        }
    }
    return out;
}
function circular() {
    var cache = new Set;
    return function print(key, val) {
        if (val === void 0) return '[__VOID__]';
        if (typeof val === 'number' && val !== val) return '[__NAN__]';
        if (typeof val === 'bigint') return val.toString();
        if (!val || typeof val !== 'object') return val;
        if (cache.has(val)) return '[Circular]';
        cache.add(val);
        return val;
    };
}
function stringify(input) {
    return JSON.stringify(input, circular(), 2).replace(/"\[__NAN__\]"/g, 'NaN').replace(/"\[__VOID__\]"/g, 'undefined');
}
function compare(input, expect) {
    if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);
    if (expect instanceof RegExp) return chars('' + input, '' + expect);
    let isA = input && typeof input == 'object';
    let isB = expect && typeof expect == 'object';
    if (isA && isB) input = sort(input, expect);
    if (isB) expect = stringify(expect);
    if (isA) input = stringify(input);
    if (expect && typeof expect == 'object') {
        input = stringify(sort(input, expect));
        expect = stringify(expect);
    }
    isA = typeof input == 'string';
    isB = typeof expect == 'string';
    if (isA && /\r?\n/.test(input)) return lines(input, '' + expect);
    if (isB && /\r?\n/.test(expect)) return lines('' + input, expect);
    if (isA && isB) return chars(input, expect);
    return direct(input, expect);
}
}),
"[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Assertion": ()=>Assertion,
    "equal": ()=>equal,
    "fixture": ()=>fixture,
    "instance": ()=>instance,
    "is": ()=>is,
    "match": ()=>match,
    "not": ()=>not,
    "ok": ()=>ok,
    "snapshot": ()=>snapshot,
    "throws": ()=>throws,
    "type": ()=>type,
    "unreachable": ()=>unreachable
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$dequal$40$2$2e$0$2e$3$2f$node_modules$2f$dequal$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$diff$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/diff/index.mjs [app-client] (ecmascript)");
;
;
function dedent(str) {
    str = str.replace(/\r?\n/g, '\n');
    let arr = str.match(/^[ \t]*(?=\S)/gm);
    let i = 0, min = 1 / 0, len = (arr || []).length;
    for(; i < len; i++)min = Math.min(min, arr[i].length);
    return len && min ? str.replace(new RegExp("^[ \\t]{".concat(min, "}"), 'gm'), '') : str;
}
class Assertion extends Error {
    constructor(opts = {}){
        super(opts.message);
        this.name = 'Assertion';
        this.code = 'ERR_ASSERTION';
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
        this.details = opts.details || false;
        this.generated = !!opts.generated;
        this.operator = opts.operator;
        this.expects = opts.expects;
        this.actual = opts.actual;
    }
}
function assert(bool, actual, expects, operator, detailer, backup, msg) {
    if (bool) return;
    let message = msg || backup;
    if (msg instanceof Error) throw msg;
    let details = detailer && detailer(actual, expects);
    throw new Assertion({
        actual,
        expects,
        operator,
        message,
        details,
        generated: !msg
    });
}
function ok(val, msg) {
    assert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);
}
function is(val, exp, msg) {
    assert(val === exp, val, exp, 'is', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$diff$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compare"], 'Expected values to be strictly equal:', msg);
}
function equal(val, exp, msg) {
    assert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$dequal$40$2$2e$0$2e$3$2f$node_modules$2f$dequal$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dequal"])(val, exp), val, exp, 'equal', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$diff$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compare"], 'Expected values to be deeply equal:', msg);
}
function unreachable(msg) {
    assert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);
}
function type(val, exp, msg) {
    let tmp = typeof val;
    assert(tmp === exp, tmp, exp, 'type', false, 'Expected "'.concat(tmp, '" to be "').concat(exp, '"'), msg);
}
function instance(val, exp, msg) {
    let name = '`' + (exp.name || exp.constructor.name) + '`';
    assert(val instanceof exp, val, exp, 'instance', false, "Expected value to be an instance of ".concat(name), msg);
}
function match(val, exp, msg) {
    if (typeof exp === 'string') {
        assert(val.includes(exp), val, exp, 'match', false, 'Expected value to include "'.concat(exp, '" substring'), msg);
    } else {
        assert(exp.test(val), val, exp, 'match', false, "Expected value to match `".concat(String(exp), "` pattern"), msg);
    }
}
function snapshot(val, exp, msg) {
    val = dedent(val);
    exp = dedent(exp);
    assert(val === exp, val, exp, 'snapshot', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$diff$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lines"], 'Expected value to match snapshot:', msg);
}
const lineNums = (x, y)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$diff$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lines"])(x, y, 1);
function fixture(val, exp, msg) {
    val = dedent(val);
    exp = dedent(exp);
    assert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);
}
function throws(blk, exp, msg) {
    if (!msg && typeof exp === 'string') {
        msg = exp;
        exp = null;
    }
    try {
        blk();
        assert(false, false, true, 'throws', false, 'Expected function to throw', msg);
    } catch (err) {
        if (err instanceof Assertion) throw err;
        if (typeof exp === 'function') {
            assert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);
        } else if (exp instanceof RegExp) {
            assert(exp.test(err.message), false, true, 'throws', false, "Expected function to throw exception matching `".concat(String(exp), "` pattern"), msg);
        }
    }
}
function not(val, msg) {
    assert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);
}
not.ok = not;
is.not = function(val, exp, msg) {
    assert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);
};
not.equal = function(val, exp, msg) {
    assert(!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$dequal$40$2$2e$0$2e$3$2f$node_modules$2f$dequal$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dequal"])(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);
};
not.type = function(val, exp, msg) {
    let tmp = typeof val;
    assert(tmp !== exp, tmp, exp, 'not.type', false, 'Expected "'.concat(tmp, '" not to be "').concat(exp, '"'), msg);
};
not.instance = function(val, exp, msg) {
    let name = '`' + (exp.name || exp.constructor.name) + '`';
    assert(!(val instanceof exp), val, exp, 'not.instance', false, "Expected value not to be an instance of ".concat(name), msg);
};
not.snapshot = function(val, exp, msg) {
    val = dedent(val);
    exp = dedent(exp);
    assert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);
};
not.fixture = function(val, exp, msg) {
    val = dedent(val);
    exp = dedent(exp);
    assert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);
};
not.match = function(val, exp, msg) {
    if (typeof exp === 'string') {
        assert(!val.includes(exp), val, exp, 'not.match', false, 'Expected value not to include "'.concat(exp, '" substring'), msg);
    } else {
        assert(!exp.test(val), val, exp, 'not.match', false, "Expected value not to match `".concat(String(exp), "` pattern"), msg);
    }
};
not.throws = function(blk, exp, msg) {
    if (!msg && typeof exp === 'string') {
        msg = exp;
        exp = null;
    }
    try {
        blk();
    } catch (err) {
        if (typeof exp === 'function') {
            assert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);
        } else if (exp instanceof RegExp) {
            assert(!exp.test(err.message), true, false, 'not.throws', false, "Expected function not to throw exception matching `".concat(String(exp), "` pattern"), msg);
        } else if (!exp) {
            assert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);
        }
    }
};
}),
"[project]/node_modules/.pnpm/micromark-factory-space@1.1.0/node_modules/micromark-factory-space/dev/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */ __turbopack_context__.s({
    "factorySpace": ()=>factorySpace
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
;
function factorySpace(effects, ok, type, max) {
    const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
    let size = 0;
    return start;
    //TURBOPACK unreachable
    ;
    /** @type {State} */ function start(code) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code)) {
            effects.enter(type);
            return prefix(code);
        }
        return ok(code);
    }
    /** @type {State} */ function prefix(code) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code) && size++ < limit) {
            effects.consume(code);
            return prefix;
        }
        effects.exit(type);
        return ok(code);
    }
}
}),
"[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/types.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * This module is compiled away!
 *
 * Here is the list of all types of tokens exposed by micromark, with a short
 * explanation of what they include and where they are found.
 * In picking names, generally, the rule is to be as explicit as possible
 * instead of reusing names.
 * For example, there is a `definitionDestination` and a `resourceDestination`,
 * instead of one shared name.
 */ // Note: when changing the next record, you must also change `TokenTypeMap`
// in `micromark-util-types/index.d.ts`.
__turbopack_context__.s({
    "types": ()=>types
});
const types = {
    // Generic type for data, such as in a title, a destination, etc.
    data: 'data',
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: 'whitespace',
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: 'lineEnding',
    // A line ending, but ending a blank line.
    lineEndingBlank: 'lineEndingBlank',
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: 'linePrefix',
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: 'lineSuffix',
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: 'atxHeading',
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: 'atxHeadingSequence',
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: 'atxHeadingText',
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: 'autolink',
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: 'autolinkEmail',
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: 'autolinkMarker',
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: 'autolinkProtocol',
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: 'characterEscape',
    // The escaped character (`-`).
    characterEscapeValue: 'characterEscapeValue',
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: 'characterReference',
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: 'characterReferenceMarker',
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: 'characterReferenceMarkerNumeric',
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: 'characterReferenceMarkerHexadecimal',
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: 'characterReferenceValue',
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: 'codeFenced',
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: 'codeFencedFence',
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: 'codeFencedFenceSequence',
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: 'codeFencedFenceInfo',
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: 'codeFencedFenceMeta',
    // A line of code.
    codeFlowValue: 'codeFlowValue',
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: 'codeIndented',
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: 'codeText',
    codeTextData: 'codeTextData',
    // A space or line ending right after or before a tick.
    codeTextPadding: 'codeTextPadding',
    // A text code fence (` `` `).
    codeTextSequence: 'codeTextSequence',
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: 'content',
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: 'definition',
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: 'definitionDestination',
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: 'definitionDestinationLiteral',
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: 'definitionDestinationLiteralMarker',
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: 'definitionDestinationRaw',
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: 'definitionDestinationString',
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: 'definitionLabel',
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: 'definitionLabelMarker',
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: 'definitionLabelString',
    // Marker between a label and a destination (`:`).
    definitionMarker: 'definitionMarker',
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: 'definitionTitle',
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: 'definitionTitleMarker',
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: 'definitionTitleString',
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: 'emphasis',
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: 'emphasisSequence',
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: 'emphasisText',
    // The character escape marker (`\`).
    escapeMarker: 'escapeMarker',
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: 'hardBreakEscape',
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: 'hardBreakTrailing',
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: 'htmlFlow',
    htmlFlowData: 'htmlFlowData',
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: 'htmlText',
    htmlTextData: 'htmlTextData',
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: 'image',
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: 'label',
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: 'labelText',
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: 'labelLink',
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: 'labelImage',
    // Marker of a label (`[` or `]`).
    labelMarker: 'labelMarker',
    // Marker to start an image (`!`).
    labelImageMarker: 'labelImageMarker',
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: 'labelEnd',
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: 'link',
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: 'paragraph',
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: 'reference',
    // A reference marker (`[` or `]`).
    referenceMarker: 'referenceMarker',
    // Reference text (`alpha`).
    // Includes string.
    referenceString: 'referenceString',
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: 'resource',
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: 'resourceDestination',
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: 'resourceDestinationLiteral',
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: 'resourceDestinationLiteralMarker',
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: 'resourceDestinationRaw',
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: 'resourceDestinationString',
    // A resource marker (`(` or `)`).
    resourceMarker: 'resourceMarker',
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: 'resourceTitle',
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: 'resourceTitleMarker',
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: 'resourceTitleString',
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: 'setextHeading',
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: 'setextHeadingText',
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: 'setextHeadingLine',
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: 'setextHeadingLineSequence',
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: 'strong',
    // Sequence of strong markers (`**` or `__`).
    strongSequence: 'strongSequence',
    // Strong text (`alpha`).
    // Includes text.
    strongText: 'strongText',
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: 'thematicBreak',
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: 'thematicBreakSequence',
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: 'blockQuote',
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: 'blockQuotePrefix',
    // The `>` of a block quote prefix.
    blockQuoteMarker: 'blockQuoteMarker',
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: 'blockQuotePrefixWhitespace',
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: 'listOrdered',
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: 'listUnordered',
    // The indent of further list item lines.
    listItemIndent: 'listItemIndent',
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: 'listItemMarker',
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: 'listItemPrefix',
    // The whitespace after a marker.
    listItemPrefixWhitespace: 'listItemPrefixWhitespace',
    // The numerical value of an ordered item.
    listItemValue: 'listItemValue',
    // Internal types used for subtokenizers, compiled away
    chunkDocument: 'chunkDocument',
    chunkContent: 'chunkContent',
    chunkFlow: 'chunkFlow',
    chunkText: 'chunkText',
    chunkString: 'chunkString'
};
}),
"[project]/node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/dev/lib/blank-line.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ __turbopack_context__.s({
    "blankLine": ()=>blankLine
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-factory-space@1.1.0/node_modules/micromark-factory-space/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/types.js [app-client] (ecmascript)");
;
;
;
;
const blankLine = {
    tokenize: tokenizeBlankLine,
    partial: true
};
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeBlankLine(effects, ok, nok) {
    return start;
    //TURBOPACK unreachable
    ;
    /**
   * Start of blank line.
   *
   * > 👉 **Note**: `␠` represents a space character.
   *
   * ```markdown
   * > | ␠␠␊
   *     ^
   * > | ␊
   *     ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, after, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].linePrefix)(code) : after(code);
    }
    /**
   * At eof/eol, after optional whitespace.
   *
   * > 👉 **Note**: `␠` represents a space character.
   *
   * ```markdown
   * > | ␠␠␊
   *       ^
   * > | ␊
   *     ^
   * ```
   *
   * @type {State}
   */ function after(code) {
        return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEnding"])(code) ? ok(code) : nok(code);
    }
}
}),
"[project]/node_modules/.pnpm/micromark-util-normalize-identifier@1.1.0/node_modules/micromark-util-normalize-identifier/dev/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "normalizeIdentifier": ()=>normalizeIdentifier
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/values.js [app-client] (ecmascript)");
;
function normalizeIdentifier(value) {
    return value// Collapse markdown whitespace.
    .replace(/[\t\n\r ]+/g, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["values"].space)// Trim.
    .replace(/^ | $/g, '')// Some characters are considered “uppercase”, but if their lowercase
    // counterpart is uppercased will result in a different uppercase
    // character.
    // Hence, to get that form, we perform both lower- and uppercase.
    // Upper case makes sure keys will not interact with default prototypal
    // methods: no method is uppercase.
    .toLowerCase().toUpperCase();
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-footnote@1.1.2/node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ __turbopack_context__.s({
    "gfmFootnote": ()=>gfmFootnote
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$core$2d$commonmark$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$core$2d$commonmark$2f$dev$2f$lib$2f$blank$2d$line$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/dev/lib/blank-line.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-factory-space@1.1.0/node_modules/micromark-factory-space/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-normalize-identifier@1.1.0/node_modules/micromark-util-normalize-identifier/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/types.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const indent = {
    tokenize: tokenizeIndent,
    partial: true
};
function gfmFootnote() {
    /** @type {Extension} */ return {
        document: {
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket]: {
                tokenize: tokenizeDefinitionStart,
                continuation: {
                    tokenize: tokenizeDefinitionContinuation
                },
                exit: gfmFootnoteDefinitionEnd
            }
        },
        text: {
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket]: {
                tokenize: tokenizeGfmFootnoteCall
            },
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket]: {
                add: 'after',
                tokenize: tokenizePotentialGfmFootnoteCall,
                resolveTo: resolveToPotentialGfmFootnoteCall
            }
        }
    };
}
// To do: remove after micromark update.
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizePotentialGfmFootnoteCall(effects, ok, nok) {
    const self = this;
    let index = self.events.length;
    /** @type {Array<string>} */ // @ts-expect-error It’s fine!
    const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
    /** @type {Token} */ let labelStart;
    // Find an opening.
    while(index--){
        const token = self.events[index][1];
        if (token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].labelImage) {
            labelStart = token;
            break;
        }
        // Exit if we’ve walked far enough.
        if (token.type === 'gfmFootnoteCall' || token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].labelLink || token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].label || token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].image || token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].link) {
            break;
        }
    }
    return start;
    //TURBOPACK unreachable
    ;
    /**
   * @type {State}
   */ function start(code) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket, 'expected `]`');
        if (!labelStart || !labelStart._balanced) {
            return nok(code);
        }
        const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeIdentifier"])(self.sliceSerialize({
            start: labelStart.end,
            end: self.now()
        }));
        if (id.codePointAt(0) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].caret || !defined.includes(id.slice(1))) {
            return nok(code);
        }
        effects.enter('gfmFootnoteCallLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallLabelMarker');
        return ok(code);
    }
}
// To do: remove after micromark update.
/** @type {Resolver} */ function resolveToPotentialGfmFootnoteCall(events, context) {
    let index = events.length;
    /** @type {Token | undefined} */ let labelStart;
    // Find an opening.
    while(index--){
        if (events[index][1].type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].labelImage && events[index][0] === 'enter') {
            labelStart = events[index][1];
            break;
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(labelStart, 'expected `labelStart` to resolve');
    // Change the `labelImageMarker` to a `data`.
    events[index + 1][1].type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].data;
    events[index + 3][1].type = 'gfmFootnoteCallLabelMarker';
    // The whole (without `!`):
    /** @type {Token} */ const call = {
        type: 'gfmFootnoteCall',
        start: Object.assign({}, events[index + 3][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
    };
    // The `^` marker
    /** @type {Token} */ const marker = {
        type: 'gfmFootnoteCallMarker',
        start: Object.assign({}, events[index + 3][1].end),
        end: Object.assign({}, events[index + 3][1].end)
    };
    // Increment the end 1 character.
    marker.end.column++;
    marker.end.offset++;
    marker.end._bufferIndex++;
    /** @type {Token} */ const string = {
        type: 'gfmFootnoteCallString',
        start: Object.assign({}, marker.end),
        end: Object.assign({}, events[events.length - 1][1].start)
    };
    /** @type {Token} */ const chunk = {
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].chunkString,
        contentType: 'string',
        start: Object.assign({}, string.start),
        end: Object.assign({}, string.end)
    };
    /** @type {Array<Event>} */ const replacement = [
        // Take the `labelImageMarker` (now `data`, the `!`)
        events[index + 1],
        events[index + 2],
        [
            'enter',
            call,
            context
        ],
        // The `[`
        events[index + 3],
        events[index + 4],
        // The `^`.
        [
            'enter',
            marker,
            context
        ],
        [
            'exit',
            marker,
            context
        ],
        // Everything in between.
        [
            'enter',
            string,
            context
        ],
        [
            'enter',
            chunk,
            context
        ],
        [
            'exit',
            chunk,
            context
        ],
        [
            'exit',
            string,
            context
        ],
        // The ending (`]`, properly parsed and labelled).
        events[events.length - 2],
        events[events.length - 1],
        [
            'exit',
            call,
            context
        ]
    ];
    events.splice(index, events.length - index + 1, ...replacement);
    return events;
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeGfmFootnoteCall(effects, ok, nok) {
    const self = this;
    /** @type {Array<string>} */ // @ts-expect-error It’s fine!
    const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
    let size = 0;
    /** @type {boolean} */ let data;
    // Note: the implementation of `markdown-rs` is different, because it houses
    // core *and* extensions in one project.
    // Therefore, it can include footnote logic inside `label-end`.
    // We can’t do that, but luckily, we can parse footnotes in a simpler way than
    // needed for labels.
    return start;
    //TURBOPACK unreachable
    ;
    /**
   * Start of footnote label.
   *
   * ```markdown
   * > | a [^b] c
   *       ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket, 'expected `[`');
        effects.enter('gfmFootnoteCall');
        effects.enter('gfmFootnoteCallLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallLabelMarker');
        return callStart;
    }
    /**
   * After `[`, at `^`.
   *
   * ```markdown
   * > | a [^b] c
   *        ^
   * ```
   *
   * @type {State}
   */ function callStart(code) {
        if (code !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].caret) return nok(code);
        effects.enter('gfmFootnoteCallMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallMarker');
        effects.enter('gfmFootnoteCallString');
        effects.enter('chunkString').contentType = 'string';
        return callData;
    }
    /**
   * In label.
   *
   * ```markdown
   * > | a [^b] c
   *         ^
   * ```
   *
   * @type {State}
   */ function callData(code) {
        if (// Too long.
        size > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].linkReferenceSizeMax || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code)) {
            return nok(code);
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket) {
            effects.exit('chunkString');
            const token = effects.exit('gfmFootnoteCallString');
            if (!defined.includes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeIdentifier"])(self.sliceSerialize(token)))) {
                return nok(code);
            }
            effects.enter('gfmFootnoteCallLabelMarker');
            effects.consume(code);
            effects.exit('gfmFootnoteCallLabelMarker');
            effects.exit('gfmFootnoteCall');
            return ok;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code)) {
            data = true;
        }
        size++;
        effects.consume(code);
        return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].backslash ? callEscape : callData;
    }
    /**
   * On character after escape.
   *
   * ```markdown
   * > | a [^b\c] d
   *           ^
   * ```
   *
   * @type {State}
   */ function callEscape(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].backslash || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket) {
            effects.consume(code);
            size++;
            return callData;
        }
        return callData(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeDefinitionStart(effects, ok, nok) {
    const self = this;
    /** @type {Array<string>} */ // @ts-expect-error It’s fine!
    const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
    /** @type {string} */ let identifier;
    let size = 0;
    /** @type {boolean | undefined} */ let data;
    return start;
    //TURBOPACK unreachable
    ;
    /**
   * Start of GFM footnote definition.
   *
   * ```markdown
   * > | [^a]: b
   *     ^
   * ```
   *
   * @type {State}
   */ function start(code) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket, 'expected `[`');
        effects.enter('gfmFootnoteDefinition')._container = true;
        effects.enter('gfmFootnoteDefinitionLabel');
        effects.enter('gfmFootnoteDefinitionLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteDefinitionLabelMarker');
        return labelAtMarker;
    }
    /**
   * In label, at caret.
   *
   * ```markdown
   * > | [^a]: b
   *      ^
   * ```
   *
   * @type {State}
   */ function labelAtMarker(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].caret) {
            effects.enter('gfmFootnoteDefinitionMarker');
            effects.consume(code);
            effects.exit('gfmFootnoteDefinitionMarker');
            effects.enter('gfmFootnoteDefinitionLabelString');
            effects.enter('chunkString').contentType = 'string';
            return labelInside;
        }
        return nok(code);
    }
    /**
   * In label.
   *
   * > 👉 **Note**: `cmark-gfm` prevents whitespace from occurring in footnote
   * > definition labels.
   *
   * ```markdown
   * > | [^a]: b
   *       ^
   * ```
   *
   * @type {State}
   */ function labelInside(code) {
        if (// Too long.
        size > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].linkReferenceSizeMax || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code)) {
            return nok(code);
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket) {
            effects.exit('chunkString');
            const token = effects.exit('gfmFootnoteDefinitionLabelString');
            identifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeIdentifier"])(self.sliceSerialize(token));
            effects.enter('gfmFootnoteDefinitionLabelMarker');
            effects.consume(code);
            effects.exit('gfmFootnoteDefinitionLabelMarker');
            effects.exit('gfmFootnoteDefinitionLabel');
            return labelAfter;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code)) {
            data = true;
        }
        size++;
        effects.consume(code);
        return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].backslash ? labelEscape : labelInside;
    }
    /**
   * After `\`, at a special character.
   *
   * > 👉 **Note**: `cmark-gfm` currently does not support escaped brackets:
   * > <https://github.com/github/cmark-gfm/issues/240>
   *
   * ```markdown
   * > | [^a\*b]: c
   *         ^
   * ```
   *
   * @type {State}
   */ function labelEscape(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].backslash || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket) {
            effects.consume(code);
            size++;
            return labelInside;
        }
        return labelInside(code);
    }
    /**
   * After definition label.
   *
   * ```markdown
   * > | [^a]: b
   *         ^
   * ```
   *
   * @type {State}
   */ function labelAfter(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].colon) {
            effects.enter('definitionMarker');
            effects.consume(code);
            effects.exit('definitionMarker');
            if (!defined.includes(identifier)) {
                defined.push(identifier);
            }
            // Any whitespace after the marker is eaten, forming indented code
            // is not possible.
            // No space is also fine, just like a block quote marker.
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, whitespaceAfter, 'gfmFootnoteDefinitionWhitespace');
        }
        return nok(code);
    }
    /**
   * After definition prefix.
   *
   * ```markdown
   * > | [^a]: b
   *           ^
   * ```
   *
   * @type {State}
   */ function whitespaceAfter(code) {
        // `markdown-rs` has a wrapping token for the prefix that is closed here.
        return ok(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeDefinitionContinuation(effects, ok, nok) {
    /// Start of footnote definition continuation.
    ///
    /// ```markdown
    ///   | [^a]: b
    /// > |     c
    ///     ^
    /// ```
    //
    // Either a blank line, which is okay, or an indented thing.
    return effects.check(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$core$2d$commonmark$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$core$2d$commonmark$2f$dev$2f$lib$2f$blank$2d$line$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blankLine"], ok, effects.attempt(indent, ok, nok));
}
/** @type {Exiter} */ function gfmFootnoteDefinitionEnd(effects) {
    effects.exit('gfmFootnoteDefinition');
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeIndent(effects, ok, nok) {
    const self = this;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].tabSize + 1);
    //TURBOPACK unreachable
    ;
    /**
   * @type {State}
   */ function afterPrefix(code) {
        const tail = self.events[self.events.length - 1];
        return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].tabSize ? ok(code) : nok(code);
    }
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-footnote@1.1.2/node_modules/micromark-extension-gfm-footnote/dev/lib/html.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 */ /**
 * @callback BackLabelTemplate
 *   Generate a back label dynamically.
 *
 *   For the following markdown:
 *
 *   ```markdown
 *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].
 *
 *   [^remark]: things about remark
 *   [^micromark]: things about micromark
 *   ```
 *
 *   This function will be called with:
 *
 *   * `0` and `0` for the backreference from `things about micromark` to
 *      `alpha`, as it is the first used definition, and the first call to it
 *   * `0` and `1` for the backreference from `things about micromark` to
 *      `bravo`, as it is the first used definition, and the second call to it
 *   * `1` and `0` for the backreference from `things about remark` to
 *      `charlie`, as it is the second used definition
 * @param {number} referenceIndex
 *   Index of the definition in the order that they are first referenced,
 *   0-indexed.
 * @param {number} rereferenceIndex
 *   Index of calls to the same definition, 0-indexed.
 * @returns {string}
 *   Back label to use when linking back from definitions to their reference.
 */ /**
 * @typedef Options
 *   Configuration.
 * @property {string} [clobberPrefix='user-content-']
 *   Prefix to use before the `id` attribute on footnotes to prevent them from
 *   *clobbering*.
 *
 *   The default is `'user-content-'`.
 *   Pass `''` for trusted markdown and when you are careful with
 *   polyfilling.
 *   You could pass a different prefix.
 *
 *   DOM clobbering is this:
 *
 *   ```html
 *   <p id="x"></p>
 *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>
 *   ```
 *
 *   The above example shows that elements are made available by browsers, by
 *   their ID, on the `window` object.
 *   This is a security risk because you might be expecting some other variable
 *   at that place.
 *   It can also break polyfills.
 *   Using a prefix solves these problems.
 * @property {string} [label='Footnotes']
 *   Textual label to use for the footnotes section.
 *
 *   The default value is `'Footnotes'`.
 *   Change it when the markdown is not in English.
 *
 *   This label is typically hidden visually (assuming a `sr-only` CSS class
 *   is defined that does that) and so affects screen readers only.
 *   If you do have such a class, but want to show this section to everyone,
 *   pass different attributes with the `labelAttributes` option.
 * @property {string} [labelAttributes='class="sr-only"']
 *   Attributes to use on the footnote label.
 *
 *   Change it to show the label and add other attributes.
 *
 *   This label is typically hidden visually (assuming an `sr-only` CSS class
 *   is defined that does that) and so affects screen readers only.
 *   If you do have such a class, but want to show this section to everyone,
 *   pass an empty string.
 *   You can also add different attributes.
 *
 *   > 👉 **Note**: `id="footnote-label"` is always added, because footnote
 *   > calls use it with `aria-describedby` to provide an accessible label.
 * @property {string} [labelTagName='h2']
 *   HTML tag name to use for the footnote label element.
 *
 *   Change it to match your document structure.
 *
 *   This label is typically hidden visually (assuming a `sr-only` CSS class
 *   is defined that does that) and so affects screen readers only.
 *   If you do have such a class, but want to show this section to everyone,
 *   pass different attributes with the `labelAttributes` option.
 * @property {BackLabelTemplate | string} [backLabel]
 *   Textual label to describe the backreference back to references.
 *
 *   The default value is:
 *
 *   ```js
 *   function defaultBackLabel(referenceIndex, rereferenceIndex) {
 *    return (
 *      'Back to reference ' +
 *      (referenceIndex + 1) +
 *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')
 *    )
 *  }
 *   ```
 *
 *   Change it when the markdown is not in English.
 *
 *   This label is used in the `aria-label` attribute on each backreference
 *   (the `↩` links).
 *   It affects users of assistive technology.
 */ __turbopack_context__.s({
    "defaultBackLabel": ()=>defaultBackLabel,
    "gfmFootnoteHtml": ()=>gfmFootnoteHtml
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-normalize-identifier@1.1.0/node_modules/micromark-util-normalize-identifier/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$sanitize$2d$uri$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$sanitize$2d$uri$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-sanitize-uri@1.2.0/node_modules/micromark-util-sanitize-uri/dev/index.js [app-client] (ecmascript)");
;
;
;
const own = {}.hasOwnProperty;
/** @type {Options} */ const emptyOptions = {};
function defaultBackLabel(referenceIndex, rereferenceIndex) {
    return 'Back to reference ' + (referenceIndex + 1) + (rereferenceIndex > 1 ? '-' + rereferenceIndex : '');
}
function gfmFootnoteHtml(options) {
    const config = options || emptyOptions;
    const label = config.label || 'Footnotes';
    const labelTagName = config.labelTagName || 'h2';
    const labelAttributes = config.labelAttributes === null || config.labelAttributes === undefined ? 'class="sr-only"' : config.labelAttributes;
    const backLabel = config.backLabel || defaultBackLabel;
    const clobberPrefix = config.clobberPrefix === null || config.clobberPrefix === undefined ? 'user-content-' : config.clobberPrefix;
    return {
        enter: {
            gfmFootnoteDefinition () {
                const stack = this.getData('tightStack');
                stack.push(false);
            },
            gfmFootnoteDefinitionLabelString () {
                this.buffer();
            },
            gfmFootnoteCallString () {
                this.buffer();
            }
        },
        exit: {
            gfmFootnoteDefinition () {
                let definitions = this.getData('gfmFootnoteDefinitions');
                const footnoteStack = this.getData('gfmFootnoteDefinitionStack');
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(footnoteStack, 'expected `footnoteStack`');
                const tightStack = this.getData('tightStack');
                const current = footnoteStack.pop();
                const value = this.resume();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(current, 'expected to be in a footnote');
                if (!definitions) {
                    this.setData('gfmFootnoteDefinitions', definitions = {});
                }
                if (!own.call(definitions, current)) definitions[current] = value;
                tightStack.pop();
                this.setData('slurpOneLineEnding', true);
                // “Hack” to prevent a line ending from showing up if we’re in a definition in
                // an empty list item.
                this.setData('lastWasTag');
            },
            gfmFootnoteDefinitionLabelString (token) {
                let footnoteStack = this.getData('gfmFootnoteDefinitionStack');
                if (!footnoteStack) {
                    this.setData('gfmFootnoteDefinitionStack', footnoteStack = []);
                }
                footnoteStack.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeIdentifier"])(this.sliceSerialize(token)));
                this.resume(); // Drop the label.
                this.buffer(); // Get ready for a value.
            },
            gfmFootnoteCallString (token) {
                let calls = this.getData('gfmFootnoteCallOrder');
                let counts = this.getData('gfmFootnoteCallCounts');
                const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeIdentifier"])(this.sliceSerialize(token));
                /** @type {number} */ let counter;
                this.resume();
                if (!calls) this.setData('gfmFootnoteCallOrder', calls = []);
                if (!counts) this.setData('gfmFootnoteCallCounts', counts = {});
                const index = calls.indexOf(id);
                const safeId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$sanitize$2d$uri$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$sanitize$2d$uri$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sanitizeUri"])(id.toLowerCase());
                if (index === -1) {
                    calls.push(id);
                    counts[id] = 1;
                    counter = calls.length;
                } else {
                    counts[id]++;
                    counter = index + 1;
                }
                const reuseCounter = counts[id];
                this.tag('<sup><a href="#' + clobberPrefix + 'fn-' + safeId + '" id="' + clobberPrefix + 'fnref-' + safeId + (reuseCounter > 1 ? '-' + reuseCounter : '') + '" data-footnote-ref="" aria-describedby="footnote-label">' + String(counter) + '</a></sup>');
            },
            null () {
                const calls = this.getData('gfmFootnoteCallOrder') || [];
                const counts = this.getData('gfmFootnoteCallCounts') || {};
                const definitions = this.getData('gfmFootnoteDefinitions') || {};
                let index = -1;
                if (calls.length > 0) {
                    this.lineEndingIfNeeded();
                    this.tag('<section data-footnotes="" class="footnotes"><' + labelTagName + ' id="footnote-label"' + (labelAttributes ? ' ' + labelAttributes : '') + '>');
                    this.raw(this.encode(label));
                    this.tag('</' + labelTagName + '>');
                    this.lineEndingIfNeeded();
                    this.tag('<ol>');
                }
                while(++index < calls.length){
                    // Called definitions are always defined.
                    const id = calls[index];
                    const safeId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$sanitize$2d$uri$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$sanitize$2d$uri$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sanitizeUri"])(id.toLowerCase());
                    let referenceIndex = 0;
                    /** @type {Array<string>} */ const references = [];
                    while(++referenceIndex <= counts[id]){
                        references.push('<a href="#' + clobberPrefix + 'fnref-' + safeId + (referenceIndex > 1 ? '-' + referenceIndex : '') + '" data-footnote-backref="" aria-label="' + this.encode(typeof backLabel === 'string' ? backLabel : backLabel(index, referenceIndex)) + '" class="data-footnote-backref">↩' + (referenceIndex > 1 ? '<sup>' + referenceIndex + '</sup>' : '') + '</a>');
                    }
                    const reference = references.join(' ');
                    let injected = false;
                    this.lineEndingIfNeeded();
                    this.tag('<li id="' + clobberPrefix + 'fn-' + safeId + '">');
                    this.lineEndingIfNeeded();
                    this.tag(definitions[id].replace(/<\/p>(?:\r?\n|\r)?$/, (/** @type {string} */ $0)=>{
                        injected = true;
                        return ' ' + reference + $0;
                    }));
                    if (!injected) {
                        this.lineEndingIfNeeded();
                        this.tag(reference);
                    }
                    this.lineEndingIfNeeded();
                    this.tag('</li>');
                }
                if (calls.length > 0) {
                    this.lineEndingIfNeeded();
                    this.tag('</ol>');
                    this.lineEndingIfNeeded();
                    this.tag('</section>');
                }
            }
        }
    };
}
}),
"[project]/node_modules/.pnpm/micromark-util-classify-character@1.1.0/node_modules/micromark-util-classify-character/dev/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Code} Code
 */ __turbopack_context__.s({
    "classifyCharacter": ()=>classifyCharacter
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/constants.js [app-client] (ecmascript)");
;
;
;
function classifyCharacter(code) {
    if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodeWhitespace"])(code)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].characterGroupWhitespace;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodePunctuation"])(code)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].characterGroupPunctuation;
    }
}
}),
"[project]/node_modules/.pnpm/micromark-util-resolve-all@1.1.0/node_modules/micromark-util-resolve-all/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */ /**
 * Call all `resolveAll`s.
 *
 * @param {Array<{resolveAll?: Resolver | undefined}>} constructs
 *   List of constructs, optionally with `resolveAll`s.
 * @param {Array<Event>} events
 *   List of events.
 * @param {TokenizeContext} context
 *   Context used by `tokenize`.
 * @returns {Array<Event>}
 *   Changed events.
 */ __turbopack_context__.s({
    "resolveAll": ()=>resolveAll
});
function resolveAll(constructs, events, context) {
    /** @type {Array<Resolver>} */ const called = [];
    let index = -1;
    while(++index < constructs.length){
        const resolve = constructs[index].resolveAll;
        if (resolve && !called.includes(resolve)) {
            events = resolve(events, context);
            called.push(resolve);
        }
    }
    return events;
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 *
 * @typedef Options
 *   Configuration (optional).
 * @property {boolean} [singleTilde=true]
 *   Whether to support strikethrough with a single tilde.
 *
 *   Single tildes work on github.com, but are technically prohibited by the
 *   GFM spec.
 */ __turbopack_context__.s({
    "gfmStrikethrough": ()=>gfmStrikethrough
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$chunked$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$chunked$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-chunked@1.1.0/node_modules/micromark-util-chunked/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$classify$2d$character$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$classify$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-classify-character@1.1.0/node_modules/micromark-util-classify-character/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$resolve$2d$all$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$resolve$2d$all$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-resolve-all@1.1.0/node_modules/micromark-util-resolve-all/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/types.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
function gfmStrikethrough(options) {
    const options_ = options || {};
    let single = options_.singleTilde;
    const tokenizer = {
        tokenize: tokenizeStrikethrough,
        resolveAll: resolveAllStrikethrough
    };
    if (single === null || single === undefined) {
        single = true;
    }
    return {
        text: {
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde]: tokenizer
        },
        insideSpan: {
            null: [
                tokenizer
            ]
        },
        attentionMarkers: {
            null: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde
            ]
        }
    };
    //TURBOPACK unreachable
    ;
    /**
   * Take events and resolve strikethrough.
   *
   * @type {Resolver}
   */ function resolveAllStrikethrough(events, context) {
        let index = -1;
        // Walk through all events.
        while(++index < events.length){
            // Find a token that can close.
            if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {
                let open = index;
                // Now walk back to find an opener.
                while(open--){
                    // Find a token that can open the closer.
                    if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open && // If the sizes are the same:
                    events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
                        events[index][1].type = 'strikethroughSequence';
                        events[open][1].type = 'strikethroughSequence';
                        /** @type {Token} */ const strikethrough = {
                            type: 'strikethrough',
                            start: Object.assign({}, events[open][1].start),
                            end: Object.assign({}, events[index][1].end)
                        };
                        /** @type {Token} */ const text = {
                            type: 'strikethroughText',
                            start: Object.assign({}, events[open][1].end),
                            end: Object.assign({}, events[index][1].start)
                        };
                        // Opening.
                        /** @type {Array<Event>} */ const nextEvents = [
                            [
                                'enter',
                                strikethrough,
                                context
                            ],
                            [
                                'enter',
                                events[open][1],
                                context
                            ],
                            [
                                'exit',
                                events[open][1],
                                context
                            ],
                            [
                                'enter',
                                text,
                                context
                            ]
                        ];
                        const insideSpan = context.parser.constructs.insideSpan.null;
                        if (insideSpan) {
                            // Between.
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$chunked$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$chunked$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splice"])(nextEvents, nextEvents.length, 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$resolve$2d$all$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$resolve$2d$all$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveAll"])(insideSpan, events.slice(open + 1, index), context));
                        }
                        // Closing.
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$chunked$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$chunked$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splice"])(nextEvents, nextEvents.length, 0, [
                            [
                                'exit',
                                text,
                                context
                            ],
                            [
                                'enter',
                                events[index][1],
                                context
                            ],
                            [
                                'exit',
                                events[index][1],
                                context
                            ],
                            [
                                'exit',
                                strikethrough,
                                context
                            ]
                        ]);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$chunked$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$chunked$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splice"])(events, open - 1, index - open + 3, nextEvents);
                        index = open + nextEvents.length - 2;
                        break;
                    }
                }
            }
        }
        index = -1;
        while(++index < events.length){
            if (events[index][1].type === 'strikethroughSequenceTemporary') {
                events[index][1].type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].data;
            }
        }
        return events;
    }
    /**
   * @this {TokenizeContext}
   * @type {Tokenizer}
   */ function tokenizeStrikethrough(effects, ok, nok) {
        const previous = this.previous;
        const events = this.events;
        let size = 0;
        return start;
        //TURBOPACK unreachable
        ;
        /** @type {State} */ function start(code) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde, 'expected `~`');
            if (previous === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde && events[events.length - 1][1].type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].characterEscape) {
                return nok(code);
            }
            effects.enter('strikethroughSequenceTemporary');
            return more(code);
        }
        /** @type {State} */ function more(code) {
            const before = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$classify$2d$character$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$classify$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["classifyCharacter"])(previous);
            if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde) {
                // If this is the third marker, exit.
                if (size > 1) return nok(code);
                effects.consume(code);
                size++;
                return more;
            }
            if (size < 2 && !single) return nok(code);
            const token = effects.exit('strikethroughSequenceTemporary');
            const after = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$classify$2d$character$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$classify$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["classifyCharacter"])(code);
            token._open = !after || after === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].attentionSideAfter && Boolean(before);
            token._close = !before || before === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].attentionSideAfter && Boolean(after);
            return ok(code);
        }
    }
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/dev/lib/html.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 */ // To do: next major: expose function instead of object.
/**
 * Extension for `micromark` that can be passed in `htmlExtensions`, to
 * support GFM strikethrough when serializing to HTML.
 *
 * @type {HtmlExtension}
 */ __turbopack_context__.s({
    "gfmStrikethroughHtml": ()=>gfmStrikethroughHtml
});
const gfmStrikethroughHtml = {
    enter: {
        strikethrough () {
            this.tag('<del>');
        }
    },
    exit: {
        strikethrough () {
            this.tag('</del>');
        }
    }
};
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Event} Event
 */ // Port of `edit_map.rs` from `markdown-rs`.
// This should move to `markdown-js` later.
// Deal with several changes in events, batching them together.
//
// Preferably, changes should be kept to a minimum.
// Sometimes, it’s needed to change the list of events, because parsing can be
// messy, and it helps to expose a cleaner interface of events to the compiler
// and other users.
// It can also help to merge many adjacent similar events.
// And, in other cases, it’s needed to parse subcontent: pass some events
// through another tokenizer and inject the result.
/**
 * @typedef {[number, number, Array<Event>]} Change
 * @typedef {[number, number, number]} Jump
 */ /**
 * Tracks a bunch of edits.
 */ __turbopack_context__.s({
    "EditMap": ()=>EditMap
});
class EditMap {
    /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {void}
   */ add(index, remove, add) {
        addImpl(this, index, remove, add);
    }
    // To do: not used here.
    // /**
    //  * Create an edit: but insert `add` before existing additions.
    //  *
    //  * @param {number} index
    //  * @param {number} remove
    //  * @param {Array<Event>} add
    //  * @returns {void}
    //  */
    // addBefore(index, remove, add) {
    //   addImpl(this, index, remove, add, true)
    // }
    /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {void}
   */ consume(events) {
        this.map.sort((a, b)=>a[0] - b[0]);
        /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */ if (this.map.length === 0) {
            return;
        }
        // To do: if links are added in events, like they are in `markdown-rs`,
        // this is needed.
        // // Calculate jumps: where items in the current list move to.
        // /** @type {Array<Jump>} */
        // const jumps = []
        // let index = 0
        // let addAcc = 0
        // let removeAcc = 0
        // while (index < this.map.length) {
        //   const [at, remove, add] = this.map[index]
        //   removeAcc += remove
        //   addAcc += add.length
        //   jumps.push([at, removeAcc, addAcc])
        //   index += 1
        // }
        //
        // . shiftLinks(events, jumps)
        let index = this.map.length;
        /** @type {Array<Array<Event>>} */ const vecs = [];
        while(index > 0){
            index -= 1;
            vecs.push(events.slice(this.map[index][0] + this.map[index][1]));
            // eslint-disable-next-line unicorn/no-array-push-push
            vecs.push(this.map[index][2]);
            // Truncate rest.
            events.length = this.map[index][0];
        }
        vecs.push([
            ...events
        ]);
        events.length = 0;
        let slice = vecs.pop();
        while(slice){
            events.push(...slice);
            slice = vecs.pop();
        }
        // Truncate everything.
        this.map.length = 0;
    }
    /**
   * Create a new edit map.
   */ constructor(){
        /**
     * Record of changes.
     *
     * @type {Array<Change>}
     */ this.map = [];
    }
}
/**
 * Create an edit.
 *
 * @param {EditMap} editMap
 * @param {number} at
 * @param {number} remove
 * @param {Array<Event>} add
 * @returns {void}
 */ function addImpl(editMap, at, remove, add) {
    let index = 0;
    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */ if (remove === 0 && add.length === 0) {
        return;
    }
    while(index < editMap.map.length){
        if (editMap.map[index][0] === at) {
            editMap.map[index][1] += remove;
            // To do: before not used.
            // if (before) {
            //   add.push(...editMap.map[index][2])
            //   editMap.map[index][2] = add
            // } else {
            editMap.map[index][2].push(...add);
            // }
            return;
        }
        index += 1;
    }
    editMap.map.push([
        at,
        remove,
        add
    ]);
} // /**
 //  * Shift `previous` and `next` links according to `jumps`.
 //  *
 //  * This fixes links in case there are events removed or added between them.
 //  *
 //  * @param {Array<Event>} events
 //  * @param {Array<Jump>} jumps
 //  */
 // function shiftLinks(events, jumps) {
 //   let jumpIndex = 0
 //   let index = 0
 //   let add = 0
 //   let rm = 0
 //   while (index < events.length) {
 //     const rmCurr = rm
 //     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {
 //       add = jumps[jumpIndex][2]
 //       rm = jumps[jumpIndex][1]
 //       jumpIndex += 1
 //     }
 //     // Ignore items that will be removed.
 //     if (rm > rmCurr) {
 //       index += rm - rmCurr
 //     } else {
 //       console.log('to do: links?', add, rmCurr)
 //       // ?
 //       // if let Some(link) = &events[index].link {
 //       //     if let Some(next) = link.next {
 //       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);
 //       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {
 //       //             add = jumps[jumpIndex].2;
 //       //             rm = jumps[jumpIndex].1;
 //       //             jumpIndex += 1;
 //       //         }
 //       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);
 //       //         index = next;
 //       //         continue;
 //       //     }
 //       // }
 //       index += 1
 //     }
 //   }
 // }
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/dev/lib/infer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Event} Event
 */ /**
 * @typedef {'left' | 'center' | 'right' | 'none'} Align
 */ __turbopack_context__.s({
    "gfmTableAlign": ()=>gfmTableAlign
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs [app-client] (ecmascript)");
;
function gfmTableAlign(events, index) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(events[index][1].type === 'table', 'expected table');
    let inDelimiterRow = false;
    /** @type {Array<Align>} */ const align = [];
    while(index < events.length){
        const event = events[index];
        if (inDelimiterRow) {
            if (event[0] === 'enter') {
                // Start of alignment value: set a new column.
                // To do: `markdown-rs` uses `tableDelimiterCellValue`.
                if (event[1].type === 'tableContent') {
                    align.push(events[index + 1][1].type === 'tableDelimiterMarker' ? 'left' : 'none');
                }
            } else if (event[1].type === 'tableContent') {
                if (events[index - 1][1].type === 'tableDelimiterMarker') {
                    const alignIndex = align.length - 1;
                    align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right';
                }
            } else if (event[1].type === 'tableDelimiterRow') {
                break;
            }
        } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {
            inDelimiterRow = true;
        }
        index += 1;
    }
    return align;
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/dev/lib/syntax.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ /**
 * @typedef {[number, number, number, number]} Range
 *   Cell info.
 *
 * @typedef {0 | 1 | 2 | 3} RowKind
 *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.
 */ __turbopack_context__.s({
    "gfmTable": ()=>gfmTable
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-factory-space@1.1.0/node_modules/micromark-factory-space/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/types.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$table$2f$dev$2f$lib$2f$edit$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$table$2f$dev$2f$lib$2f$infer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/dev/lib/infer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const gfmTable = {
    flow: {
        null: {
            tokenize: tokenizeTable,
            resolveAll: resolveTable
        }
    }
};
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeTable(effects, ok, nok) {
    const self = this;
    let size = 0;
    let sizeB = 0;
    /** @type {boolean | undefined} */ let seen;
    return start;
    //TURBOPACK unreachable
    ;
    /**
   * Start of a GFM table.
   *
   * If there is a valid table row or table head before, then we try to parse
   * another row.
   * Otherwise, we try to parse a head.
   *
   * ```markdown
   * > | | a |
   *     ^
   *   | | - |
   * > | | b |
   *     ^
   * ```
   * @type {State}
   */ function start(code) {
        let index = self.events.length - 1;
        while(index > -1){
            const type = self.events[index][1].type;
            if (type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
            type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].linePrefix) index--;
            else break;
        }
        const tail = index > -1 ? self.events[index][1].type : null;
        const next = tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore;
        // Don’t allow lazy body rows.
        if (next === bodyRowStart && self.parser.lazy[self.now().line]) {
            return nok(code);
        }
        return next(code);
    }
    /**
   * Before table head row.
   *
   * ```markdown
   * > | | a |
   *     ^
   *   | | - |
   *   | | b |
   * ```
   *
   * @type {State}
   */ function headRowBefore(code) {
        effects.enter('tableHead');
        effects.enter('tableRow');
        return headRowStart(code);
    }
    /**
   * Before table head row, after whitespace.
   *
   * ```markdown
   * > | | a |
   *     ^
   *   | | - |
   *   | | b |
   * ```
   *
   * @type {State}
   */ function headRowStart(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar) {
            return headRowBreak(code);
        }
        // To do: micromark-js should let us parse our own whitespace in extensions,
        // like `markdown-rs`:
        //
        // ```js
        // // 4+ spaces.
        // if (markdownSpace(code)) {
        //   return nok(code)
        // }
        // ```
        seen = true;
        // Count the first character, that isn’t a pipe, double.
        sizeB += 1;
        return headRowBreak(code);
    }
    /**
   * At break in table head row.
   *
   * ```markdown
   * > | | a |
   *     ^
   *       ^
   *         ^
   *   | | - |
   *   | | b |
   * ```
   *
   * @type {State}
   */ function headRowBreak(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof) {
            // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.
            return nok(code);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEnding"])(code)) {
            // If anything other than one pipe (ignoring whitespace) was used, it’s fine.
            if (sizeB > 1) {
                sizeB = 0;
                // To do: check if this works.
                // Feel free to interrupt:
                self.interrupt = true;
                effects.exit('tableRow');
                effects.enter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].lineEnding);
                effects.consume(code);
                effects.exit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].lineEnding);
                return headDelimiterStart;
            }
            // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.
            return nok(code);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code)) {
            // To do: check if this is fine.
            // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)
            // State::Retry(space_or_tab(tokenizer))
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, headRowBreak, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].whitespace)(code);
        }
        sizeB += 1;
        if (seen) {
            seen = false;
            // Header cell count.
            size += 1;
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar) {
            effects.enter('tableCellDivider');
            effects.consume(code);
            effects.exit('tableCellDivider');
            // Whether a delimiter was seen.
            seen = true;
            return headRowBreak;
        }
        // Anything else is cell data.
        effects.enter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].data);
        return headRowData(code);
    }
    /**
   * In table head row data.
   *
   * ```markdown
   * > | | a |
   *       ^
   *   | | - |
   *   | | b |
   * ```
   *
   * @type {State}
   */ function headRowData(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code)) {
            effects.exit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].data);
            return headRowBreak(code);
        }
        effects.consume(code);
        return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].backslash ? headRowEscape : headRowData;
    }
    /**
   * In table head row escape.
   *
   * ```markdown
   * > | | a\-b |
   *         ^
   *   | | ---- |
   *   | | c    |
   * ```
   *
   * @type {State}
   */ function headRowEscape(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].backslash || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar) {
            effects.consume(code);
            return headRowData;
        }
        return headRowData(code);
    }
    /**
   * Before delimiter row.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *     ^
   *   | | b |
   * ```
   *
   * @type {State}
   */ function headDelimiterStart(code) {
        // Reset `interrupt`.
        self.interrupt = false;
        // Note: in `markdown-rs`, we need to handle piercing here too.
        if (self.parser.lazy[self.now().line]) {
            return nok(code);
        }
        effects.enter('tableDelimiterRow');
        // Track if we’ve seen a `:` or `|`.
        seen = false;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(self.parser.constructs.disable.null, 'expected `disabled.null`');
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, headDelimiterBefore, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].linePrefix, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].tabSize)(code);
        }
        return headDelimiterBefore(code);
    }
    /**
   * Before delimiter row, after optional whitespace.
   *
   * Reused when a `|` is found later, to parse another cell.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *     ^
   *   | | b |
   * ```
   *
   * @type {State}
   */ function headDelimiterBefore(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dash || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].colon) {
            return headDelimiterValueBefore(code);
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar) {
            seen = true;
            // If we start with a pipe, we open a cell marker.
            effects.enter('tableCellDivider');
            effects.consume(code);
            effects.exit('tableCellDivider');
            return headDelimiterCellBefore;
        }
        // More whitespace / empty row not allowed at start.
        return headDelimiterNok(code);
    }
    /**
   * After `|`, before delimiter cell.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *      ^
   * ```
   *
   * @type {State}
   */ function headDelimiterCellBefore(code) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, headDelimiterValueBefore, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].whitespace)(code);
        }
        return headDelimiterValueBefore(code);
    }
    /**
   * Before delimiter cell value.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *       ^
   * ```
   *
   * @type {State}
   */ function headDelimiterValueBefore(code) {
        // Align: left.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].colon) {
            sizeB += 1;
            seen = true;
            effects.enter('tableDelimiterMarker');
            effects.consume(code);
            effects.exit('tableDelimiterMarker');
            return headDelimiterLeftAlignmentAfter;
        }
        // Align: none.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dash) {
            sizeB += 1;
            // To do: seems weird that this *isn’t* left aligned, but that state is used?
            return headDelimiterLeftAlignmentAfter(code);
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEnding"])(code)) {
            return headDelimiterCellAfter(code);
        }
        return headDelimiterNok(code);
    }
    /**
   * After delimiter cell left alignment marker.
   *
   * ```markdown
   *   | | a  |
   * > | | :- |
   *        ^
   * ```
   *
   * @type {State}
   */ function headDelimiterLeftAlignmentAfter(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dash) {
            effects.enter('tableDelimiterFiller');
            return headDelimiterFiller(code);
        }
        // Anything else is not ok after the left-align colon.
        return headDelimiterNok(code);
    }
    /**
   * In delimiter cell filler.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *       ^
   * ```
   *
   * @type {State}
   */ function headDelimiterFiller(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].dash) {
            effects.consume(code);
            return headDelimiterFiller;
        }
        // Align is `center` if it was `left`, `right` otherwise.
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].colon) {
            seen = true;
            effects.exit('tableDelimiterFiller');
            effects.enter('tableDelimiterMarker');
            effects.consume(code);
            effects.exit('tableDelimiterMarker');
            return headDelimiterRightAlignmentAfter;
        }
        effects.exit('tableDelimiterFiller');
        return headDelimiterRightAlignmentAfter(code);
    }
    /**
   * After delimiter cell right alignment marker.
   *
   * ```markdown
   *   | |  a |
   * > | | -: |
   *         ^
   * ```
   *
   * @type {State}
   */ function headDelimiterRightAlignmentAfter(code) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, headDelimiterCellAfter, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].whitespace)(code);
        }
        return headDelimiterCellAfter(code);
    }
    /**
   * After delimiter cell.
   *
   * ```markdown
   *   | |  a |
   * > | | -: |
   *          ^
   * ```
   *
   * @type {State}
   */ function headDelimiterCellAfter(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar) {
            return headDelimiterBefore(code);
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEnding"])(code)) {
            // Exit when:
            // * there was no `:` or `|` at all (it’s a thematic break or setext
            //   underline instead)
            // * the header cell count is not the delimiter cell count
            if (!seen || size !== sizeB) {
                return headDelimiterNok(code);
            }
            // Note: in markdown-rs`, a reset is needed here.
            effects.exit('tableDelimiterRow');
            effects.exit('tableHead');
            // To do: in `markdown-rs`, resolvers need to be registered manually.
            // effects.register_resolver(ResolveName::GfmTable)
            return ok(code);
        }
        return headDelimiterNok(code);
    }
    /**
   * In delimiter row, at a disallowed byte.
   *
   * ```markdown
   *   | | a |
   * > | | x |
   *       ^
   * ```
   *
   * @type {State}
   */ function headDelimiterNok(code) {
        // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.
        return nok(code);
    }
    /**
   * Before table body row.
   *
   * ```markdown
   *   | | a |
   *   | | - |
   * > | | b |
   *     ^
   * ```
   *
   * @type {State}
   */ function bodyRowStart(code) {
        // Note: in `markdown-rs` we need to manually take care of a prefix,
        // but in `micromark-js` that is done for us, so if we’re here, we’re
        // never at whitespace.
        effects.enter('tableRow');
        return bodyRowBreak(code);
    }
    /**
   * At break in table body row.
   *
   * ```markdown
   *   | | a |
   *   | | - |
   * > | | b |
   *     ^
   *       ^
   *         ^
   * ```
   *
   * @type {State}
   */ function bodyRowBreak(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar) {
            effects.enter('tableCellDivider');
            effects.consume(code);
            effects.exit('tableCellDivider');
            return bodyRowBreak;
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEnding"])(code)) {
            effects.exit('tableRow');
            return ok(code);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, bodyRowBreak, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].whitespace)(code);
        }
        // Anything else is cell content.
        effects.enter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].data);
        return bodyRowData(code);
    }
    /**
   * In table body row data.
   *
   * ```markdown
   *   | | a |
   *   | | - |
   * > | | b |
   *       ^
   * ```
   *
   * @type {State}
   */ function bodyRowData(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code)) {
            effects.exit(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].data);
            return bodyRowBreak(code);
        }
        effects.consume(code);
        return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].backslash ? bodyRowEscape : bodyRowData;
    }
    /**
   * In table body row escape.
   *
   * ```markdown
   *   | | a    |
   *   | | ---- |
   * > | | b\-c |
   *         ^
   * ```
   *
   * @type {State}
   */ function bodyRowEscape(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].backslash || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].verticalBar) {
            effects.consume(code);
            return bodyRowData;
        }
        return bodyRowData(code);
    }
}
/** @type {Resolver} */ // eslint-disable-next-line complexity
function resolveTable(events, context) {
    let index = -1;
    let inFirstCellAwaitingPipe = true;
    /** @type {RowKind} */ let rowKind = 0;
    /** @type {Range} */ let lastCell = [
        0,
        0,
        0,
        0
    ];
    /** @type {Range} */ let cell = [
        0,
        0,
        0,
        0
    ];
    let afterHeadAwaitingFirstBodyRow = false;
    let lastTableEnd = 0;
    /** @type {Token | undefined} */ let currentTable;
    /** @type {Token | undefined} */ let currentBody;
    /** @type {Token | undefined} */ let currentCell;
    const map = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$table$2f$dev$2f$lib$2f$edit$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditMap"]();
    while(++index < events.length){
        const event = events[index];
        const token = event[1];
        if (event[0] === 'enter') {
            // Start of head.
            if (token.type === 'tableHead') {
                afterHeadAwaitingFirstBodyRow = false;
                // Inject previous (body end and) table end.
                if (lastTableEnd !== 0) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(currentTable, 'there should be a table opening');
                    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);
                    currentBody = undefined;
                    lastTableEnd = 0;
                }
                // Inject table start.
                currentTable = {
                    type: 'table',
                    start: Object.assign({}, token.start),
                    // Note: correct end is set later.
                    end: Object.assign({}, token.end)
                };
                map.add(index, 0, [
                    [
                        'enter',
                        currentTable,
                        context
                    ]
                ]);
            } else if (token.type === 'tableRow' || token.type === 'tableDelimiterRow') {
                inFirstCellAwaitingPipe = true;
                currentCell = undefined;
                lastCell = [
                    0,
                    0,
                    0,
                    0
                ];
                cell = [
                    0,
                    index + 1,
                    0,
                    0
                ];
                // Inject table body start.
                if (afterHeadAwaitingFirstBodyRow) {
                    afterHeadAwaitingFirstBodyRow = false;
                    currentBody = {
                        type: 'tableBody',
                        start: Object.assign({}, token.start),
                        // Note: correct end is set later.
                        end: Object.assign({}, token.end)
                    };
                    map.add(index, 0, [
                        [
                            'enter',
                            currentBody,
                            context
                        ]
                    ]);
                }
                rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1;
            } else if (rowKind && (token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].data || token.type === 'tableDelimiterMarker' || token.type === 'tableDelimiterFiller')) {
                inFirstCellAwaitingPipe = false;
                // First value in cell.
                if (cell[2] === 0) {
                    if (lastCell[1] !== 0) {
                        cell[0] = cell[1];
                        currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);
                        lastCell = [
                            0,
                            0,
                            0,
                            0
                        ];
                    }
                    cell[2] = index;
                }
            } else if (token.type === 'tableCellDivider') {
                if (inFirstCellAwaitingPipe) {
                    inFirstCellAwaitingPipe = false;
                } else {
                    if (lastCell[1] !== 0) {
                        cell[0] = cell[1];
                        currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);
                    }
                    lastCell = cell;
                    cell = [
                        lastCell[1],
                        index,
                        0,
                        0
                    ];
                }
            }
        } else if (token.type === 'tableHead') {
            afterHeadAwaitingFirstBodyRow = true;
            lastTableEnd = index;
        } else if (token.type === 'tableRow' || token.type === 'tableDelimiterRow') {
            lastTableEnd = index;
            if (lastCell[1] !== 0) {
                cell[0] = cell[1];
                currentCell = flushCell(map, context, lastCell, rowKind, index, currentCell);
            } else if (cell[1] !== 0) {
                currentCell = flushCell(map, context, cell, rowKind, index, currentCell);
            }
            rowKind = 0;
        } else if (rowKind && (token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].data || token.type === 'tableDelimiterMarker' || token.type === 'tableDelimiterFiller')) {
            cell[3] = index;
        }
    }
    if (lastTableEnd !== 0) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(currentTable, 'expected table opening');
        flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);
    }
    map.consume(context.events);
    // To do: move this into `html`, when events are exposed there.
    // That’s what `markdown-rs` does.
    // That needs updates to `mdast-util-gfm-table`.
    index = -1;
    while(++index < context.events.length){
        const event = context.events[index];
        if (event[0] === 'enter' && event[1].type === 'table') {
            event[1]._align = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$table$2f$dev$2f$lib$2f$infer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTableAlign"])(context.events, index);
        }
    }
    return events;
}
/// Generate a cell.
/**
 *
 * @param {EditMap} map
 * @param {TokenizeContext} context
 * @param {Range} range
 * @param {RowKind} rowKind
 * @param {number | undefined} rowEnd
 * @param {Token | undefined} previousCell
 * @returns {Token | undefined}
 */ // eslint-disable-next-line max-params
function flushCell(map, context, range, rowKind, rowEnd, previousCell) {
    // `markdown-rs` uses:
    // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'
    const groupName = rowKind === 1 ? 'tableHeader' : rowKind === 2 ? 'tableDelimiter' : 'tableData';
    // `markdown-rs` uses:
    // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'
    const valueName = 'tableContent';
    // Insert an exit for the previous cell, if there is one.
    //
    // ```markdown
    // > | | aa | bb | cc |
    //          ^-- exit
    //           ^^^^-- this cell
    // ```
    if (range[0] !== 0) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(previousCell, 'expected previous cell enter');
        previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
        map.add(range[0], 0, [
            [
                'exit',
                previousCell,
                context
            ]
        ]);
    }
    // Insert enter of this cell.
    //
    // ```markdown
    // > | | aa | bb | cc |
    //           ^-- enter
    //           ^^^^-- this cell
    // ```
    const now = getPoint(context.events, range[1]);
    previousCell = {
        type: groupName,
        start: Object.assign({}, now),
        // Note: correct end is set later.
        end: Object.assign({}, now)
    };
    map.add(range[1], 0, [
        [
            'enter',
            previousCell,
            context
        ]
    ]);
    // Insert text start at first data start and end at last data end, and
    // remove events between.
    //
    // ```markdown
    // > | | aa | bb | cc |
    //            ^-- enter
    //             ^-- exit
    //           ^^^^-- this cell
    // ```
    if (range[2] !== 0) {
        const relatedStart = getPoint(context.events, range[2]);
        const relatedEnd = getPoint(context.events, range[3]);
        /** @type {Token} */ const valueToken = {
            type: valueName,
            start: Object.assign({}, relatedStart),
            end: Object.assign({}, relatedEnd)
        };
        map.add(range[2], 0, [
            [
                'enter',
                valueToken,
                context
            ]
        ]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(range[3] !== 0);
        if (rowKind !== 2) {
            // Fix positional info on remaining events
            const start = context.events[range[2]];
            const end = context.events[range[3]];
            start[1].end = Object.assign({}, end[1].end);
            start[1].type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].chunkText;
            start[1].contentType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].contentTypeText;
            // Remove if needed.
            if (range[3] > range[2] + 1) {
                const a = range[2] + 1;
                const b = range[3] - range[2] - 1;
                map.add(a, b, []);
            }
        }
        map.add(range[3] + 1, 0, [
            [
                'exit',
                valueToken,
                context
            ]
        ]);
    }
    // Insert an exit for the last cell, if at the row end.
    //
    // ```markdown
    // > | | aa | bb | cc |
    //                    ^-- exit
    //               ^^^^^^-- this cell (the last one contains two “between” parts)
    // ```
    if (rowEnd !== undefined) {
        previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
        map.add(rowEnd, 0, [
            [
                'exit',
                previousCell,
                context
            ]
        ]);
        previousCell = undefined;
    }
    return previousCell;
}
/**
 * Generate table end (and table body end).
 *
 * @param {EditMap} map
 * @param {TokenizeContext} context
 * @param {number} index
 * @param {Token} table
 * @param {Token | undefined} tableBody
 */ // eslint-disable-next-line max-params
function flushTableEnd(map, context, index, table, tableBody) {
    /** @type {Array<Event>} */ const exits = [];
    const related = getPoint(context.events, index);
    if (tableBody) {
        tableBody.end = Object.assign({}, related);
        exits.push([
            'exit',
            tableBody,
            context
        ]);
    }
    table.end = Object.assign({}, related);
    exits.push([
        'exit',
        table,
        context
    ]);
    map.add(index + 1, 0, exits);
}
/**
 * @param {Array<Event>} events
 * @param {number} index
 * @returns {readonly Point}
 */ function getPoint(events, index) {
    const event = events[index];
    const side = event[0] === 'enter' ? 'start' : 'end';
    return event[1][side];
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/dev/lib/html.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 */ /**
 * @typedef {import('./infer.js').Align} Align
 */ __turbopack_context__.s({
    "gfmTableHtml": ()=>gfmTableHtml
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs [app-client] (ecmascript)");
;
const alignment = {
    none: '',
    left: ' align="left"',
    right: ' align="right"',
    center: ' align="center"'
};
const gfmTableHtml = {
    enter: {
        table (token) {
            const tableAlign = token._align;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(tableAlign, 'expected `_align`');
            this.lineEndingIfNeeded();
            this.tag('<table>');
            this.setData('tableAlign', tableAlign);
        },
        tableBody () {
            this.tag('<tbody>');
        },
        tableData () {
            const tableAlign = this.getData('tableAlign');
            const tableColumn = this.getData('tableColumn');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(tableAlign, 'expected `tableAlign`');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(typeof tableColumn === 'number', 'expected `tableColumn`');
            const align = alignment[tableAlign[tableColumn]];
            if (align === undefined) {
                // Capture results to ignore them.
                this.buffer();
            } else {
                this.lineEndingIfNeeded();
                this.tag('<td' + align + '>');
            }
        },
        tableHead () {
            this.lineEndingIfNeeded();
            this.tag('<thead>');
        },
        tableHeader () {
            const tableAlign = this.getData('tableAlign');
            const tableColumn = this.getData('tableColumn');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(tableAlign, 'expected `tableAlign`');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(typeof tableColumn === 'number', 'expected `tableColumn`');
            const align = alignment[tableAlign[tableColumn]];
            this.lineEndingIfNeeded();
            this.tag('<th' + align + '>');
        },
        tableRow () {
            this.setData('tableColumn', 0);
            this.lineEndingIfNeeded();
            this.tag('<tr>');
        }
    },
    exit: {
        // Overwrite the default code text data handler to unescape escaped pipes when
        // they are in tables.
        codeTextData (token) {
            let value = this.sliceSerialize(token);
            if (this.getData('tableAlign')) {
                value = value.replace(/\\([\\|])/g, replace);
            }
            this.raw(this.encode(value));
        },
        table () {
            this.setData('tableAlign');
            // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,
            // but we do need to reset it to match a funky newline GH generates for
            // list items combined with tables.
            this.setData('slurpAllLineEndings');
            this.lineEndingIfNeeded();
            this.tag('</table>');
        },
        tableBody () {
            this.lineEndingIfNeeded();
            this.tag('</tbody>');
        },
        tableData () {
            const tableAlign = this.getData('tableAlign');
            const tableColumn = this.getData('tableColumn');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(tableAlign, 'expected `tableAlign`');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(typeof tableColumn === 'number', 'expected `tableColumn`');
            if (tableColumn in tableAlign) {
                this.tag('</td>');
                this.setData('tableColumn', tableColumn + 1);
            } else {
                // Stop capturing.
                this.resume();
            }
        },
        tableHead () {
            this.lineEndingIfNeeded();
            this.tag('</thead>');
        },
        tableHeader () {
            const tableColumn = this.getData('tableColumn');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(typeof tableColumn === 'number', 'expected `tableColumn`');
            this.tag('</th>');
            this.setData('tableColumn', tableColumn + 1);
        },
        tableRow () {
            const tableAlign = this.getData('tableAlign');
            let tableColumn = this.getData('tableColumn');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(tableAlign, 'expected `tableAlign`');
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(typeof tableColumn === 'number', 'expected `tableColumn`');
            while(tableColumn < tableAlign.length){
                this.lineEndingIfNeeded();
                this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>');
                tableColumn++;
            }
            this.setData('tableColumn', tableColumn);
            this.lineEndingIfNeeded();
            this.tag('</tr>');
        }
    }
};
/**
 * @param {string} $0
 * @param {string} $1
 * @returns {string}
 */ function replace($0, $1) {
    // Pipes work, backslashes don’t (but can’t escape pipes).
    return $1 === '|' ? $1 : $0;
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-tagfilter@1.0.2/node_modules/micromark-extension-gfm-tagfilter/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').CompileContext} CompileContext
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 * @typedef {import('micromark-util-types').Token} Token
 */ // An opening or closing tag start, followed by a case-insensitive specific tag name,
// followed by HTML whitespace, a greater than, or a slash.
__turbopack_context__.s({
    "gfmTagfilterHtml": ()=>gfmTagfilterHtml
});
const reFlow = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\t\n\f\r />])/gi;
// As HTML (text) parses tags separately (and very strictly), we don’t need to be
// global.
const reText = new RegExp('^' + reFlow.source, 'i');
const gfmTagfilterHtml = {
    exit: {
        htmlFlowData (token) {
            exitHtmlData.call(this, token, reFlow);
        },
        htmlTextData (token) {
            exitHtmlData.call(this, token, reText);
        }
    }
};
/**
 * @this {CompileContext}
 * @param {Token} token
 * @param {RegExp} filter
 */ function exitHtmlData(token, filter) {
    let value = this.sliceSerialize(token);
    if (this.options.allowDangerousHtml) {
        value = value.replace(filter, '&lt;$1$2');
    }
    this.raw(this.encode(value));
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */ __turbopack_context__.s({
    "gfmTaskListItem": ()=>gfmTaskListItem
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-factory-space@1.1.0/node_modules/micromark-factory-space/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/types.js [app-client] (ecmascript)");
;
;
;
;
;
const tasklistCheck = {
    tokenize: tokenizeTasklistCheck
};
const gfmTaskListItem = {
    text: {
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket]: tasklistCheck
    }
};
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function tokenizeTasklistCheck(effects, ok, nok) {
    const self = this;
    return open;
    //TURBOPACK unreachable
    ;
    /**
   * At start of task list item check.
   *
   * ```markdown
   * > | * [x] y.
   *       ^
   * ```
   *
   * @type {State}
   */ function open(code) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uvu$40$0$2e$5$2e$6$2f$node_modules$2f$uvu$2f$assert$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].leftSquareBracket, 'expected `[`');
        if (// Exit if there’s stuff before.
        self.previous !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof || // Exit if not in the first content that is the first child of a list
        // item.
        !self._gfmTasklistFirstContentOfListItem) {
            return nok(code);
        }
        effects.enter('taskListCheck');
        effects.enter('taskListCheckMarker');
        effects.consume(code);
        effects.exit('taskListCheckMarker');
        return inside;
    }
    /**
   * In task list item check.
   *
   * ```markdown
   * > | * [x] y.
   *        ^
   * ```
   *
   * @type {State}
   */ function inside(code) {
        // Currently we match how GH works in files.
        // To match how GH works in comments, use `markdownSpace` (`[\t ]`) instead
        // of `markdownLineEndingOrSpace` (`[\t\n\r ]`).
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEndingOrSpace"])(code)) {
            effects.enter('taskListCheckValueUnchecked');
            effects.consume(code);
            effects.exit('taskListCheckValueUnchecked');
            return close;
        }
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].uppercaseX || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lowercaseX) {
            effects.enter('taskListCheckValueChecked');
            effects.consume(code);
            effects.exit('taskListCheckValueChecked');
            return close;
        }
        return nok(code);
    }
    /**
   * At close of task list item check.
   *
   * ```markdown
   * > | * [x] y.
   *         ^
   * ```
   *
   * @type {State}
   */ function close(code) {
        if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].rightSquareBracket) {
            effects.enter('taskListCheckMarker');
            effects.consume(code);
            effects.exit('taskListCheckMarker');
            effects.exit('taskListCheck');
            return after;
        }
        return nok(code);
    }
    /**
   * @type {State}
   */ function after(code) {
        // EOL in paragraph means there must be something else after it.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownLineEnding"])(code)) {
            return ok(code);
        }
        // Space or tab?
        // Check what comes after.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownSpace"])(code)) {
            return effects.check({
                tokenize: spaceThenNonSpace
            }, ok, nok)(code);
        }
        // EOF, or non-whitespace, both wrong.
        return nok(code);
    }
}
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */ function spaceThenNonSpace(effects, ok, nok) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$factory$2d$space$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$factory$2d$space$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["factorySpace"])(effects, after, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["types"].whitespace);
    //TURBOPACK unreachable
    ;
    /**
   * After whitespace, after task list item check.
   *
   * ```markdown
   * > | * [x] y.
   *           ^
   * ```
   *
   * @type {State}
   */ function after(code) {
        // EOF means there was nothing, so bad.
        // EOL means there’s content after it, so good.
        // Impossible to have more spaces.
        // Anything else is good.
        return code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].eof ? nok(code) : ok(code);
    }
}
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/dev/lib/html.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 */ // To do: next major: expose function to make extension.
/**
 * Extension for `micromark` that can be passed in `htmlExtensions` to
 * support GFM task list items when serializing to HTML.
 *
 * @type {HtmlExtension}
 */ __turbopack_context__.s({
    "gfmTaskListItemHtml": ()=>gfmTaskListItemHtml
});
const gfmTaskListItemHtml = {
    enter: {
        taskListCheck () {
            this.tag('<input type="checkbox" disabled="" ');
        }
    },
    exit: {
        taskListCheck () {
            this.tag('/>');
        },
        taskListCheckValueChecked () {
            this.tag('checked="" ');
        }
    }
};
}),
"[project]/node_modules/.pnpm/micromark-extension-gfm@2.0.3/node_modules/micromark-extension-gfm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions
 * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 */ __turbopack_context__.s({
    "gfm": ()=>gfm,
    "gfmHtml": ()=>gfmHtml
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$combine$2d$extensions$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$combine$2d$extensions$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-combine-extensions@1.1.0/node_modules/micromark-util-combine-extensions/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$autolink$2d$literal$40$1$2e$0$2e$5$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$autolink$2d$literal$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$autolink$2d$literal$40$1$2e$0$2e$5$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$autolink$2d$literal$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$footnote$40$1$2e$1$2e$2$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$footnote$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-footnote@1.1.2/node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$footnote$40$1$2e$1$2e$2$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$footnote$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-footnote@1.1.2/node_modules/micromark-extension-gfm-footnote/dev/lib/html.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$strikethrough$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$strikethrough$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$strikethrough$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$strikethrough$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/dev/lib/html.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$table$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/dev/lib/syntax.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$table$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/dev/lib/html.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$tagfilter$40$1$2e$0$2e$2$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$tagfilter$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-tagfilter@1.0.2/node_modules/micromark-extension-gfm-tagfilter/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$task$2d$list$2d$item$40$1$2e$0$2e$5$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$task$2d$list$2d$item$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$task$2d$list$2d$item$40$1$2e$0$2e$5$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$task$2d$list$2d$item$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/dev/lib/html.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
function gfm(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$combine$2d$extensions$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$combine$2d$extensions$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineExtensions"])([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$autolink$2d$literal$40$1$2e$0$2e$5$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$autolink$2d$literal$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmAutolinkLiteral"],
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$footnote$40$1$2e$1$2e$2$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$footnote$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmFootnote"])(),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$strikethrough$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$strikethrough$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmStrikethrough"])(options),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$table$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTable"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$task$2d$list$2d$item$40$1$2e$0$2e$5$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$task$2d$list$2d$item$2f$dev$2f$lib$2f$syntax$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTaskListItem"]
    ]);
}
function gfmHtml(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$combine$2d$extensions$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$combine$2d$extensions$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineHtmlExtensions"])([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$autolink$2d$literal$40$1$2e$0$2e$5$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$autolink$2d$literal$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmAutolinkLiteralHtml"],
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$footnote$40$1$2e$1$2e$2$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$footnote$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmFootnoteHtml"])(options),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$strikethrough$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$strikethrough$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmStrikethroughHtml"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$table$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTableHtml"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$tagfilter$40$1$2e$0$2e$2$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$tagfilter$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTagfilterHtml"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$2d$task$2d$list$2d$item$40$1$2e$0$2e$5$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2d$task$2d$list$2d$item$2f$dev$2f$lib$2f$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTaskListItemHtml"]
    ]);
}
}),
"[project]/node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>escapeStringRegexp
});
function escapeStringRegexp(string) {
    if (typeof string !== 'string') {
        throw new TypeError('Expected a string');
    }
    // Escape characters with special meaning either inside or outside character sets.
    // Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
}),
"[project]/node_modules/.pnpm/unist-util-is@5.2.1/node_modules/unist-util-is/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */ /**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */ /**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */ /**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */ /**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */ /**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */ /**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */ __turbopack_context__.s({
    "convert": ()=>convert,
    "is": ()=>is
});
const is = /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */ // eslint-disable-next-line max-params
function is(node, test, index, parent, context) {
    const check = convert(test);
    if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {
        throw new Error('Expected positive finite index');
    }
    if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {
        throw new Error('Expected parent node');
    }
    if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {
        throw new Error('Expected both parent and index');
    }
    // @ts-expect-error Looks like a node.
    return node && node.type && typeof node.type === 'string' ? Boolean(check.call(context, node, index, parent)) : false;
};
const convert = /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */ function(test) {
    if (test === undefined || test === null) {
        return ok;
    }
    if (typeof test === 'string') {
        return typeFactory(test);
    }
    if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === 'function') {
        return castFactory(test);
    }
    throw new Error('Expected function, string, or object as test');
};
/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */ function anyFactory(tests) {
    /** @type {Array<AssertAnything>} */ const checks = [];
    let index = -1;
    while(++index < tests.length){
        checks[index] = convert(tests[index]);
    }
    return castFactory(any);
    //TURBOPACK unreachable
    ;
    /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */ function any() {
        for(var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++){
            parameters[_key] = arguments[_key];
        }
        let index = -1;
        while(++index < checks.length){
            if (checks[index].call(this, ...parameters)) return true;
        }
        return false;
    }
}
/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */ function propsFactory(check) {
    return castFactory(all);
    //TURBOPACK unreachable
    ;
    /**
   * @param {Node} node
   * @returns {boolean}
   */ function all(node) {
        /** @type {string} */ let key;
        for(key in check){
            // @ts-expect-error: hush, it sure works as an index.
            if (node[key] !== check[key]) return false;
        }
        return true;
    }
}
/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */ function typeFactory(check) {
    return castFactory(type);
    //TURBOPACK unreachable
    ;
    /**
   * @param {Node} node
   */ function type(node) {
        return node && node.type === check;
    }
}
/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */ function castFactory(check) {
    return assertion;
    //TURBOPACK unreachable
    ;
    /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */ function assertion(node) {
        for(var _len = arguments.length, parameters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            parameters[_key - 1] = arguments[_key];
        }
        return Boolean(node && typeof node === 'object' && 'type' in node && // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters)));
    }
}
function ok() {
    return true;
}
}),
"[project]/node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/color.browser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @param {string} d
 * @returns {string}
 */ __turbopack_context__.s({
    "color": ()=>color
});
function color(d) {
    return d;
}
}),
"[project]/node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 */ /**
 * @typedef {boolean | 'skip'} Action
 *   Union of the action types.
 *
 * @typedef {number} Index
 *   Move to the sibling at `index` next (after node itself is completely
 *   traversed).
 *
 *   Useful if mutating the tree, such as removing the node the visitor is
 *   currently on, or any of its previous siblings.
 *   Results less than 0 or greater than or equal to `children.length` stop
 *   traversing the parent.
 *
 * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple
 *   List with one or two values, the first an action, the second an index.
 *
 * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult
 *   Any value that can be returned from a visitor.
 */ /**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform the parent of node (the last of `ancestors`).
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of an ancestor still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Array<Ancestor>} ancestors
 *   Ancestors of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */ /**
 * @template {Node} [Tree=Node]
 *   Tree type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor
 *   Build a typed `Visitor` function from a tree and a test.
 *
 *   It will infer which values are passed as `node` and which as `parents`.
 */ __turbopack_context__.s({
    "CONTINUE": ()=>CONTINUE,
    "EXIT": ()=>EXIT,
    "SKIP": ()=>SKIP,
    "visitParents": ()=>visitParents
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$unist$2d$util$2d$is$40$5$2e$2$2e$1$2f$node_modules$2f$unist$2d$util$2d$is$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/unist-util-is@5.2.1/node_modules/unist-util-is/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$unist$2d$util$2d$visit$2d$parents$40$5$2e$1$2e$3$2f$node_modules$2f$unist$2d$util$2d$visit$2d$parents$2f$lib$2f$color$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/color.browser.js [app-client] (ecmascript)");
;
;
const CONTINUE = true;
const EXIT = false;
const SKIP = 'skip';
const visitParents = /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */ function(tree, test, visitor, reverse) {
    if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor;
        // @ts-expect-error no visitor given, so `visitor` is test.
        visitor = test;
        test = null;
    }
    const is = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$unist$2d$util$2d$is$40$5$2e$2$2e$1$2f$node_modules$2f$unist$2d$util$2d$is$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convert"])(test);
    const step = reverse ? -1 : 1;
    factory(tree, undefined, [])();
    /**
       * @param {Node} node
       * @param {number | undefined} index
       * @param {Array<Parent>} parents
       */ function factory(node, index, parents) {
        /** @type {Record<string, unknown>} */ // @ts-expect-error: hush
        const value = node && typeof node === 'object' ? node : {};
        if (typeof value.type === 'string') {
            const name = // `hast`
            typeof value.tagName === 'string' ? value.tagName : typeof value.name === 'string' ? value.name : undefined;
            Object.defineProperty(visit, 'name', {
                value: 'node (' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$unist$2d$util$2d$visit$2d$parents$40$5$2e$1$2e$3$2f$node_modules$2f$unist$2d$util$2d$visit$2d$parents$2f$lib$2f$color$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"])(node.type + (name ? '<' + name + '>' : '')) + ')'
            });
        }
        return visit;
        //TURBOPACK unreachable
        ;
        function visit() {
            /** @type {ActionTuple} */ let result = [];
            /** @type {ActionTuple} */ let subresult;
            /** @type {number} */ let offset;
            /** @type {Array<Parent>} */ let grandparents;
            if (!test || is(node, index, parents[parents.length - 1] || null)) {
                result = toResult(visitor(node, parents));
                if (result[0] === EXIT) {
                    return result;
                }
            }
            // @ts-expect-error looks like a parent.
            if (node.children && result[0] !== SKIP) {
                // @ts-expect-error looks like a parent.
                offset = (reverse ? node.children.length : -1) + step;
                // @ts-expect-error looks like a parent.
                grandparents = parents.concat(node);
                // @ts-expect-error looks like a parent.
                while(offset > -1 && offset < node.children.length){
                    // @ts-expect-error looks like a parent.
                    subresult = factory(node.children[offset], offset, grandparents)();
                    if (subresult[0] === EXIT) {
                        return subresult;
                    }
                    offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;
                }
            }
            return result;
        }
    }
};
/**
 * Turn a return value into a clean result.
 *
 * @param {VisitorResult} value
 *   Valid return values from visitors.
 * @returns {ActionTuple}
 *   Clean result.
 */ function toResult(value) {
    if (Array.isArray(value)) {
        return value;
    }
    if (typeof value === 'number') {
        return [
            CONTINUE,
            value
        ];
    }
    return [
        value
    ];
}
}),
"[project]/node_modules/.pnpm/mdast-util-find-and-replace@2.2.2/node_modules/mdast-util-find-and-replace/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').Parent} MdastParent
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 * @typedef {import('mdast').Text} Text
 * @typedef {import('unist-util-visit-parents').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 */ /**
 * @typedef {Content | Root} Node
 * @typedef {Extract<Node, MdastParent>} Parent
 * @typedef {Exclude<Parent, Root>} ContentParent
 *
 * @typedef RegExpMatchObject
 *   Info on the match.
 * @property {number} index
 *   The index of the search at which the result was found.
 * @property {string} input
 *   A copy of the search string in the text node.
 * @property {[Root, ...Array<ContentParent>, Text]} stack
 *   All ancestors of the text node, where the last node is the text itself.
 *
 * @callback ReplaceFunction
 *   Callback called when a search matches.
 * @param {...any} parameters
 *   The parameters are the result of corresponding search expression:
 *
 *   * `value` (`string`) — whole match
 *   * `...capture` (`Array<string>`) — matches from regex capture groups
 *   * `match` (`RegExpMatchObject`) — info on the match
 * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}
 *   Thing to replace with.
 *
 *   * when `null`, `undefined`, `''`, remove the match
 *   * …or when `false`, do not replace at all
 *   * …or when `string`, replace with a text node of that value
 *   * …or when `Node` or `Array<Node>`, replace with those nodes
 *
 * @typedef {string | RegExp} Find
 *   Pattern to find.
 *
 *   Strings are escaped and then turned into global expressions.
 *
 * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList
 *   Several find and replaces, in array form.
 * @typedef {Record<string, Replace>} FindAndReplaceSchema
 *   Several find and replaces, in object form.
 * @typedef {[Find, Replace]} FindAndReplaceTuple
 *   Find and replace in tuple form.
 * @typedef {string | ReplaceFunction} Replace
 *   Thing to replace with.
 * @typedef {[RegExp, ReplaceFunction]} Pair
 *   Normalized find and replace.
 * @typedef {Array<Pair>} Pairs
 *   All find and replaced.
 *
 * @typedef Options
 *   Configuration.
 * @property {Test | null | undefined} [ignore]
 *   Test for which nodes to ignore.
 */ __turbopack_context__.s({
    "findAndReplace": ()=>findAndReplace
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$escape$2d$string$2d$regexp$40$5$2e$0$2e$0$2f$node_modules$2f$escape$2d$string$2d$regexp$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$unist$2d$util$2d$visit$2d$parents$40$5$2e$1$2e$3$2f$node_modules$2f$unist$2d$util$2d$visit$2d$parents$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$unist$2d$util$2d$is$40$5$2e$2$2e$1$2f$node_modules$2f$unist$2d$util$2d$is$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/unist-util-is@5.2.1/node_modules/unist-util-is/lib/index.js [app-client] (ecmascript)");
;
;
;
const own = {}.hasOwnProperty;
const findAndReplace = /**
     * @template {Node} Tree
     * @param {Tree} tree
     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find
     * @param {Replace | Options | null | undefined} [replace]
     * @param {Options | null | undefined} [options]
     * @returns {Tree}
     */ function(tree, find, replace, options) {
    /** @type {Options | null | undefined} */ let settings;
    /** @type {FindAndReplaceSchema|FindAndReplaceList} */ let schema;
    if (typeof find === 'string' || find instanceof RegExp) {
        // @ts-expect-error don’t expect options twice.
        schema = [
            [
                find,
                replace
            ]
        ];
        settings = options;
    } else {
        schema = find;
        // @ts-expect-error don’t expect replace twice.
        settings = replace;
    }
    if (!settings) {
        settings = {};
    }
    const ignored = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$unist$2d$util$2d$is$40$5$2e$2$2e$1$2f$node_modules$2f$unist$2d$util$2d$is$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convert"])(settings.ignore || []);
    const pairs = toPairs(schema);
    let pairIndex = -1;
    while(++pairIndex < pairs.length){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$unist$2d$util$2d$visit$2d$parents$40$5$2e$1$2e$3$2f$node_modules$2f$unist$2d$util$2d$visit$2d$parents$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["visitParents"])(tree, 'text', visitor);
    }
    // To do next major: don’t return the given tree.
    return tree;
    //TURBOPACK unreachable
    ;
    /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */ function visitor(node, parents) {
        let index = -1;
        /** @type {Parent | undefined} */ let grandparent;
        while(++index < parents.length){
            const parent = parents[index];
            if (ignored(parent, // @ts-expect-error: TS doesn’t understand but it’s perfect.
            grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {
                return;
            }
            grandparent = parent;
        }
        if (grandparent) {
            return handler(node, parents);
        }
    }
    /**
       * Handle a text node which is not in an ignored parent.
       *
       * @param {Text} node
       *   Text node.
       * @param {Array<Parent>} parents
       *   Parents.
       * @returns {VisitorResult}
       *   Result.
       */ function handler(node, parents) {
        const parent = parents[parents.length - 1];
        const find = pairs[pairIndex][0];
        const replace = pairs[pairIndex][1];
        let start = 0;
        // @ts-expect-error: TS is wrong, some of these children can be text.
        const index = parent.children.indexOf(node);
        let change = false;
        /** @type {Array<PhrasingContent>} */ let nodes = [];
        find.lastIndex = 0;
        let match = find.exec(node.value);
        while(match){
            const position = match.index;
            /** @type {RegExpMatchObject} */ const matchObject = {
                index: match.index,
                input: match.input,
                // @ts-expect-error: stack is fine.
                stack: [
                    ...parents,
                    node
                ]
            };
            let value = replace(...match, matchObject);
            if (typeof value === 'string') {
                value = value.length > 0 ? {
                    type: 'text',
                    value
                } : undefined;
            }
            // It wasn’t a match after all.
            if (value !== false) {
                if (start !== position) {
                    nodes.push({
                        type: 'text',
                        value: node.value.slice(start, position)
                    });
                }
                if (Array.isArray(value)) {
                    nodes.push(...value);
                } else if (value) {
                    nodes.push(value);
                }
                start = position + match[0].length;
                change = true;
            }
            if (!find.global) {
                break;
            }
            match = find.exec(node.value);
        }
        if (change) {
            if (start < node.value.length) {
                nodes.push({
                    type: 'text',
                    value: node.value.slice(start)
                });
            }
            parent.children.splice(index, 1, ...nodes);
        } else {
            nodes = [
                node
            ];
        }
        return index + nodes.length;
    }
};
/**
 * Turn a schema into pairs.
 *
 * @param {FindAndReplaceSchema | FindAndReplaceList} schema
 *   Schema.
 * @returns {Pairs}
 *   Clean pairs.
 */ function toPairs(schema) {
    /** @type {Pairs} */ const result = [];
    if (typeof schema !== 'object') {
        throw new TypeError('Expected array or object as schema');
    }
    if (Array.isArray(schema)) {
        let index = -1;
        while(++index < schema.length){
            result.push([
                toExpression(schema[index][0]),
                toFunction(schema[index][1])
            ]);
        }
    } else {
        /** @type {string} */ let key;
        for(key in schema){
            if (own.call(schema, key)) {
                result.push([
                    toExpression(key),
                    toFunction(schema[key])
                ]);
            }
        }
    }
    return result;
}
/**
 * Turn a find into an expression.
 *
 * @param {Find} find
 *   Find.
 * @returns {RegExp}
 *   Expression.
 */ function toExpression(find) {
    return typeof find === 'string' ? new RegExp((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$escape$2d$string$2d$regexp$40$5$2e$0$2e$0$2f$node_modules$2f$escape$2d$string$2d$regexp$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(find), 'g') : find;
}
/**
 * Turn a replace into a function.
 *
 * @param {Replace} replace
 *   Replace.
 * @returns {ReplaceFunction}
 *   Function.
 */ function toFunction(replace) {
    return typeof replace === 'function' ? replace : ()=>replace;
}
}),
"[project]/node_modules/.pnpm/mdast-util-gfm-autolink-literal@1.0.3/node_modules/mdast-util-gfm-autolink-literal/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').Link} Link
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 *
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform
 *
 * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 *
 * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction
 * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject
 */ __turbopack_context__.s({
    "gfmAutolinkLiteralFromMarkdown": ()=>gfmAutolinkLiteralFromMarkdown,
    "gfmAutolinkLiteralToMarkdown": ()=>gfmAutolinkLiteralToMarkdown
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ccount$40$2$2e$0$2e$1$2f$node_modules$2f$ccount$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$find$2d$and$2d$replace$40$2$2e$2$2e$2$2f$node_modules$2f$mdast$2d$util$2d$find$2d$and$2d$replace$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-find-and-replace@2.2.2/node_modules/mdast-util-find-and-replace/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/dev/index.js [app-client] (ecmascript)");
;
;
;
/** @type {ConstructName} */ const inConstruct = 'phrasing';
/** @type {Array<ConstructName>} */ const notInConstruct = [
    'autolink',
    'link',
    'image',
    'label'
];
const gfmAutolinkLiteralFromMarkdown = {
    transforms: [
        transformGfmAutolinkLiterals
    ],
    enter: {
        literalAutolink: enterLiteralAutolink,
        literalAutolinkEmail: enterLiteralAutolinkValue,
        literalAutolinkHttp: enterLiteralAutolinkValue,
        literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
        literalAutolink: exitLiteralAutolink,
        literalAutolinkEmail: exitLiteralAutolinkEmail,
        literalAutolinkHttp: exitLiteralAutolinkHttp,
        literalAutolinkWww: exitLiteralAutolinkWww
    }
};
const gfmAutolinkLiteralToMarkdown = {
    unsafe: [
        {
            character: '@',
            before: '[+\\-.\\w]',
            after: '[\\-.\\w]',
            inConstruct,
            notInConstruct
        },
        {
            character: '.',
            before: '[Ww]',
            after: '[\\-.\\w]',
            inConstruct,
            notInConstruct
        },
        {
            character: ':',
            before: '[ps]',
            after: '\\/',
            inConstruct,
            notInConstruct
        }
    ]
};
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterLiteralAutolink(token) {
    this.enter({
        type: 'link',
        title: null,
        url: '',
        children: []
    }, token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterLiteralAutolinkValue(token) {
    this.config.enter.autolinkProtocol.call(this, token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitLiteralAutolinkHttp(token) {
    this.config.exit.autolinkProtocol.call(this, token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitLiteralAutolinkWww(token) {
    this.config.exit.data.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = 'http://' + this.sliceSerialize(token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitLiteralAutolinkEmail(token) {
    this.config.exit.autolinkEmail.call(this, token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitLiteralAutolink(token) {
    this.exit(token);
}
/** @type {FromMarkdownTransform} */ function transformGfmAutolinkLiterals(tree) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$find$2d$and$2d$replace$40$2$2e$2$2e$2$2f$node_modules$2f$mdast$2d$util$2d$find$2d$and$2d$replace$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findAndReplace"])(tree, [
        [
            /(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi,
            findUrl
        ],
        [
            /([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g,
            findEmail
        ]
    ], {
        ignore: [
            'link',
            'linkReference'
        ]
    });
}
/**
 * @type {ReplaceFunction}
 * @param {string} _
 * @param {string} protocol
 * @param {string} domain
 * @param {string} path
 * @param {RegExpMatchObject} match
 * @returns {Link | Array<PhrasingContent> | false}
 */ // eslint-disable-next-line max-params
function findUrl(_, protocol, domain, path, match) {
    let prefix = '';
    // Not an expected previous character.
    if (!previous(match)) {
        return false;
    }
    // Treat `www` as part of the domain.
    if (/^w/i.test(protocol)) {
        domain = protocol + domain;
        protocol = '';
        prefix = 'http://';
    }
    if (!isCorrectDomain(domain)) {
        return false;
    }
    const parts = splitUrl(domain + path);
    if (!parts[0]) return false;
    /** @type {Link} */ const result = {
        type: 'link',
        title: null,
        url: prefix + protocol + parts[0],
        children: [
            {
                type: 'text',
                value: protocol + parts[0]
            }
        ]
    };
    if (parts[1]) {
        return [
            result,
            {
                type: 'text',
                value: parts[1]
            }
        ];
    }
    return result;
}
/**
 * @type {ReplaceFunction}
 * @param {string} _
 * @param {string} atext
 * @param {string} label
 * @param {RegExpMatchObject} match
 * @returns {Link | false}
 */ function findEmail(_, atext, label, match) {
    if (// Not an expected previous character.
    !previous(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)) {
        return false;
    }
    return {
        type: 'link',
        title: null,
        url: 'mailto:' + atext + '@' + label,
        children: [
            {
                type: 'text',
                value: atext + '@' + label
            }
        ]
    };
}
/**
 * @param {string} domain
 * @returns {boolean}
 */ function isCorrectDomain(domain) {
    const parts = domain.split('.');
    if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
        return false;
    }
    return true;
}
/**
 * @param {string} url
 * @returns {[string, string | undefined]}
 */ function splitUrl(url) {
    const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
    if (!trailExec) {
        return [
            url,
            undefined
        ];
    }
    url = url.slice(0, trailExec.index);
    let trail = trailExec[0];
    let closingParenIndex = trail.indexOf(')');
    const openingParens = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ccount$40$2$2e$0$2e$1$2f$node_modules$2f$ccount$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ccount"])(url, '(');
    let closingParens = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ccount$40$2$2e$0$2e$1$2f$node_modules$2f$ccount$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ccount"])(url, ')');
    while(closingParenIndex !== -1 && openingParens > closingParens){
        url += trail.slice(0, closingParenIndex + 1);
        trail = trail.slice(closingParenIndex + 1);
        closingParenIndex = trail.indexOf(')');
        closingParens++;
    }
    return [
        url,
        trail
    ];
}
/**
 * @param {RegExpMatchObject} match
 * @param {boolean | null | undefined} [email=false]
 * @returns {boolean}
 */ function previous(match, email) {
    const code = match.input.charCodeAt(match.index - 1);
    return (match.index === 0 || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodeWhitespace"])(code) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$character$40$1$2e$2$2e$0$2f$node_modules$2f$micromark$2d$util$2d$character$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unicodePunctuation"])(code)) && (!email || code !== 47);
}
}),
"[project]/node_modules/.pnpm/decode-named-character-reference@1.2.0/node_modules/decode-named-character-reference/index.dom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/// <reference lib="dom" />
/* global document */ __turbopack_context__.s({
    "decodeNamedCharacterReference": ()=>decodeNamedCharacterReference
});
const element = document.createElement('i');
function decodeNamedCharacterReference(value) {
    const characterReference = '&' + value + ';';
    element.innerHTML = characterReference;
    const character = element.textContent;
    // Some named character references do not require the closing semicolon
    // (`&not`, for instance), which leads to situations where parsing the assumed
    // named reference of `&notit;` will result in the string `¬it;`.
    // When we encounter a trailing semicolon after parsing, and the character
    // reference to decode was not a semicolon (`&semi;`), we can assume that the
    // matching was not complete.
    if (// @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 /* `;` */  && value !== 'semi') {
        return false;
    }
    // If the decoded string is equal to the input, the character reference was
    // not valid.
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    return character === characterReference ? false : character;
}
}),
"[project]/node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.1.0/node_modules/micromark-util-decode-numeric-character-reference/dev/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "decodeNumericCharacterReference": ()=>decodeNumericCharacterReference
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/values.js [app-client] (ecmascript)");
;
;
function decodeNumericCharacterReference(value, base) {
    const code = Number.parseInt(value, base);
    if (// C0 except for HT, LF, FF, CR, space.
    code < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].ht || code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].vt || code > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].cr && code < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].space || code > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].tilde && code < 160 || code > 55295 && code < 57344 || code > 64975 && code < 65008 || /* eslint-disable no-bitwise */ (code & 65535) === 65535 || (code & 65535) === 65534 || /* eslint-enable no-bitwise */ // Out of range
    code > 1114111) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$values$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["values"].replacementCharacter;
    }
    return String.fromCharCode(code);
}
}),
"[project]/node_modules/.pnpm/micromark-util-decode-string@1.1.0/node_modules/micromark-util-decode-string/dev/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "decodeString": ()=>decodeString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$decode$2d$named$2d$character$2d$reference$40$1$2e$2$2e$0$2f$node_modules$2f$decode$2d$named$2d$character$2d$reference$2f$index$2e$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/decode-named-character-reference@1.2.0/node_modules/decode-named-character-reference/index.dom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$decode$2d$numeric$2d$character$2d$reference$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$decode$2d$numeric$2d$character$2d$reference$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.1.0/node_modules/micromark-util-decode-numeric-character-reference/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/codes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-symbol@1.1.0/node_modules/micromark-util-symbol/constants.js [app-client] (ecmascript)");
;
;
;
;
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
    return value.replace(characterEscapeOrReference, decode);
}
/**
 * @param {string} $0
 * @param {string} $1
 * @param {string} $2
 * @returns {string}
 */ function decode($0, $1, $2) {
    if ($1) {
        // Escape.
        return $1;
    }
    // Reference.
    const head = $2.charCodeAt(0);
    if (head === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].numberSign) {
        const head = $2.charCodeAt(1);
        const hex = head === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].lowercaseX || head === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$codes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["codes"].uppercaseX;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$decode$2d$numeric$2d$character$2d$reference$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$decode$2d$numeric$2d$character$2d$reference$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeNumericCharacterReference"])($2.slice(hex ? 2 : 1), hex ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].numericBaseHexadecimal : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$symbol$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$symbol$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constants"].numericBaseDecimal);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$decode$2d$named$2d$character$2d$reference$40$1$2e$2$2e$0$2f$node_modules$2f$decode$2d$named$2d$character$2d$reference$2f$index$2e$dom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeNamedCharacterReference"])($2) || $0;
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/association.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').AssociationId} AssociationId
 */ __turbopack_context__.s({
    "association": ()=>association
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$decode$2d$string$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$decode$2d$string$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-decode-string@1.1.0/node_modules/micromark-util-decode-string/dev/index.js [app-client] (ecmascript)");
;
function association(node) {
    if (node.label || !node.identifier) {
        return node.label || '';
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$decode$2d$string$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$decode$2d$string$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeString"])(node.identifier);
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-flow.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').FlowContent} FlowContent
 * @typedef {import('../types.js').Node} Node
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').TrackFields} TrackFields
 */ /**
 * @param {Parent & {children: Array<FlowContent>}} parent
 *   Parent of flow nodes.
 * @param {State} state
 *   Info passed around about the current state.
 * @param {TrackFields} info
 *   Info on where we are in the document we are generating.
 * @returns {string}
 *   Serialized children, joined by (blank) lines.
 */ __turbopack_context__.s({
    "containerFlow": ()=>containerFlow
});
function containerFlow(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const tracker = state.createTracker(info);
    /** @type {Array<string>} */ const results = [];
    let index = -1;
    indexStack.push(-1);
    while(++index < children.length){
        const child = children[index];
        indexStack[indexStack.length - 1] = index;
        results.push(tracker.move(state.handle(child, parent, state, {
            before: '\n',
            after: '\n',
            ...tracker.current()
        })));
        if (child.type !== 'list') {
            state.bulletLastUsed = undefined;
        }
        if (index < children.length - 1) {
            results.push(tracker.move(between(child, children[index + 1], parent, state)));
        }
    }
    indexStack.pop();
    return results.join('');
}
/**
 * @param {Node} left
 * @param {Node} right
 * @param {Parent} parent
 * @param {State} state
 * @returns {string}
 */ function between(left, right, parent, state) {
    let index = state.join.length;
    while(index--){
        const result = state.join[index](left, right, parent, state);
        if (result === true || result === 1) {
            break;
        }
        if (typeof result === 'number') {
            return '\n'.repeat(1 + result);
        }
        if (result === false) {
            return '\n\n<!---->\n\n';
        }
    }
    return '\n\n';
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').IndentLines} IndentLines
 */ __turbopack_context__.s({
    "indentLines": ()=>indentLines
});
const eol = /\r?\n|\r/g;
function indentLines(value, map) {
    /** @type {Array<string>} */ const result = [];
    let start = 0;
    let line = 0;
    /** @type {RegExpExecArray | null} */ let match;
    while(match = eol.exec(value)){
        one(value.slice(start, match.index));
        result.push(match[0]);
        start = match.index + match[0].length;
        line++;
    }
    one(value.slice(start));
    return result.join('');
    //TURBOPACK unreachable
    ;
    /**
   * @param {string} value
   */ function one(value) {
        result.push(map(value, line, !value));
    }
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').Unsafe} Unsafe
 */ /**
 * @param {Unsafe} pattern
 * @returns {RegExp}
 */ __turbopack_context__.s({
    "patternCompile": ()=>patternCompile
});
function patternCompile(pattern) {
    if (!pattern._compiled) {
        const before = (pattern.atBreak ? '[\\r\\n][\\t ]*' : '') + (pattern.before ? '(?:' + pattern.before + ')' : '');
        pattern._compiled = new RegExp((before ? '(' + before + ')' : '') + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? '\\' : '') + pattern.character + (pattern.after ? '(?:' + pattern.after + ')' : ''), 'g');
    }
    return pattern._compiled;
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').Unsafe} Unsafe
 * @typedef {import('../types.js').ConstructName} ConstructName
 */ /**
 * @param {Array<ConstructName>} stack
 * @param {Unsafe} pattern
 * @returns {boolean}
 */ __turbopack_context__.s({
    "patternInScope": ()=>patternInScope
});
function patternInScope(stack, pattern) {
    return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
/**
 * @param {Array<ConstructName>} stack
 * @param {Unsafe['inConstruct']} list
 * @param {boolean} none
 * @returns {boolean}
 */ function listInScope(stack, list, none) {
    if (typeof list === 'string') {
        list = [
            list
        ];
    }
    if (!list || list.length === 0) {
        return none;
    }
    let index = -1;
    while(++index < list.length){
        if (stack.includes(list[index])) {
            return true;
        }
    }
    return false;
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/safe.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').SafeConfig} SafeConfig
 */ __turbopack_context__.s({
    "safe": ()=>safe
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$pattern$2d$compile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$pattern$2d$in$2d$scope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js [app-client] (ecmascript)");
;
;
function safe(state, input, config) {
    const value = (config.before || '') + (input || '') + (config.after || '');
    /** @type {Array<number>} */ const positions = [];
    /** @type {Array<string>} */ const result = [];
    /** @type {Record<number, {before: boolean, after: boolean}>} */ const infos = {};
    let index = -1;
    while(++index < state.unsafe.length){
        const pattern = state.unsafe[index];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$pattern$2d$in$2d$scope$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["patternInScope"])(state.stack, pattern)) {
            continue;
        }
        const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$pattern$2d$compile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["patternCompile"])(pattern);
        /** @type {RegExpExecArray | null} */ let match;
        while(match = expression.exec(value)){
            const before = 'before' in pattern || Boolean(pattern.atBreak);
            const after = 'after' in pattern;
            const position = match.index + (before ? match[1].length : 0);
            if (positions.includes(position)) {
                if (infos[position].before && !before) {
                    infos[position].before = false;
                }
                if (infos[position].after && !after) {
                    infos[position].after = false;
                }
            } else {
                positions.push(position);
                infos[position] = {
                    before,
                    after
                };
            }
        }
    }
    positions.sort(numerical);
    let start = config.before ? config.before.length : 0;
    const end = value.length - (config.after ? config.after.length : 0);
    index = -1;
    while(++index < positions.length){
        const position = positions[index];
        // Character before or after matched:
        if (position < start || position >= end) {
            continue;
        }
        // If this character is supposed to be escaped because it has a condition on
        // the next character, and the next character is definitly being escaped,
        // then skip this escape.
        if (position + 1 < end && positions[index + 1] === position + 1 && infos[position].after && !infos[position + 1].before && !infos[position + 1].after || positions[index - 1] === position - 1 && infos[position].before && !infos[position - 1].before && !infos[position - 1].after) {
            continue;
        }
        if (start !== position) {
            // If we have to use a character reference, an ampersand would be more
            // correct, but as backslashes only care about punctuation, either will
            // do the trick
            result.push(escapeBackslashes(value.slice(start, position), '\\'));
        }
        start = position;
        if (/[!-/:-@[-`{-~]/.test(value.charAt(position)) && (!config.encode || !config.encode.includes(value.charAt(position)))) {
            // Character escape.
            result.push('\\');
        } else {
            // Character reference.
            result.push('&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';');
            start++;
        }
    }
    result.push(escapeBackslashes(value.slice(start, end), config.after));
    return result.join('');
}
/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */ function numerical(a, b) {
    return a - b;
}
/**
 * @param {string} value
 * @param {string} after
 * @returns {string}
 */ function escapeBackslashes(value, after) {
    const expression = /\\(?=[!-/:-@[-`{-~])/g;
    /** @type {Array<number>} */ const positions = [];
    /** @type {Array<string>} */ const results = [];
    const whole = value + after;
    let index = -1;
    let start = 0;
    /** @type {RegExpExecArray | null} */ let match;
    while(match = expression.exec(whole)){
        positions.push(match.index);
    }
    while(++index < positions.length){
        if (start !== positions[index]) {
            results.push(value.slice(start, positions[index]));
        }
        results.push('\\');
        start = positions[index];
    }
    results.push(value.slice(start));
    return results.join('');
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/track.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').CreateTracker} CreateTracker
 * @typedef {import('../types.js').TrackCurrent} TrackCurrent
 * @typedef {import('../types.js').TrackMove} TrackMove
 * @typedef {import('../types.js').TrackShift} TrackShift
 */ /**
 * Track positional info in the output.
 *
 * @type {CreateTracker}
 */ __turbopack_context__.s({
    "track": ()=>track
});
function track(config) {
    // Defaults are used to prevent crashes when older utilities somehow activate
    // this code.
    /* c8 ignore next 5 */ const options = config || {};
    const now = options.now || {};
    let lineShift = options.lineShift || 0;
    let line = now.line || 1;
    let column = now.column || 1;
    return {
        move,
        current,
        shift
    };
    //TURBOPACK unreachable
    ;
    /**
   * Get the current tracked info.
   *
   * @type {TrackCurrent}
   */ function current() {
        return {
            now: {
                line,
                column
            },
            lineShift
        };
    }
    /**
   * Define an increased line shift (the typical indent for lines).
   *
   * @type {TrackShift}
   */ function shift(value) {
        lineShift += value;
    }
    /**
   * Move past some generated markdown.
   *
   * @type {TrackMove}
   */ function move(input) {
        // eslint-disable-next-line unicorn/prefer-default-parameters
        const value = input || '';
        const chunks = value.split(/\r?\n|\r/g);
        const tail = chunks[chunks.length - 1];
        line += chunks.length - 1;
        column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
        return value;
    }
}
}),
"[project]/node_modules/.pnpm/mdast-util-gfm-footnote@1.0.2/node_modules/mdast-util-gfm-footnote/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').FootnoteReference} FootnoteReference
 * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Map} Map
 */ __turbopack_context__.s({
    "gfmFootnoteFromMarkdown": ()=>gfmFootnoteFromMarkdown,
    "gfmFootnoteToMarkdown": ()=>gfmFootnoteToMarkdown
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-util-normalize-identifier@1.1.0/node_modules/micromark-util-normalize-identifier/dev/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$association$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/association.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$container$2d$flow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-flow.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$indent$2d$lines$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$safe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/safe.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$track$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/track.js [app-client] (ecmascript)");
;
;
;
;
;
;
footnoteReference.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
    return {
        enter: {
            gfmFootnoteDefinition: enterFootnoteDefinition,
            gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
            gfmFootnoteCall: enterFootnoteCall,
            gfmFootnoteCallString: enterFootnoteCallString
        },
        exit: {
            gfmFootnoteDefinition: exitFootnoteDefinition,
            gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
            gfmFootnoteCall: exitFootnoteCall,
            gfmFootnoteCallString: exitFootnoteCallString
        }
    };
}
function gfmFootnoteToMarkdown() {
    return {
        // This is on by default already.
        unsafe: [
            {
                character: '[',
                inConstruct: [
                    'phrasing',
                    'label',
                    'reference'
                ]
            }
        ],
        handlers: {
            footnoteDefinition,
            footnoteReference
        }
    };
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterFootnoteDefinition(token) {
    this.enter({
        type: 'footnoteDefinition',
        identifier: '',
        label: '',
        children: []
    }, token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterFootnoteDefinitionLabelString() {
    this.buffer();
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitFootnoteDefinitionLabelString(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeIdentifier"])(this.sliceSerialize(token)).toLowerCase();
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitFootnoteDefinition(token) {
    this.exit(token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterFootnoteCall(token) {
    this.enter({
        type: 'footnoteReference',
        identifier: '',
        label: ''
    }, token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterFootnoteCallString() {
    this.buffer();
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitFootnoteCallString(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$util$2d$normalize$2d$identifier$40$1$2e$1$2e$0$2f$node_modules$2f$micromark$2d$util$2d$normalize$2d$identifier$2f$dev$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeIdentifier"])(this.sliceSerialize(token)).toLowerCase();
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitFootnoteCall(token) {
    this.exit(token);
}
/**
 * @type {ToMarkdownHandle}
 * @param {FootnoteReference} node
 */ function footnoteReference(node, _, context, safeOptions) {
    const tracker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$track$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["track"])(safeOptions);
    let value = tracker.move('[^');
    const exit = context.enter('footnoteReference');
    const subexit = context.enter('reference');
    value += tracker.move((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$safe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safe"])(context, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$association$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["association"])(node), {
        ...tracker.current(),
        before: value,
        after: ']'
    }));
    subexit();
    exit();
    value += tracker.move(']');
    return value;
}
/** @type {ToMarkdownHandle} */ function footnoteReferencePeek() {
    return '[';
}
/**
 * @type {ToMarkdownHandle}
 * @param {FootnoteDefinition} node
 */ function footnoteDefinition(node, _, context, safeOptions) {
    const tracker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$track$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["track"])(safeOptions);
    let value = tracker.move('[^');
    const exit = context.enter('footnoteDefinition');
    const subexit = context.enter('label');
    value += tracker.move((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$safe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safe"])(context, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$association$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["association"])(node), {
        ...tracker.current(),
        before: value,
        after: ']'
    }));
    subexit();
    value += tracker.move(']:' + (node.children && node.children.length > 0 ? ' ' : ''));
    tracker.shift(4);
    value += tracker.move((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$indent$2d$lines$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["indentLines"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$container$2d$flow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["containerFlow"])(node, context, tracker.current()), map));
    exit();
    return value;
}
/** @type {Map} */ function map(line, index, blank) {
    if (index === 0) {
        return line;
    }
    return (blank ? '' : '    ') + line;
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Info} Info
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').PhrasingContent} PhrasingContent
 * @typedef {import('../types.js').State} State
 */ /**
 * Serialize the children of a parent that contains phrasing children.
 *
 * These children will be joined flush together.
 *
 * @param {Parent & {children: Array<PhrasingContent>}} parent
 *   Parent of flow nodes.
 * @param {State} state
 *   Info passed around about the current state.
 * @param {Info} info
 *   Info on where we are in the document we are generating.
 * @returns {string}
 *   Serialized children, joined together.
 */ __turbopack_context__.s({
    "containerPhrasing": ()=>containerPhrasing
});
function containerPhrasing(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    /** @type {Array<string>} */ const results = [];
    let index = -1;
    let before = info.before;
    indexStack.push(-1);
    let tracker = state.createTracker(info);
    while(++index < children.length){
        const child = children[index];
        /** @type {string} */ let after;
        indexStack[indexStack.length - 1] = index;
        if (index + 1 < children.length) {
            /** @type {Handle} */ // @ts-expect-error: hush, it’s actually a `zwitch`.
            let handle = state.handle.handlers[children[index + 1].type];
            /** @type {Handle} */ // @ts-expect-error: hush, it’s actually a `zwitch`.
            if (handle && handle.peek) handle = handle.peek;
            after = handle ? handle(children[index + 1], parent, state, {
                before: '',
                after: '',
                ...tracker.current()
            }).charAt(0) : '';
        } else {
            after = info.after;
        }
        // In some cases, html (text) can be found in phrasing right after an eol.
        // When we’d serialize that, in most cases that would be seen as html
        // (flow).
        // As we can’t escape or so to prevent it from happening, we take a somewhat
        // reasonable approach: replace that eol with a space.
        // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>
        if (results.length > 0 && (before === '\r' || before === '\n') && child.type === 'html') {
            results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, ' ');
            before = ' ';
            // To do: does this work to reset tracker?
            tracker = state.createTracker(info);
            tracker.move(results.join(''));
        }
        results.push(tracker.move(state.handle(child, parent, state, {
            ...tracker.current(),
            before,
            after
        })));
        before = results[results.length - 1].slice(-1);
    }
    indexStack.pop();
    return results.join('');
}
}),
"[project]/node_modules/.pnpm/mdast-util-gfm-strikethrough@1.0.3/node_modules/mdast-util-gfm-strikethrough/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').Delete} Delete
 *
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 *
 * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 */ __turbopack_context__.s({
    "gfmStrikethroughFromMarkdown": ()=>gfmStrikethroughFromMarkdown,
    "gfmStrikethroughToMarkdown": ()=>gfmStrikethroughToMarkdown
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$container$2d$phrasing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$track$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/track.js [app-client] (ecmascript)");
;
;
// To do: next major: expose functions.
// To do: next major: use `state`, state utilities.
/**
 * List of constructs that occur in phrasing (paragraphs, headings), but cannot
 * contain strikethrough.
 * So they sort of cancel each other out.
 * Note: could use a better name.
 *
 * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>
 *
 * @type {Array<ConstructName>}
 */ const constructsWithoutStrikethrough = [
    'autolink',
    'destinationLiteral',
    'destinationRaw',
    'reference',
    'titleQuote',
    'titleApostrophe'
];
handleDelete.peek = peekDelete;
const gfmStrikethroughFromMarkdown = {
    canContainEols: [
        'delete'
    ],
    enter: {
        strikethrough: enterStrikethrough
    },
    exit: {
        strikethrough: exitStrikethrough
    }
};
const gfmStrikethroughToMarkdown = {
    unsafe: [
        {
            character: '~',
            inConstruct: 'phrasing',
            notInConstruct: constructsWithoutStrikethrough
        }
    ],
    handlers: {
        delete: handleDelete
    }
};
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterStrikethrough(token) {
    this.enter({
        type: 'delete',
        children: []
    }, token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitStrikethrough(token) {
    this.exit(token);
}
/**
 * @type {ToMarkdownHandle}
 * @param {Delete} node
 */ function handleDelete(node, _, context, safeOptions) {
    const tracker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$track$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["track"])(safeOptions);
    const exit = context.enter('strikethrough');
    let value = tracker.move('~~');
    value += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$container$2d$phrasing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["containerPhrasing"])(node, context, {
        ...tracker.current(),
        before: value,
        after: '~'
    });
    value += tracker.move('~~');
    exit();
    return value;
}
/** @type {ToMarkdownHandle} */ function peekDelete() {
    return '~';
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').State} State
 */ __turbopack_context__.s({
    "inlineCode": ()=>inlineCode
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$pattern$2d$compile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js [app-client] (ecmascript)");
;
inlineCode.peek = inlineCodePeek;
function inlineCode(node, _, state) {
    let value = node.value || '';
    let sequence = '`';
    let index = -1;
    // If there is a single grave accent on its own in the code, use a fence of
    // two.
    // If there are two in a row, use one.
    while(new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)){
        sequence += '`';
    }
    // If this is not just spaces or eols (tabs don’t count), and either the
    // first or last character are a space, eol, or tick, then pad with spaces.
    if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
        value = ' ' + value + ' ';
    }
    // We have a potential problem: certain characters after eols could result in
    // blocks being seen.
    // For example, if someone injected the string `'\n# b'`, then that would
    // result in an ATX heading.
    // We can’t escape characters in `inlineCode`, but because eols are
    // transformed to spaces when going from markdown to HTML anyway, we can swap
    // them out.
    while(++index < state.unsafe.length){
        const pattern = state.unsafe[index];
        const expression = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$pattern$2d$compile$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["patternCompile"])(pattern);
        /** @type {RegExpExecArray | null} */ let match;
        // Only look for `atBreak`s.
        // Btw: note that `atBreak` patterns will always start the regex at LF or
        // CR.
        if (!pattern.atBreak) continue;
        while(match = expression.exec(value)){
            let position = match.index;
            // Support CRLF (patterns only look for one of the characters).
            if (value.charCodeAt(position) === 10 /* `\n` */  && value.charCodeAt(position - 1) === 13 /* `\r` */ ) {
                position--;
            }
            value = value.slice(0, position) + ' ' + value.slice(match.index + 1);
        }
    }
    return sequence + value + sequence;
}
/**
 * @returns {string}
 */ function inlineCodePeek() {
    return '`';
}
}),
"[project]/node_modules/.pnpm/markdown-table@3.0.4/node_modules/markdown-table/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// To do: next major: remove.
/**
 * @typedef {Options} MarkdownTableOptions
 *   Configuration.
 */ /**
 * @typedef Options
 *   Configuration.
 * @property {boolean | null | undefined} [alignDelimiters=true]
 *   Whether to align the delimiters (default: `true`);
 *   they are aligned by default:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   Pass `false` to make them staggered:
 *
 *   ```markdown
 *   | Alpha | B |
 *   | - | - |
 *   | C | Delta |
 *   ```
 * @property {ReadonlyArray<string | null | undefined> | string | null | undefined} [align]
 *   How to align columns (default: `''`);
 *   one style for all columns or styles for their respective columns;
 *   each style is either `'l'` (left), `'r'` (right), or `'c'` (center);
 *   other values are treated as `''`, which doesn’t place the colon in the
 *   alignment row but does align left;
 *   *only the lowercased first character is used, so `Right` is fine.*
 * @property {boolean | null | undefined} [delimiterEnd=true]
 *   Whether to end each row with the delimiter (default: `true`).
 *
 *   > 👉 **Note**: please don’t use this: it could create fragile structures
 *   > that aren’t understandable to some markdown parsers.
 *
 *   When `true`, there are ending delimiters:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there are no ending delimiters:
 *
 *   ```markdown
 *   | Alpha | B
 *   | ----- | -----
 *   | C     | Delta
 *   ```
 * @property {boolean | null | undefined} [delimiterStart=true]
 *   Whether to begin each row with the delimiter (default: `true`).
 *
 *   > 👉 **Note**: please don’t use this: it could create fragile structures
 *   > that aren’t understandable to some markdown parsers.
 *
 *   When `true`, there are starting delimiters:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there are no starting delimiters:
 *
 *   ```markdown
 *   Alpha | B     |
 *   ----- | ----- |
 *   C     | Delta |
 *   ```
 * @property {boolean | null | undefined} [padding=true]
 *   Whether to add a space of padding between delimiters and cells
 *   (default: `true`).
 *
 *   When `true`, there is padding:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there is no padding:
 *
 *   ```markdown
 *   |Alpha|B    |
 *   |-----|-----|
 *   |C    |Delta|
 *   ```
 * @property {((value: string) => number) | null | undefined} [stringLength]
 *   Function to detect the length of table cell content (optional);
 *   this is used when aligning the delimiters (`|`) between table cells;
 *   full-width characters and emoji mess up delimiter alignment when viewing
 *   the markdown source;
 *   to fix this, you can pass this function,
 *   which receives the cell content and returns its “visible” size;
 *   note that what is and isn’t visible depends on where the text is displayed.
 *
 *   Without such a function, the following:
 *
 *   ```js
 *   markdownTable([
 *     ['Alpha', 'Bravo'],
 *     ['中文', 'Charlie'],
 *     ['👩‍❤️‍👩', 'Delta']
 *   ])
 *   ```
 *
 *   Yields:
 *
 *   ```markdown
 *   | Alpha | Bravo |
 *   | - | - |
 *   | 中文 | Charlie |
 *   | 👩‍❤️‍👩 | Delta |
 *   ```
 *
 *   With [`string-width`](https://github.com/sindresorhus/string-width):
 *
 *   ```js
 *   import stringWidth from 'string-width'
 *
 *   markdownTable(
 *     [
 *       ['Alpha', 'Bravo'],
 *       ['中文', 'Charlie'],
 *       ['👩‍❤️‍👩', 'Delta']
 *     ],
 *     {stringLength: stringWidth}
 *   )
 *   ```
 *
 *   Yields:
 *
 *   ```markdown
 *   | Alpha | Bravo   |
 *   | ----- | ------- |
 *   | 中文  | Charlie |
 *   | 👩‍❤️‍👩    | Delta   |
 *   ```
 */ /**
 * @param {string} value
 *   Cell value.
 * @returns {number}
 *   Cell size.
 */ __turbopack_context__.s({
    "markdownTable": ()=>markdownTable
});
function defaultStringLength(value) {
    return value.length;
}
function markdownTable(table, options) {
    const settings = options || {};
    // To do: next major: change to spread.
    const align = (settings.align || []).concat();
    const stringLength = settings.stringLength || defaultStringLength;
    /** @type {Array<number>} Character codes as symbols for alignment per column. */ const alignments = [];
    /** @type {Array<Array<string>>} Cells per row. */ const cellMatrix = [];
    /** @type {Array<Array<number>>} Sizes of each cell per row. */ const sizeMatrix = [];
    /** @type {Array<number>} */ const longestCellByColumn = [];
    let mostCellsPerRow = 0;
    let rowIndex = -1;
    // This is a superfluous loop if we don’t align delimiters, but otherwise we’d
    // do superfluous work when aligning, so optimize for aligning.
    while(++rowIndex < table.length){
        /** @type {Array<string>} */ const row = [];
        /** @type {Array<number>} */ const sizes = [];
        let columnIndex = -1;
        if (table[rowIndex].length > mostCellsPerRow) {
            mostCellsPerRow = table[rowIndex].length;
        }
        while(++columnIndex < table[rowIndex].length){
            const cell = serialize(table[rowIndex][columnIndex]);
            if (settings.alignDelimiters !== false) {
                const size = stringLength(cell);
                sizes[columnIndex] = size;
                if (longestCellByColumn[columnIndex] === undefined || size > longestCellByColumn[columnIndex]) {
                    longestCellByColumn[columnIndex] = size;
                }
            }
            row.push(cell);
        }
        cellMatrix[rowIndex] = row;
        sizeMatrix[rowIndex] = sizes;
    }
    // Figure out which alignments to use.
    let columnIndex = -1;
    if (typeof align === 'object' && 'length' in align) {
        while(++columnIndex < mostCellsPerRow){
            alignments[columnIndex] = toAlignment(align[columnIndex]);
        }
    } else {
        const code = toAlignment(align);
        while(++columnIndex < mostCellsPerRow){
            alignments[columnIndex] = code;
        }
    }
    // Inject the alignment row.
    columnIndex = -1;
    /** @type {Array<string>} */ const row = [];
    /** @type {Array<number>} */ const sizes = [];
    while(++columnIndex < mostCellsPerRow){
        const code = alignments[columnIndex];
        let before = '';
        let after = '';
        if (code === 99 /* `c` */ ) {
            before = ':';
            after = ':';
        } else if (code === 108 /* `l` */ ) {
            before = ':';
        } else if (code === 114 /* `r` */ ) {
            after = ':';
        }
        // There *must* be at least one hyphen-minus in each alignment cell.
        let size = settings.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);
        const cell = before + '-'.repeat(size) + after;
        if (settings.alignDelimiters !== false) {
            size = before.length + size + after.length;
            if (size > longestCellByColumn[columnIndex]) {
                longestCellByColumn[columnIndex] = size;
            }
            sizes[columnIndex] = size;
        }
        row[columnIndex] = cell;
    }
    // Inject the alignment row.
    cellMatrix.splice(1, 0, row);
    sizeMatrix.splice(1, 0, sizes);
    rowIndex = -1;
    /** @type {Array<string>} */ const lines = [];
    while(++rowIndex < cellMatrix.length){
        const row = cellMatrix[rowIndex];
        const sizes = sizeMatrix[rowIndex];
        columnIndex = -1;
        /** @type {Array<string>} */ const line = [];
        while(++columnIndex < mostCellsPerRow){
            const cell = row[columnIndex] || '';
            let before = '';
            let after = '';
            if (settings.alignDelimiters !== false) {
                const size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
                const code = alignments[columnIndex];
                if (code === 114 /* `r` */ ) {
                    before = ' '.repeat(size);
                } else if (code === 99 /* `c` */ ) {
                    if (size % 2) {
                        before = ' '.repeat(size / 2 + 0.5);
                        after = ' '.repeat(size / 2 - 0.5);
                    } else {
                        before = ' '.repeat(size / 2);
                        after = before;
                    }
                } else {
                    after = ' '.repeat(size);
                }
            }
            if (settings.delimiterStart !== false && !columnIndex) {
                line.push('|');
            }
            if (settings.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
            // empty: there will be a closing space.
            !(settings.alignDelimiters === false && cell === '') && (settings.delimiterStart !== false || columnIndex)) {
                line.push(' ');
            }
            if (settings.alignDelimiters !== false) {
                line.push(before);
            }
            line.push(cell);
            if (settings.alignDelimiters !== false) {
                line.push(after);
            }
            if (settings.padding !== false) {
                line.push(' ');
            }
            if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
                line.push('|');
            }
        }
        lines.push(settings.delimiterEnd === false ? line.join('').replace(/ +$/, '') : line.join(''));
    }
    return lines.join('\n');
}
/**
 * @param {string | null | undefined} [value]
 *   Value to serialize.
 * @returns {string}
 *   Result.
 */ function serialize(value) {
    return value === null || value === undefined ? '' : String(value);
}
/**
 * @param {string | null | undefined} value
 *   Value.
 * @returns {number}
 *   Alignment.
 */ function toAlignment(value) {
    const code = typeof value === 'string' ? value.codePointAt(0) : 0;
    return code === 67 /* `C` */  || code === 99 /* `c` */  ? 99 /* `c` */  : code === 76 /* `L` */  || code === 108 /* `l` */  ? 108 /* `l` */  : code === 82 /* `R` */  || code === 114 /* `r` */  ? 114 /* `r` */  : 0;
}
}),
"[project]/node_modules/.pnpm/mdast-util-gfm-table@1.0.7/node_modules/mdast-util-gfm-table/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').Table} Table
 * @typedef {import('mdast').TableRow} TableRow
 * @typedef {import('mdast').TableCell} TableCell
 * @typedef {import('mdast').InlineCode} InlineCode
 *
 * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions
 *
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 *
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext
 * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions
 */ /**
 * @typedef Options
 *   Configuration.
 * @property {boolean | null | undefined} [tableCellPadding=true]
 *   Whether to add a space of padding between delimiters and cells.
 * @property {boolean | null | undefined} [tablePipeAlign=true]
 *   Whether to align the delimiters.
 * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]
 *   Function to detect the length of table cell content, used when aligning
 *   the delimiters between cells
 */ __turbopack_context__.s({
    "gfmTableFromMarkdown": ()=>gfmTableFromMarkdown,
    "gfmTableToMarkdown": ()=>gfmTableToMarkdown
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$container$2d$phrasing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$handle$2f$inline$2d$code$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$markdown$2d$table$40$3$2e$0$2e$4$2f$node_modules$2f$markdown$2d$table$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/markdown-table@3.0.4/node_modules/markdown-table/index.js [app-client] (ecmascript)");
;
;
;
const gfmTableFromMarkdown = {
    enter: {
        table: enterTable,
        tableData: enterCell,
        tableHeader: enterCell,
        tableRow: enterRow
    },
    exit: {
        codeText: exitCodeText,
        table: exitTable,
        tableData: exit,
        tableHeader: exit,
        tableRow: exit
    }
};
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterTable(token) {
    /** @type {Array<'left' | 'right' | 'center' | 'none'>} */ // @ts-expect-error: `align` is custom.
    const align = token._align;
    this.enter({
        type: 'table',
        align: align.map((d)=>d === 'none' ? null : d),
        children: []
    }, token);
    this.setData('inTable', true);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitTable(token) {
    this.exit(token);
    this.setData('inTable');
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterRow(token) {
    this.enter({
        type: 'tableRow',
        children: []
    }, token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exit(token) {
    this.exit(token);
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function enterCell(token) {
    this.enter({
        type: 'tableCell',
        children: []
    }, token);
}
// Overwrite the default code text data handler to unescape escaped pipes when
// they are in tables.
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitCodeText(token) {
    let value = this.resume();
    if (this.getData('inTable')) {
        value = value.replace(/\\([\\|])/g, replace);
    }
    const node = this.stack[this.stack.length - 1];
    node.value = value;
    this.exit(token);
}
/**
 * @param {string} $0
 * @param {string} $1
 * @returns {string}
 */ function replace($0, $1) {
    // Pipes work, backslashes don’t (but can’t escape pipes).
    return $1 === '|' ? $1 : $0;
}
function gfmTableToMarkdown(options) {
    const settings = options || {};
    const padding = settings.tableCellPadding;
    const alignDelimiters = settings.tablePipeAlign;
    const stringLength = settings.stringLength;
    const around = padding ? ' ' : '|';
    return {
        unsafe: [
            {
                character: '\r',
                inConstruct: 'tableCell'
            },
            {
                character: '\n',
                inConstruct: 'tableCell'
            },
            // A pipe, when followed by a tab or space (padding), or a dash or colon
            // (unpadded delimiter row), could result in a table.
            {
                atBreak: true,
                character: '|',
                after: '[\t :-]'
            },
            // A pipe in a cell must be encoded.
            {
                character: '|',
                inConstruct: 'tableCell'
            },
            // A colon must be followed by a dash, in which case it could start a
            // delimiter row.
            {
                atBreak: true,
                character: ':',
                after: '-'
            },
            // A delimiter row can also start with a dash, when followed by more
            // dashes, a colon, or a pipe.
            // This is a stricter version than the built in check for lists, thematic
            // breaks, and setex heading underlines though:
            // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
            {
                atBreak: true,
                character: '-',
                after: '[:|-]'
            }
        ],
        handlers: {
            table: handleTable,
            tableRow: handleTableRow,
            tableCell: handleTableCell,
            inlineCode: inlineCodeWithTable
        }
    };
    //TURBOPACK unreachable
    ;
    /**
   * @type {ToMarkdownHandle}
   * @param {Table} node
   */ function handleTable(node, _, context, safeOptions) {
        return serializeData(handleTableAsData(node, context, safeOptions), node.align);
    }
    /**
   * This function isn’t really used normally, because we handle rows at the
   * table level.
   * But, if someone passes in a table row, this ensures we make somewhat sense.
   *
   * @type {ToMarkdownHandle}
   * @param {TableRow} node
   */ function handleTableRow(node, _, context, safeOptions) {
        const row = handleTableRowAsData(node, context, safeOptions);
        const value = serializeData([
            row
        ]);
        // `markdown-table` will always add an align row
        return value.slice(0, value.indexOf('\n'));
    }
    /**
   * @type {ToMarkdownHandle}
   * @param {TableCell} node
   */ function handleTableCell(node, _, context, safeOptions) {
        const exit = context.enter('tableCell');
        const subexit = context.enter('phrasing');
        const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$container$2d$phrasing$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["containerPhrasing"])(node, context, {
            ...safeOptions,
            before: around,
            after: around
        });
        subexit();
        exit();
        return value;
    }
    /**
   * @param {Array<Array<string>>} matrix
   * @param {Array<string | null | undefined> | null | undefined} [align]
   */ function serializeData(matrix, align) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$markdown$2d$table$40$3$2e$0$2e$4$2f$node_modules$2f$markdown$2d$table$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["markdownTable"])(matrix, {
            align,
            // @ts-expect-error: `markdown-table` types should support `null`.
            alignDelimiters,
            // @ts-expect-error: `markdown-table` types should support `null`.
            padding,
            // @ts-expect-error: `markdown-table` types should support `null`.
            stringLength
        });
    }
    /**
   * @param {Table} node
   * @param {ToMarkdownContext} context
   * @param {SafeOptions} safeOptions
   */ function handleTableAsData(node, context, safeOptions) {
        const children = node.children;
        let index = -1;
        /** @type {Array<Array<string>>} */ const result = [];
        const subexit = context.enter('table');
        while(++index < children.length){
            result[index] = handleTableRowAsData(children[index], context, safeOptions);
        }
        subexit();
        return result;
    }
    /**
   * @param {TableRow} node
   * @param {ToMarkdownContext} context
   * @param {SafeOptions} safeOptions
   */ function handleTableRowAsData(node, context, safeOptions) {
        const children = node.children;
        let index = -1;
        /** @type {Array<string>} */ const result = [];
        const subexit = context.enter('tableRow');
        while(++index < children.length){
            // Note: the positional info as used here is incorrect.
            // Making it correct would be impossible due to aligning cells?
            // And it would need copy/pasting `markdown-table` into this project.
            result[index] = handleTableCell(children[index], node, context, safeOptions);
        }
        subexit();
        return result;
    }
    /**
   * @type {ToMarkdownHandle}
   * @param {InlineCode} node
   */ function inlineCodeWithTable(node, parent, context) {
        let value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$handle$2f$inline$2d$code$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inlineCode"])(node, parent, context);
        if (context.stack.includes('tableCell')) {
            value = value.replace(/\|/g, '\\$&');
        }
        return value;
    }
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').Options} Options
 */ /**
 * @param {State} state
 * @returns {Exclude<Options['bullet'], null | undefined>}
 */ __turbopack_context__.s({
    "checkBullet": ()=>checkBullet
});
function checkBullet(state) {
    const marker = state.options.bullet || '*';
    if (marker !== '*' && marker !== '+' && marker !== '-') {
        throw new Error('Cannot serialize items with `' + marker + '` for `options.bullet`, expected `*`, `+`, or `-`');
    }
    return marker;
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').Options} Options
 */ /**
 * @param {State} state
 * @returns {Exclude<Options['listItemIndent'], null | undefined>}
 */ __turbopack_context__.s({
    "checkListItemIndent": ()=>checkListItemIndent
});
function checkListItemIndent(state) {
    const style = state.options.listItemIndent || 'tab';
    // To do: remove in a major.
    // @ts-expect-error: deprecated.
    if (style === 1 || style === '1') {
        return 'one';
    }
    if (style !== 'tab' && style !== 'one' && style !== 'mixed') {
        throw new Error('Cannot serialize items with `' + style + '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`');
    }
    return style;
}
}),
"[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/list-item.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('../types.js').Map} Map
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').Info} Info
 */ __turbopack_context__.s({
    "listItem": ()=>listItem
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$check$2d$bullet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$check$2d$list$2d$item$2d$indent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js [app-client] (ecmascript)");
;
;
function listItem(node, parent, state, info) {
    const listItemIndent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$check$2d$list$2d$item$2d$indent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkListItemIndent"])(state);
    let bullet = state.bulletCurrent || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$check$2d$bullet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkBullet"])(state);
    // Add the marker value for ordered lists.
    if (parent && parent.type === 'list' && parent.ordered) {
        bullet = (typeof parent.start === 'number' && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + bullet;
    }
    let size = bullet.length + 1;
    if (listItemIndent === 'tab' || listItemIndent === 'mixed' && (parent && parent.type === 'list' && parent.spread || node.spread)) {
        size = Math.ceil(size / 4) * 4;
    }
    const tracker = state.createTracker(info);
    tracker.move(bullet + ' '.repeat(size - bullet.length));
    tracker.shift(size);
    const exit = state.enter('listItem');
    const value = state.indentLines(state.containerFlow(node, tracker.current()), map);
    exit();
    return value;
    //TURBOPACK unreachable
    ;
    /** @type {Map} */ function map(line, index, blank) {
        if (index) {
            return (blank ? '' : ' '.repeat(size)) + line;
        }
        return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line;
    }
}
}),
"[project]/node_modules/.pnpm/mdast-util-gfm-task-list-item@1.0.2/node_modules/mdast-util-gfm-task-list-item/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('mdast').Parent} Parent
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 */ /**
 * @typedef {Extract<Root | Content, Parent>} Parents
 */ __turbopack_context__.s({
    "gfmTaskListItemFromMarkdown": ()=>gfmTaskListItemFromMarkdown,
    "gfmTaskListItemToMarkdown": ()=>gfmTaskListItemToMarkdown
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$handle$2f$list$2d$item$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/list-item.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$track$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/track.js [app-client] (ecmascript)");
;
;
const gfmTaskListItemFromMarkdown = {
    exit: {
        taskListCheckValueChecked: exitCheck,
        taskListCheckValueUnchecked: exitCheck,
        paragraph: exitParagraphWithTaskListItem
    }
};
const gfmTaskListItemToMarkdown = {
    unsafe: [
        {
            atBreak: true,
            character: '-',
            after: '[:|-]'
        }
    ],
    handlers: {
        listItem: listItemWithTaskListItem
    }
};
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitCheck(token) {
    const node = this.stack[this.stack.length - 2];
    // We’re always in a paragraph, in a list item.
    node.checked = token.type === 'taskListCheckValueChecked';
}
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */ function exitParagraphWithTaskListItem(token) {
    const parent = this.stack[this.stack.length - 2];
    if (parent && parent.type === 'listItem' && typeof parent.checked === 'boolean') {
        const node = this.stack[this.stack.length - 1];
        const head = node.children[0];
        if (head && head.type === 'text') {
            const siblings = parent.children;
            let index = -1;
            /** @type {Paragraph | undefined} */ let firstParaghraph;
            while(++index < siblings.length){
                const sibling = siblings[index];
                if (sibling.type === 'paragraph') {
                    firstParaghraph = sibling;
                    break;
                }
            }
            if (firstParaghraph === node) {
                // Must start with a space or a tab.
                head.value = head.value.slice(1);
                if (head.value.length === 0) {
                    node.children.shift();
                } else if (node.position && head.position && typeof head.position.start.offset === 'number') {
                    head.position.start.column++;
                    head.position.start.offset++;
                    node.position.start = Object.assign({}, head.position.start);
                }
            }
        }
    }
    this.exit(token);
}
/**
 * @type {ToMarkdownHandle}
 * @param {ListItem} node
 */ function listItemWithTaskListItem(node, parent, context, safeOptions) {
    const head = node.children[0];
    const checkable = typeof node.checked === 'boolean' && head && head.type === 'paragraph';
    const checkbox = '[' + (node.checked ? 'x' : ' ') + '] ';
    const tracker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$util$2f$track$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["track"])(safeOptions);
    if (checkable) {
        tracker.move(checkbox);
    }
    let value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$to$2d$markdown$40$1$2e$5$2e$0$2f$node_modules$2f$mdast$2d$util$2d$to$2d$markdown$2f$lib$2f$handle$2f$list$2d$item$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["listItem"])(node, parent, context, {
        ...safeOptions,
        ...tracker.current()
    });
    if (checkable) {
        value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
    }
    return value;
    //TURBOPACK unreachable
    ;
    /**
   * @param {string} $0
   * @returns {string}
   */ function check($0) {
        return $0 + checkbox;
    }
}
}),
"[project]/node_modules/.pnpm/mdast-util-gfm@2.0.2/node_modules/mdast-util-gfm/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 */ /**
 * @typedef {import('mdast-util-gfm-table').Options} Options
 *   Configuration.
 */ __turbopack_context__.s({
    "gfmFromMarkdown": ()=>gfmFromMarkdown,
    "gfmToMarkdown": ()=>gfmToMarkdown
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$autolink$2d$literal$40$1$2e$0$2e$3$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$autolink$2d$literal$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-gfm-autolink-literal@1.0.3/node_modules/mdast-util-gfm-autolink-literal/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$footnote$40$1$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$footnote$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-gfm-footnote@1.0.2/node_modules/mdast-util-gfm-footnote/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$strikethrough$40$1$2e$0$2e$3$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$strikethrough$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-gfm-strikethrough@1.0.3/node_modules/mdast-util-gfm-strikethrough/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$table$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-gfm-table@1.0.7/node_modules/mdast-util-gfm-table/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$task$2d$list$2d$item$40$1$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$task$2d$list$2d$item$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-gfm-task-list-item@1.0.2/node_modules/mdast-util-gfm-task-list-item/lib/index.js [app-client] (ecmascript)");
;
;
;
;
;
function gfmFromMarkdown() {
    return [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$autolink$2d$literal$40$1$2e$0$2e$3$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$autolink$2d$literal$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmAutolinkLiteralFromMarkdown"],
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$footnote$40$1$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$footnote$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmFootnoteFromMarkdown"])(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$strikethrough$40$1$2e$0$2e$3$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$strikethrough$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmStrikethroughFromMarkdown"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$table$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTableFromMarkdown"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$task$2d$list$2d$item$40$1$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$task$2d$list$2d$item$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTaskListItemFromMarkdown"]
    ];
}
function gfmToMarkdown(options) {
    return {
        extensions: [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$autolink$2d$literal$40$1$2e$0$2e$3$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$autolink$2d$literal$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmAutolinkLiteralToMarkdown"],
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$footnote$40$1$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$footnote$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmFootnoteToMarkdown"])(),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$strikethrough$40$1$2e$0$2e$3$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$strikethrough$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmStrikethroughToMarkdown"],
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$table$40$1$2e$0$2e$7$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$table$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTableToMarkdown"])(options),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$2d$task$2d$list$2d$item$40$1$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2d$task$2d$list$2d$item$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmTaskListItemToMarkdown"]
        ]
    };
}
}),
"[project]/node_modules/.pnpm/remark-gfm@3.0.1/node_modules/remark-gfm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options
 */ __turbopack_context__.s({
    "default": ()=>remarkGfm
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$40$2$2e$0$2e$3$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/micromark-extension-gfm@2.0.3/node_modules/micromark-extension-gfm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$40$2$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/mdast-util-gfm@2.0.2/node_modules/mdast-util-gfm/lib/index.js [app-client] (ecmascript)");
;
;
function remarkGfm() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const data = this.data();
    add('micromarkExtensions', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$micromark$2d$extension$2d$gfm$40$2$2e$0$2e$3$2f$node_modules$2f$micromark$2d$extension$2d$gfm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfm"])(options));
    add('fromMarkdownExtensions', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$40$2$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmFromMarkdown"])());
    add('toMarkdownExtensions', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$mdast$2d$util$2d$gfm$40$2$2e$0$2e$2$2f$node_modules$2f$mdast$2d$util$2d$gfm$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gfmToMarkdown"])(options));
    /**
   * @param {string} field
   * @param {unknown} value
   */ function add(field, value) {
        const list = // Other extensions
        /* c8 ignore next 2 */ data[field] ? data[field] : data[field] = [];
        list.push(value);
    }
}
}),
}]);

//# sourceMappingURL=node_modules__pnpm_261f5f08._.js.map