{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/utils.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/options.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/unicode.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/tokenize.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/utils-ast.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/traverse.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/parse.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/transform.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/generate.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/subclass.js","file:///C:/Hyperverge/sensai-frontend/node_modules/.pnpm/oniguruma-to-es%402.3.0/node_modules/oniguruma-to-es/src/index.js"],"sourcesContent":["import {EsVersion, Target} from './options.js';\n\nconst cp = String.fromCodePoint;\nconst r = String.raw;\n\nconst envSupportsFlagGroups = (() => {\n  try {\n    new RegExp('(?i:)');\n  } catch {\n    return false;\n  }\n  return true;\n})();\n\nconst envSupportsFlagV = (() => {\n  try {\n    new RegExp('', 'v');\n  } catch {\n    return false;\n  }\n  return true;\n})();\n\nfunction getNewCurrentFlags(current, {enable, disable}) {\n  return {\n    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase),\n  };\n}\n\nfunction getOrCreate(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\n\n/**\n@param {keyof Target} target\n@param {keyof Target} min\n@returns {boolean}\n*/\nfunction isMinTarget(target, min) {\n  return EsVersion[target] >= EsVersion[min];\n}\n\nfunction throwIfNot(value, msg) {\n  if (!value) {\n    throw new Error(msg ?? 'Value expected');\n  }\n  return value;\n}\n\nexport {\n  cp,\n  envSupportsFlagGroups,\n  envSupportsFlagV,\n  getNewCurrentFlags,\n  getOrCreate,\n  isMinTarget,\n  r,\n  throwIfNot,\n};\n","import {envSupportsFlagGroups, envSupportsFlagV} from './utils.js';\n\nconst Accuracy = /** @type {const} */ ({\n  default: 'default',\n  strict: 'strict',\n});\n\nconst EsVersion = {\n  ES2025: 2025,\n  ES2024: 2024,\n  ES2018: 2018,\n};\n\nconst Target = /** @type {const} */ ({\n  auto: 'auto',\n  ES2025: 'ES2025',\n  ES2024: 'ES2024',\n  ES2018: 'ES2018',\n});\n\n/**\nReturns a complete set of options, with default values set for options that weren't provided.\n@param {import('.').OnigurumaToEsOptions} [options]\n@returns {Required<import('.').OnigurumaToEsOptions>}\n*/\nfunction getOptions(options) {\n  if (options?.target !== undefined && !Target[options.target]) {\n    throw new Error(`Unexpected target \"${options.target}\"`)\n  }\n  // Set default values\n  const opts = {\n    // Sets the level of emulation rigor/strictness.\n    accuracy: 'default',\n    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n    // certain patterns not being emulatable.\n    avoidSubclass: false,\n    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W` in any order (all optional).\n    // Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n    flags: '',\n    // Include JavaScript flag `g` (`global`) in the result.\n    global: false,\n    // Include JavaScript flag `d` (`hasIndices`) in the result.\n    hasIndices: false,\n    // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n    // your environment. Later targets allow faster processing, simpler generated source, and\n    // support for additional features.\n    target: 'auto',\n    // Disables optimizations that simplify the pattern when it doesn't change the meaning.\n    verbose: false,\n    ...options,\n    // Advanced options that override standard behavior, error checking, and flags when enabled.\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns.\n      allowOrphanBackrefs: false,\n      // Use ASCII-based `\\b` and `\\B`, which increases search performance of generated regexes.\n      asciiWordBoundaries: false,\n      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in\n      // `vscode-oniguruma`.\n      captureGroup: false,\n      // Change the recursion depth limit from Oniguruma's `20` to an integer `2`–`20`.\n      recursionLimit: 20,\n      // `^` as `\\A`; `$` as`\\Z`. Improves search performance of generated regexes without changing\n      // meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.\n      singleline: false,\n      ...(options?.rules),\n    },\n  };\n  if (opts.target === 'auto') {\n    opts.target = envSupportsFlagGroups ? 'ES2025' : (envSupportsFlagV ? 'ES2024' : 'ES2018');\n  }\n  return opts;\n}\n\nexport {\n  Accuracy,\n  EsVersion,\n  getOptions,\n  Target,\n};\n","import {cp, r} from './utils.js';\n\nconst CharsWithoutIgnoreCaseExpansion = new Set([\n  cp(0x130), // İ\n  cp(0x131), // ı\n]);\n\nfunction getIgnoreCaseMatchChars(char) {\n  // Some chars should not match the chars they case swap to\n  if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n    return [char];\n  }\n  const set = new Set();\n  const lower = char.toLowerCase();\n  // Everything else is based on `lower`\n  const upper = lower.toUpperCase();\n  const title = LowerToTitleCaseMap.get(lower);\n  const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n  // Exclude ucase if multiple chars; count code point length. Excludes ucase versions of German\n  // es-zed 'ß', ligatures like 'ﬀ', and chars with no precomposed ucase like 'ŉ'. See\n  // <unicode.org/Public/UNIDATA/SpecialCasing.txt>\n  if ([...upper].length === 1) {\n    set.add(upper);\n  }\n  altUpper && set.add(altUpper);\n  title && set.add(title);\n  // Lcase of 'İ' is multiple chars, but it's excluded by `CharsWithoutIgnoreCaseExpansion`\n  set.add(lower);\n  altLower && set.add(altLower);\n  return [...set];\n}\n\n// The following set includes:\n// - All ES2024 general categories and their aliases (all are supported by Oniguruma). See\n//   <github.com/mathiasbynens/unicode-match-property-value-ecmascript/blob/main/data/mappings.js>\n// - All ES2024 binary properties and their aliases (all are supported by Oniguruma). See\n//   <tc39.es/ecma262/multipage/text-processing.html#table-binary-unicode-properties>\n// Unicode properties must be mapped to property names supported by JS, and must also apply JS's\n// stricter rules for casing, whitespace, and underscores in Unicode property names. In order to\n// remain lightweight, this library assumes properties not in this list are Unicode script names\n// (which require a `Script=` or `sc=` prefix in JS). Unlike JS, Oniguruma doesn't support script\n// extensions, and it supports some properties that aren't supported in JS (including blocks with\n// an `In_` prefix). See also:\n// - Properties supported in Oniguruma: <github.com/kkos/oniguruma/blob/master/doc/UNICODE_PROPERTIES>\n// - Properties supported in JS by spec version: <github.com/eslint-community/regexpp/blob/main/src/unicode/properties.ts>\nconst JsUnicodeProperties = new Set(\n`C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS`.split(/\\s/)\n);\n\nconst JsUnicodePropertiesMap = new Map();\nfor (const p of JsUnicodeProperties) {\n  JsUnicodePropertiesMap.set(slug(p), p);\n}\n\nconst JsUnicodePropertiesOfStrings = new Set([\n  // ES2024 properties of strings; none are supported by Oniguruma\n  'Basic_Emoji',\n  'Emoji_Keycap_Sequence',\n  'RGI_Emoji',\n  'RGI_Emoji_Flag_Sequence',\n  'RGI_Emoji_Modifier_Sequence',\n  'RGI_Emoji_Tag_Sequence',\n  'RGI_Emoji_ZWJ_Sequence',\n]);\n\nconst JsUnicodePropertiesOfStringsMap = new Map();\nfor (const p of JsUnicodePropertiesOfStrings) {\n  JsUnicodePropertiesOfStringsMap.set(slug(p), p);\n}\n\nconst LowerToAlternativeLowerCaseMap = new Map([\n  ['s', cp(0x17F)], // s, ſ\n  [cp(0x17F), 's'], // ſ, s\n]);\n\nconst LowerToAlternativeUpperCaseMap = new Map([\n  [cp(0xDF), cp(0x1E9E)], // ß, ẞ\n  [cp(0x6B), cp(0x212A)], // k, K (Kelvin)\n  [cp(0xE5), cp(0x212B)], // å, Å (Angstrom)\n  [cp(0x3C9), cp(0x2126)], // ω, Ω (Ohm)\n]);\n\n// See <github.com/node-unicode/unicode-16.0.0/tree/main/General_Category/Titlecase_Letter>\nconst LowerToTitleCaseMap = new Map([\n  titleEntry(0x1C5),\n  titleEntry(0x1C8),\n  titleEntry(0x1CB),\n  titleEntry(0x1F2),\n  ...titleRange(0x1F88, 0x1F8F),\n  ...titleRange(0x1F98, 0x1F9F),\n  ...titleRange(0x1FA8, 0x1FAF),\n  titleEntry(0x1FBC),\n  titleEntry(0x1FCC),\n  titleEntry(0x1FFC),\n]);\n\n// Unlike Oniguruma's Unicode properties via `\\p` and `\\P`, these names are case sensitive and\n// don't allow inserting whitespace and underscores. Definitions at\n// <github.com/kkos/oniguruma/blob/master/doc/RE> (see: POSIX bracket: Unicode Case)\n// Note: Handling in the transformer assumes all values here are a single, negateable node that's\n// not pre-negated at the top level. It also uses ASCII versions of `graph` and `print` for target\n// `ES2018` (which doesn't allow intersection) if `accuracy` isn't `strict`\nconst PosixClassesMap = new Map([\n  ['alnum', r`[\\p{Alpha}\\p{Nd}]`],\n  ['alpha', r`\\p{Alpha}`],\n  ['ascii', r`\\p{ASCII}`],\n  ['blank', r`[\\p{Zs}\\t]`],\n  ['cntrl', r`\\p{cntrl}`],\n  ['digit', r`\\p{Nd}`],\n  ['graph', r`[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]`],\n  ['lower', r`\\p{Lower}`],\n  ['print', r`[[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`],\n  ['punct', r`[\\p{P}\\p{S}]`], // New value from Oniguruma 6.9.9\n  ['space', r`\\p{space}`],\n  ['upper', r`\\p{Upper}`],\n  ['word', r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`],\n  ['xdigit', r`\\p{AHex}`],\n]);\n\n// Apart from the property names provided by Unicode, Oniguruma explicitly adds several names (see\n// <github.com/kkos/oniguruma/blob/master/doc/RE>) that can be used within `\\p{}` and `\\P{}` (those\n// below). These should be listed here in lowercase, though they aren't case sensitive when used\nconst PosixProperties = new Set([\n  'alnum',\n  'blank',\n  'graph',\n  'print',\n  'word',\n  'xdigit',\n  // The following are available with the same name in JS (see `JsUnicodeProperties`), so can be\n  // handled as standard Unicode properties\n  // 'alpha', // (JS: Alpha)\n  // 'ascii', // (JS: ASCII)\n  // 'cntrl', // (JS: cntrl)\n  // 'digit', // (JS: digit)\n  // 'lower', // (JS: Lower)\n  // 'punct', // (JS: punct)\n  // 'space', // (JS: space)\n  // 'upper', // (JS: Upper)\n]);\n\nfunction range(start, end) {\n  // const range = Array.from(Array(end + 1 - start), (_, i) => i + start);\n  // const range = Array(end + 1 - start).fill(start).map((x, i) => x + i);\n  const range = [];\n  for (let i = start; i <= end; i++) {\n    range.push(i);\n  }\n  return range;\n}\n\n// Generates a Unicode property lookup name: lowercase, without spaces, hyphens, underscores\nfunction slug(name) {\n  return name.replace(/[- _]+/g, '').toLowerCase();\n}\n\nfunction titleEntry(codePoint) {\n  const char = cp(codePoint);\n  return [char.toLowerCase(), char];\n}\n\nfunction titleRange(start, end) {\n  return range(start, end).map(codePoint => titleEntry(codePoint));\n}\n\nconst UnicodePropertiesWithSpecificCase = new Set([\n  'Lower', 'Lowercase',\n  'Upper', 'Uppercase',\n  'Ll', 'Lowercase_Letter',\n  'Lt', 'Titlecase_Letter',\n  'Lu', 'Uppercase_Letter',\n  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.\n  // Some other properties include a handful of chars with specific cases only, but these chars are\n  // generally extreme edge cases and using such properties case insensitively generally produces\n  // undesired behavior anyway\n]);\n\nexport {\n  getIgnoreCaseMatchChars,\n  JsUnicodeProperties,\n  JsUnicodePropertiesMap,\n  JsUnicodePropertiesOfStringsMap,\n  PosixClassesMap,\n  PosixProperties,\n  slug,\n  UnicodePropertiesWithSpecificCase,\n};\n","import {PosixClassesMap} from './unicode.js';\nimport {r} from './utils.js';\n\nconst TokenTypes = /** @type {const} */ ({\n  Alternator: 'Alternator',\n  Assertion: 'Assertion',\n  Backreference: 'Backreference',\n  Character: 'Character',\n  CharacterClassClose: 'CharacterClassClose',\n  CharacterClassHyphen: 'CharacterClassHyphen',\n  CharacterClassIntersector: 'CharacterClassIntersector',\n  CharacterClassOpen: 'CharacterClassOpen',\n  CharacterSet: 'CharacterSet',\n  Directive: 'Directive',\n  GroupClose: 'GroupClose',\n  GroupOpen: 'GroupOpen',\n  Subroutine: 'Subroutine',\n  Quantifier: 'Quantifier',\n  // These aren't allowed in char classes, so they aren't equivalent to JS `[\\q{}]`\n  VariableLengthCharacterSet: 'VariableLengthCharacterSet',\n  // Intermediate representation not included in results\n  EscapedNumber: 'EscapedNumber',\n});\n\nconst TokenCharacterSetKinds = {\n  any: 'any',\n  digit: 'digit',\n  dot: 'dot',\n  hex: 'hex',\n  non_newline: 'non_newline',\n  posix: 'posix',\n  property: 'property',\n  space: 'space',\n  word: 'word',\n};\n\nconst TokenDirectiveKinds = {\n  flags: 'flags',\n  keep: 'keep',\n};\n\nconst TokenGroupKinds = {\n  absent_repeater: 'absent_repeater',\n  atomic: 'atomic',\n  capturing: 'capturing',\n  group: 'group',\n  lookahead: 'lookahead',\n  lookbehind: 'lookbehind',\n};\n\nconst EscapeCharCodes = new Map([\n  ['a',  7], // alert/bell (Not available in JS)\n  ['b',  8], // backspace (only in char classes)\n  ['e', 27], // escape (Not available in JS)\n  ['f', 12], // form feed\n  ['n', 10], // line feed\n  ['r', 13], // carriage return\n  ['t',  9], // horizontal tab\n  ['v', 11], // vertical tab\n]);\n\nconst charClassOpenPattern = r`\\[\\^?`;\nconst sharedEscapesPattern = `${\n  // Control char\n  'c.? | C(?:-.?)?'\n}|${\n  // Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n  // `\\p{gc=L}` are invalid\n  r`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`\n}|${\n  // Hex encoded byte sequence; attempt match before other `\\xNN` hex char\n  r`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`\n}|${\n  // Hex char\n  r`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`\n}|${\n  // Enclosed octal code point\n  r`o\\{[^\\}]*\\}?`\n}|${\n  // Escaped number\n  r`\\d{1,3}`\n}`;\n// Even with flag x, Onig doesn't allow whitespace to separate a quantifier from the `?` or `+`\n// that makes it lazy or possessive. Possessive suffixes don't apply to interval quantifiers\nconst quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nconst tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?: \\? (?:\n    [:=!>(]\n    | <[=!]\n    | <[^>]*>\n    | '[^']*'\n    | ~\\|?\n    | # (?:[^)\\\\] | \\\\.?)*\n    | [imx\\-]+[:)]\n  )?)?\n  | ${quantifierRe.source}\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\nconst charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:[^:]*:\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\n@typedef {{\n  type: keyof TokenTypes;\n  raw: string;\n  [key: string]: string | number | boolean;\n}} Token\n@typedef {{\n  tokens: Array<Token>;\n  flags: {\n    dotAll: boolean;\n    extended: boolean;\n    ignoreCase: boolean;\n  };\n  rules: {\n    captureGroup: boolean;\n    singleline: boolean;\n  };\n}} TokenizerResult\n*/\n/**\n@param {string} pattern Oniguruma pattern.\n@param {string} [flags] Oniguruma flags.\n@param {{\n  captureGroup?: boolean;\n  singleline?: boolean;\n}} [rules] Oniguruma compile-time options.\n@returns {TokenizerResult}\n*/\nfunction tokenize(pattern, flags = '', rules) {\n  rules = {\n    // `ONIG_OPTION_CAPTURE_GROUP`\n    captureGroup: false,\n    // `ONIG_OPTION_SINGLELINE`\n    singleline: false,\n    ...rules,\n  };\n  if (typeof pattern !== 'string') {\n    throw new Error('String expected as pattern');\n  }\n  if (!/^[imxDSW]*$/.test(flags)) {\n    throw new Error(`Flags \"${flags}\" includes unsupported value`);\n  }\n  const extended = flags.includes('x');\n  const xStack = [extended];\n  const context = {\n    captureGroup: rules.captureGroup,\n    getCurrentModX: () => xStack.at(-1),\n    numOpenGroups: 0,\n    popModX() {xStack.pop()},\n    pushModX(isXOn) {xStack.push(isXOn)},\n    replaceCurrentModX(isXOn) {xStack[xStack.length - 1] = isXOn},\n    singleline: rules.singleline,\n  };\n  let tokens = [];\n  let match;\n  tokenRe.lastIndex = 0;\n  while ((match = tokenRe.exec(pattern))) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== undefined) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n\n  const potentialUnnamedCaptureTokens = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.forEach(t => {\n    if (t.type === TokenTypes.GroupOpen) {\n      if (t.kind === TokenGroupKinds.capturing) {\n        t.number = ++numNamedAndOptInUnnamedCaptures;\n      } else if (t.raw === '(') {\n        potentialUnnamedCaptureTokens.push(t);\n      }\n    }\n  });\n  // Enable unnamed capturing groups if no named captures (when `captureGroup` not enabled)\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = TokenGroupKinds.capturing;\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  // Can now split escaped nums accurately, accounting for number of captures\n  tokens = tokens.map(\n    t => t.type === TokenTypes.EscapedNumber ? splitEscapedNumToken(t, numCaptures) : t\n  ).flat();\n\n  return {\n    tokens,\n    flags: {\n      ignoreCase: flags.includes('i'),\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      dotAll: flags.includes('m'),\n      // Flag x is fully handled during tokenization\n      extended,\n      // Flags D, S, W are currently only supported as top-level flags\n      digitIsAscii: flags.includes('D'),\n      spaceIsAscii: flags.includes('S'),\n      wordIsAscii: flags.includes('W'),\n    },\n    rules,\n  };\n}\n\nfunction getTokenWithDetails(context, pattern, m, lastIndex) {\n  const [m0, m1, m2] = m;\n  if (m0 === '[') {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex,\n    };\n  }\n  if (m0 === '\\\\') {\n    if ('AbBGzZ'.includes(m1)) {\n      return {\n        token: createToken(TokenTypes.Assertion, m, {\n          kind: m,\n        }),\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Subroutine, m),\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Backreference, m),\n      };\n    }\n    if (m1 === 'K') {\n      return {\n        token: createToken(TokenTypes.Directive, m, {\n          kind: TokenDirectiveKinds.keep,\n        }),\n      };\n    }\n    if (m1 === 'N') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.non_newline,\n        }),\n      };\n    }\n    if (m1 === 'O') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.any,\n        }),\n      };\n    }\n    if ('RX'.includes(m1)) {\n      return {\n        token: createToken(TokenTypes.VariableLengthCharacterSet, m, {\n          kind: m,\n        }),\n      };\n    }\n    // Grapheme boundaries not yet unsupported; avoid treating as an identity escape\n    if ('yY'.includes(m1)) {\n      throw new Error(`Unsupported grapheme boundary \"${m}\"`);\n    }\n    // Run last since it assumes an identity escape as final condition\n    const result = createTokenForSharedEscape(m, {inCharClass: false});\n    return Array.isArray(result) ? {tokens: result} : {token: result};\n  }\n  if (m0 === '(') {\n    // Comment group\n    if (m2 === '#') {\n      // The closing unescaped `)` isn't included in the match\n      if (pattern[lastIndex] !== ')') {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        lastIndex: lastIndex + 1,\n      };\n    }\n    // Flag modifier (directive or group opener); allows solo `-`\n    if ('-imx'.includes(m2)) {\n      return {\n        token: createTokenForFlagMod(m, context),\n      };\n    }\n    // Remaining group types all reuse current flag x status\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      (m === '(' && !context.captureGroup) ||\n      // Noncapturing group\n      m === '(?:'\n    ) {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          // For `(`, will later change to `capturing` and add `number` prop if no named captures\n          kind: TokenGroupKinds.group,\n        }),\n      };\n    }\n    // Atomic group\n    if (m === '(?>') {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.atomic,\n        }),\n      };\n    }\n    // Lookaround\n    if (m === '(?=' || m === '(?!' || m === '(?<=' || m === '(?<!') {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: m2 === '<' ? TokenGroupKinds.lookbehind : TokenGroupKinds.lookahead,\n          negate: m.endsWith('!'),\n        }),\n      };\n    }\n    // Named capture (checked after lookbehind due to similar syntax), or unnamed capture when\n    // `captureGroup` enabled\n    if (m2 === '<' || m2 === \"'\" || (m === '(' && context.captureGroup)) {\n      const token = createToken(TokenTypes.GroupOpen, m, {\n        kind: TokenGroupKinds.capturing,\n        // Will add `number` in a second pass\n      });\n      if (m !== '(') {\n        token.name = m.slice(3, -1);\n      }\n      return {\n        token,\n      };\n    }\n    if (m2 === '~') {\n      if (m === '(?~|') {\n        throw new Error(`Unsupported absent function kind \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.absent_repeater,\n        }),\n      };\n    }\n    if (m2 === '(') {\n      // [TODO] Some forms are supportable\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    if (m === '(?') {\n      throw new Error('Invalid group');\n    }\n    throw new Error(`Unexpected group \"${m}\"`);\n  }\n  if (m === ')') {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createToken(TokenTypes.GroupClose, m),\n    };\n  }\n  if (m === '#' && context.getCurrentModX()) {\n    // Onig's only line break char is line feed\n    const end = pattern.indexOf('\\n', lastIndex);\n    return {\n      // Jump forward to the end of the comment\n      lastIndex: end === -1 ? pattern.length : end,\n    };\n  }\n  if (/^\\s$/.test(m) && context.getCurrentModX()) {\n    const re = /\\s+/y;\n    re.lastIndex = lastIndex;\n    const rest = re.exec(pattern);\n    return {\n      // Jump forward to the end of the whitespace\n      lastIndex: rest ? re.lastIndex : lastIndex,\n    };\n  }\n  if (m === '.') {\n    return {\n      token: createToken(TokenTypes.CharacterSet, m, {\n        kind: TokenCharacterSetKinds.dot,\n      }),\n    };\n  }\n  if (m === '^' || m === '$') {\n    const kind = context.singleline ? {\n      '^': r`\\A`,\n      '$': r`\\Z`,\n    }[m] : m;\n    return {\n      token: createToken(TokenTypes.Assertion, m, {\n        kind,\n      }),\n    };\n  }\n  if (m === '|') {\n    return {\n      token: createToken(TokenTypes.Alternator, m),\n    };\n  }\n  if (quantifierRe.test(m)) {\n    return {\n      token: createTokenForQuantifier(m),\n    };\n  }\n  assertSingleCodePoint(m);\n  return {\n    token: createToken(TokenTypes.Character, m, {\n      value: m.codePointAt(0),\n    }),\n  };\n}\n\nfunction getAllTokensForCharClass(pattern, opener, lastIndex) {\n  const tokens = [createToken(TokenTypes.CharacterClassOpen, opener, {\n    negate: opener[1] === '^',\n  })];\n  let numCharClassesOpen = 1;\n  let match;\n  charClassTokenRe.lastIndex = lastIndex;\n  while ((match = charClassTokenRe.exec(pattern))) {\n    const m = match[0];\n    // Start of nested char class\n    // POSIX classes are handled as a single token; not as a nested char class\n    if (m[0] === '[' && m[1] !== ':') {\n      numCharClassesOpen++;\n      tokens.push(createToken(TokenTypes.CharacterClassOpen, m, {\n        negate: m[1] === '^',\n      }));\n    } else if (m === ']') {\n      if (tokens.at(-1).type === TokenTypes.CharacterClassOpen) {\n        // Allow unescaped `]` as leading char\n        tokens.push(createToken(TokenTypes.Character, m, {\n          value: 93,\n        }));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createToken(TokenTypes.CharacterClassClose, m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = createTokenForAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length,\n  }\n}\n\nfunction createTokenForAnyTokenWithinCharClass(raw) {\n  if (raw[0] === '\\\\') {\n    // Assumes an identity escape as final condition\n    return createTokenForSharedEscape(raw, {inCharClass: true});\n  }\n  // POSIX class: `[:name:]` or `[:^name:]`\n  if (raw[0] === '[') {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassesMap.get(posix.groups.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createToken(TokenTypes.CharacterSet, raw, {\n      kind: TokenCharacterSetKinds.posix,\n      negate: !!posix.groups.negate,\n      value: posix.groups.name,\n    });\n  }\n  // Range (possibly invalid) or literal hyphen\n  if (raw === '-') {\n    return createToken(TokenTypes.CharacterClassHyphen, raw);\n  }\n  if (raw === '&&') {\n    return createToken(TokenTypes.CharacterClassIntersector, raw);\n  }\n  assertSingleCodePoint(raw);\n  return createToken(TokenTypes.Character, raw, {\n    value: raw.codePointAt(0),\n  });\n}\n\n// Tokens shared by base syntax and char class syntax that start with `\\`\nfunction createTokenForSharedEscape(raw, {inCharClass}) {\n  const char1 = raw[1];\n  if (char1 === 'c' || char1 === 'C') {\n    return createTokenForControlChar(raw);\n  }\n  if ('dDhHsSwW'.includes(char1)) {\n    return createTokenForShorthandCharClass(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return createTokenForUnicodeProperty(raw);\n  }\n  // Hex UTF-8 encoded byte sequence\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map(hex => parseInt(hex, 16));\n      const decoded = new TextDecoder('utf-8', {\n        ignoreBOM: true,\n        fatal: true,\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map(char => {\n        // Since this regenerates `raw`, it might have different casing for hex A-F than the input\n        const raw = [...encoder.encode(char)].map(byte => `\\\\x${byte.toString(16)}`).join('');\n        return createToken(TokenTypes.Character, raw, {\n          value: char.codePointAt(0),\n        });\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === 'u' || char1 === 'x') {\n    return createToken(TokenTypes.Character, raw, {\n      value: getValidatedHexCharCode(raw),\n    });\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createToken(TokenTypes.Character, raw, {\n      value: EscapeCharCodes.get(char1),\n    });\n  }\n  // Escaped number: backref (possibly invalid), null, octal, or identity escape, possibly followed\n  // by 1-2 literal digits\n  if (/\\d/.test(char1)) {\n    return createToken(TokenTypes.EscapedNumber, raw, {\n      inCharClass,\n    });\n  }\n  if (raw === '\\\\') {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  // Meta `\\M-x` and `\\M-\\C-x` are unsupported; avoid treating as an identity escape\n  if (char1 === 'M') {\n    // [TODO] Supportable; see <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#12-onig_syn_op2_esc_capital_m_bar_meta-enable-m-x>, <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>, <https://github.com/ammar/regexp_parser/blob/8851030feda68223d74f502335fb254a20d77016/lib/regexp_parser/expression/classes/escape_sequence.rb#L75>\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  // Identity escape; count code point length\n  if ([...raw].length === 2) {\n    return createToken(TokenTypes.Character, raw, {\n      value: raw.codePointAt(1),\n    });\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\n\n/**\n@param {keyof TokenTypes} type\n@param {string} raw\n@param {{[key: string]: string | number | boolean;}} [data]\n@returns {Token}\n*/\nfunction createToken(type, raw, data) {\n  return {\n    type,\n    raw,\n    ...data,\n  };\n}\n\n// Expects `\\cx` or `\\C-x`\nfunction createTokenForControlChar(raw) {\n  const char = raw[1] === 'c' ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    // Unlike JS, Onig allows any char to follow `\\c` or `\\C-`, but this is an extreme edge case\n    // [TODO] Supportable; see <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#11-onig_syn_op2_esc_capital_c_bar_control-enable-c-x>, <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createToken(TokenTypes.Character, raw, {\n    value: char.toUpperCase().codePointAt(0) - 64,\n  });\n}\n\nfunction createTokenForFlagMod(raw, context) {\n  // Allows multiple `-` and solo `-` without `on` or `off` flags\n  let {on, off} = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[imx\\-]*))?/.exec(raw).groups;\n  // If the capturing group didn't participate\n  off ??= '';\n  // Flag x is used directly by the tokenizer since it changes how to interpret the pattern\n  const isXOn = (context.getCurrentModX() || on.includes('x')) && !off.includes('x');\n  const enabledFlags = getFlagPropsForToken(on);\n  const disabledFlags = getFlagPropsForToken(off);\n  const flagChanges = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  // Flag directive; ex: `(?im-x)`\n  if (raw.endsWith(')')) {\n    // Replace flag x value until the end of the current group\n    context.replaceCurrentModX(isXOn);\n    // Can't remove flag directives without flags like `(?-)`; they affect following quantifiers\n    return createToken(TokenTypes.Directive, raw, {\n      kind: TokenDirectiveKinds.flags,\n      flags: flagChanges,\n    });\n  }\n  // Flag group opener; ex: `(?im-x:`\n  if (raw.endsWith(':')) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    const token = createToken(TokenTypes.GroupOpen, raw, {\n      kind: TokenGroupKinds.group,\n    });\n    if (enabledFlags || disabledFlags) {\n      token.flags = flagChanges;\n    }\n    return token;\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\n\nfunction createTokenForQuantifier(raw) {\n  const data = {};\n  if (raw[0] === '{') {\n    const {min, max} = /^\\{(?<min>\\d*)(?:,(?<max>\\d*))?/.exec(raw).groups;\n    const limit = 100_000;\n    if (+min > limit || +max > limit) {\n      throw new Error('Quantifier value unsupported in Oniguruma');\n    }\n    data.min = +min;\n    data.max = max === undefined ? +min : (max === '' ? Infinity : +max);\n    data.greedy = !raw.endsWith('?');\n    // By default, Onig doesn't support making interval quantifiers possessive\n    data.possessive = false;\n  } else {\n    data.min = raw[0] === '+' ? 1 : 0;\n    data.max = raw[0] === '?' ? 1 : Infinity;\n    data.greedy = raw[1] !== '?';\n    data.possessive = raw[1] === '+';\n  }\n  return createToken(TokenTypes.Quantifier, raw, data);\n}\n\nfunction createTokenForShorthandCharClass(raw) {\n  const lower = raw[1].toLowerCase();\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: {\n      'd': TokenCharacterSetKinds.digit,\n      'h': TokenCharacterSetKinds.hex, // Not available in JS\n      's': TokenCharacterSetKinds.space, // Different than JS\n      'w': TokenCharacterSetKinds.word,\n    }[lower],\n    negate: raw[1] !== lower,\n  });\n}\n\nfunction createTokenForUnicodeProperty(raw) {\n  const {p, neg, value} = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw).groups;\n  const negate = (p === 'P' && !neg) || (p === 'p' && !!neg);\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: TokenCharacterSetKinds.property,\n    negate,\n    value,\n  });\n}\n\nfunction getFlagPropsForToken(flags) {\n  // Don't include `false` for flags that aren't included\n  const obj = {};\n  if (flags.includes('i')) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes('m')) {\n    // Onig flag m is equivalent to JS flag s\n    obj.dotAll = true;\n  }\n  if (flags.includes('x')) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\n\n// - Unenclosed `\\xNN` above 0x7F is handled elsewhere as a UTF-8 encoded byte sequence\n// - Enclosed `\\x{}` with value above 0x10FFFF is allowed here; handled in the parser\nfunction getValidatedHexCharCode(raw) {\n  // Note: Onig (tested 6.9.8) has a bug where bare `\\u` and `\\x` are identity escapes if they\n  // appear at the very end of the pattern, so e.g. `\\u` matches `u`, but `\\u0`, `\\u.`, and `[\\u]`\n  // are all errors, and `\\x.` and `[\\x]` aren't errors but instead the `\\x` is equivalent to `\\0`.\n  // Don't emulate these bugs (see #21), and just treat these cases as errors. Also, Onig treats\n  // incomplete `\\x{` (with the brace and not immediately followed by a hex digit) as an identity\n  // escape, so e.g. `\\x{` matches `x{` and `^\\x{,2}$` matches `xx`, but `\\x{2,}` and `\\x{0,2}` are\n  // errors. Don't emulate this pointless ambiguity; just treat incomplete `\\x{` as an error\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  // Might include leading 0s\n  const hex = raw[2] === '{' ?\n    /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw).groups.hex :\n    raw.slice(2);\n  const dec = parseInt(hex, 16);\n  return dec;\n}\n\n// Value is 1-3 digits, which can be a backref (possibly invalid), null, octal, or identity escape,\n// possibly followed by 1-2 literal digits\nfunction splitEscapedNumToken(token, numCaptures) {\n  const {raw, inCharClass} = token;\n  // Keep any leading 0s since they indicate octal\n  const value = raw.slice(1);\n  // Backref (possibly invalid)\n  if (\n    !inCharClass &&\n    ( // Single digit 1-9 outside a char class is always treated as a backref\n      (value !== '0' && value.length === 1) ||\n      // Leading 0 makes it octal; backrefs can't include following literal digits\n      (value[0] !== '0' && +value <= numCaptures)\n    )\n  ) {\n    return [createToken(TokenTypes.Backreference, raw)];\n  }\n  const tokens = [];\n  // Returns 1-3 matches; the first (only) might be octal\n  const matches = value.match(/^[0-7]+|\\d/g);\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value;\n    // Octal digits are 0-7\n    if (i === 0 && m !== '8' && m !== '9') {\n      value = parseInt(m, 8);\n      if (value > 0o177) {\n        // Octal UTF-8 encoded byte sequence; not yet supported\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value = m.codePointAt(0);\n    }\n    tokens.push(createToken(TokenTypes.Character, (i === 0 ? '\\\\' : '') + m, {\n      value,\n    }));\n  }\n  return tokens;\n}\n\nfunction assertSingleCodePoint(raw) {\n  if ([...raw].length !== 1) {\n    throw new Error(`Expected \"${raw}\" to be a single code point`);\n  }\n}\n\nexport {\n  tokenize,\n  TokenCharacterSetKinds,\n  TokenDirectiveKinds,\n  TokenGroupKinds,\n  TokenTypes,\n};\n","import {AstAssertionKinds, AstTypes} from './parse.js';\n\nfunction hasOnlyChild({alternatives}, kidFn) {\n  return (\n    alternatives.length === 1 &&\n    alternatives[0].elements.length === 1 &&\n    (!kidFn || kidFn(alternatives[0].elements[0]))\n  );\n}\n\nfunction isAlwaysZeroLength({type}) {\n  return type === AstTypes.Assertion || type === AstTypes.Directive;\n}\n\nfunction isAlwaysNonZeroLength(node) {\n  const types = [\n    AstTypes.Character,\n    AstTypes.CharacterClass,\n    AstTypes.CharacterSet,\n  ];\n  return types.includes(node.type) || (\n    node.type === AstTypes.Quantifier &&\n    node.min &&\n    types.includes(node.element.type)\n  );\n}\n\n// Consumptive groups add to the match.\n// - Includes: Capturing, named capturing, noncapturing, atomic, and flag groups.\n// - Excludes: Lookarounds.\n//   - Special case: Absent functions are consumptive (and negated, quantified) but are different\n//     in other ways so are excluded here.\n// See also `AstTypeAliases.AnyGroup`.\nfunction isConsumptiveGroup({type}) {\n  return type === AstTypes.CapturingGroup || type === AstTypes.Group;\n}\n\nfunction isLookaround({type, kind}) {\n  return (\n    type === AstTypes.Assertion &&\n    (kind === AstAssertionKinds.lookahead || kind === AstAssertionKinds.lookbehind)\n  );\n}\n\nexport {\n  hasOnlyChild,\n  isAlwaysNonZeroLength,\n  isAlwaysZeroLength,\n  isConsumptiveGroup,\n  isLookaround,\n};\n","import {AstTypes} from './parse.js';\nimport {throwIfNot} from './utils.js';\nimport {isConsumptiveGroup, isLookaround} from './utils-ast.js';\n\nfunction traverse(path, state, visitor) {\n  let ast = path.node;\n  while (ast.parent) {\n    ast = ast.parent;\n  }\n  function traverseArray(array, parent) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(node, parent = null, key = null, container = null) {\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path = {\n      node,\n      parent,\n      key,\n      container,\n      ast,\n      remove() {\n        throwIfNot(container, 'Container expected').splice(Math.max(0, key + keyShift), 1);\n        keyShift -= 1;\n      },\n      removeAllNextSiblings() {\n        return throwIfNot(container, 'Container expected').splice(key + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = key + keyShift;\n        keyShift -= shifted;\n        return throwIfNot(container, 'Container expected').splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode) {\n        setParent(newNode, parent);\n        if (container) {\n          container[Math.max(0, key + keyShift)] = newNode;\n        } else {\n          parent[key] = newNode;\n        }\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      },\n    };\n    const visitorKey = getAstTypeAliases(node).find(key => !!visitor[key]);\n    const methods = visitorKey && visitor[visitorKey];\n    const enterFn = typeof methods === 'function' ? methods : methods?.enter;\n    const exitFn = methods?.exit;\n    enterFn?.(path, state);\n    if (!skipTraversingKidsOfPath) {\n      switch (node.type) {\n        case AstTypes.Regex:\n          traverseNode(node.pattern, node, 'pattern');\n          traverseNode(node.flags, node, 'flags');\n          break;\n        case AstTypes.Alternative:\n        case AstTypes.CharacterClass:\n          traverseArray(node.elements, node);\n          break;\n        case AstTypes.Assertion:\n          if (isLookaround(node)) {\n            traverseArray(node.alternatives, node);\n          }\n          break;\n        case AstTypes.Backreference:\n        case AstTypes.Character:\n        case AstTypes.CharacterSet:\n        case AstTypes.Directive:\n        case AstTypes.Flags:\n        case AstTypes.Recursion:\n        case AstTypes.Subroutine:\n        case AstTypes.VariableLengthCharacterSet:\n          break;\n        case AstTypes.AbsentFunction:\n        case AstTypes.CapturingGroup:\n        case AstTypes.Group:\n        case AstTypes.Pattern:\n          traverseArray(node.alternatives, node);\n          break;\n        case AstTypes.CharacterClassIntersection:\n          traverseArray(node.classes, node);\n          break;\n        case AstTypes.CharacterClassRange:\n          traverseNode(node.min, node, 'min');\n          traverseNode(node.max, node, 'max');\n          break;\n        case AstTypes.Quantifier:\n          traverseNode(node.element, node, 'element');\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${node.type}\"`);\n      }\n    }\n    exitFn?.(path, state);\n    return keyShift;\n  }\n  traverseNode(path.node, path.parent, path.key, path.container);\n}\n\nconst AstTypeAliases = {\n  AnyGroup: 'AnyGroup',\n  AnyNode: 'AnyNode',\n};\n\nfunction getAstTypeAliases(node) {\n  const types = [AstTypeAliases.AnyNode];\n  if (isConsumptiveGroup(node) || isLookaround(node)) {\n    types.push(AstTypeAliases.AnyGroup);\n  }\n  types.push(node.type);\n  return types;\n}\n\nfunction setParent(node, parent) {\n  // The traverser can work with ASTs whose nodes include or don't include `parent` props, so only\n  // update the parent if a prop for it exists\n  if ('parent' in parent) {\n    node.parent = parent;\n  }\n}\n\nexport {\n  traverse,\n};\n","import {TokenCharacterSetKinds, TokenDirectiveKinds, TokenGroupKinds, TokenTypes} from './tokenize.js';\nimport {traverse} from './traverse.js';\nimport {JsUnicodePropertiesMap, JsUnicodePropertiesOfStringsMap, PosixProperties, slug} from './unicode.js';\nimport {getOrCreate, r, throwIfNot} from './utils.js';\nimport {hasOnlyChild} from './utils-ast.js';\n\nconst AstTypes = {\n  AbsentFunction: 'AbsentFunction',\n  Alternative: 'Alternative',\n  Assertion: 'Assertion',\n  Backreference: 'Backreference',\n  CapturingGroup: 'CapturingGroup',\n  Character: 'Character',\n  CharacterClass: 'CharacterClass',\n  CharacterClassIntersection: 'CharacterClassIntersection',\n  CharacterClassRange: 'CharacterClassRange',\n  CharacterSet: 'CharacterSet',\n  Directive: 'Directive',\n  Flags: 'Flags',\n  Group: 'Group',\n  Pattern: 'Pattern',\n  Quantifier: 'Quantifier',\n  Regex: 'Regex',\n  Subroutine: 'Subroutine',\n  VariableLengthCharacterSet: 'VariableLengthCharacterSet',\n  // Used only by the transformer for Regex+ ASTs\n  Recursion: 'Recursion',\n};\n\nconst AstAbsentFunctionKinds = {\n  // See <github.com/slevithan/oniguruma-to-es/issues/13>\n  repeater: 'repeater',\n};\n\nconst AstAssertionKinds = {\n  line_end: 'line_end',\n  line_start: 'line_start',\n  lookahead: 'lookahead',\n  lookbehind: 'lookbehind',\n  search_start: 'search_start',\n  string_end: 'string_end',\n  string_end_newline: 'string_end_newline',\n  string_start: 'string_start',\n  word_boundary: 'word_boundary',\n};\n\n// Identical values\nconst AstCharacterSetKinds = TokenCharacterSetKinds;\nconst AstDirectiveKinds = TokenDirectiveKinds;\n\nconst AstVariableLengthCharacterSetKinds = {\n  grapheme: 'grapheme',\n  newline: 'newline',\n};\n\n/**\n@typedef {{\n  type: 'Regex';\n  parent: null;\n  pattern: Object;\n  flags: Object;\n}} OnigurumaAst\n*/\n/**\n@param {import('./tokenize.js').TokenizerResult} tokenizerResult\n@param {{\n  skipBackrefValidation?: boolean;\n  skipPropertyNameValidation?: boolean;\n  verbose?: boolean;\n}} [options]\n@returns {OnigurumaAst}\n*/\nfunction parse({tokens, flags, rules}, options) {\n  const opts = {\n    skipBackrefValidation: false,\n    skipLookbehindValidation: false,\n    skipPropertyNameValidation: false,\n    verbose: false,\n    ...options,\n  };\n  const context = {\n    capturingGroups: [],\n    current: 0,\n    hasNumberedRef: false,\n    namedGroupsByName: new Map(),\n    parent: null,\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipLookbehindValidation: opts.skipLookbehindValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    token: null,\n    tokens,\n    verbose: opts.verbose,\n    walk,\n  };\n  function walk(parent, state) {\n    const token = tokens[context.current];\n    context.parent = parent;\n    context.token = token;\n    // Advance for the next iteration\n    context.current++;\n    switch (token.type) {\n      case TokenTypes.Alternator:\n        // Top-level only; groups handle their own alternators\n        return createAlternative();\n      case TokenTypes.Assertion:\n        return createAssertionFromToken(token);\n      case TokenTypes.Backreference:\n        return parseBackreference(context);\n      case TokenTypes.Character:\n        return createCharacter(token.value, {useLastValid: !!state.isCheckingRangeEnd});\n      case TokenTypes.CharacterClassHyphen:\n        return parseCharacterClassHyphen(context, state);\n      case TokenTypes.CharacterClassOpen:\n        return parseCharacterClassOpen(context, state);\n      case TokenTypes.CharacterSet:\n        return parseCharacterSet(context);\n      case TokenTypes.Directive:\n        return createDirectiveFromToken(token);\n      case TokenTypes.GroupOpen:\n        return parseGroupOpen(context, state);\n      case TokenTypes.Quantifier:\n        return parseQuantifier(context);\n      case TokenTypes.Subroutine:\n        return parseSubroutine(context);\n      case TokenTypes.VariableLengthCharacterSet:\n        return createVariableLengthCharacterSet(token.kind);\n      default:\n        throw new Error(`Unexpected token type \"${token.type}\"`);\n    }\n  }\n  const ast = createRegex(createPattern(), createFlags(flags));\n  let top = ast.pattern.alternatives[0];\n  while (context.current < tokens.length) {\n    const node = walk(top, {});\n    if (node.type === AstTypes.Alternative) {\n      ast.pattern.alternatives.push(node);\n      top = node;\n    } else {\n      top.elements.push(node);\n    }\n  }\n  // `context` updated by preceding `walk` loop\n  const {capturingGroups, hasNumberedRef, namedGroupsByName, subroutines} = context;\n  // Validation that requires knowledge about the complete pattern\n  if (hasNumberedRef && namedGroupsByName.size && !rules.captureGroup) {\n    throw new Error('Numbered backref/subroutine not allowed when using named capture');\n  }\n  for (const {ref} of subroutines) {\n    if (typeof ref === 'number') {\n      // Relative nums are already resolved\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref).length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    }\n  }\n  // Add `parent` properties now that we have a final AST\n  traverse({node: ast}, null, {\n    AnyNode({node, parent}) {\n      node.parent = parent;\n    },\n  });\n  return ast;\n}\n\n// Supported (if the backref appears to the right of the reffed capture's opening paren):\n// - `\\k<name>`, `\\k'name'`\n// - When named capture not used:\n//   - `\\n`, `\\nn`, `\\nnn`\n//   - `\\k<n>`, `\\k'n'\n//   - `\\k<-n>`, `\\k'-n'`\n// Unsupported:\n// - `\\k<+n>`, `\\k'+n'` - Note that, Unlike Oniguruma, Onigmo doesn't support this as special\n//   syntax and therefore considers it a valid group name.\n// - Backref with recursion level (with num or name): `\\k<n+level>`, `\\k<n-level>`, etc.\n//   (Onigmo also supports `\\k<-n+level>`, `\\k<-n-level>`, etc.)\n// Backrefs in Onig use multiplexing for duplicate group names (the rules can be complicated when\n// overlapping with subroutines), but a `Backreference`'s simple `ref` prop doesn't capture these\n// details so multiplexed ref pointers need to be derived when working with the AST\nfunction parseBackreference(context) {\n  const {raw} = context.token;\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    // Note: It's not an error for numbered backrefs to come before their referenced group in Onig,\n    // but an error is the best path for this library because:\n    // 1. Most placements are mistakes and can never match (based on the Onig behavior for backrefs\n    //    to nonparticipating groups).\n    // 2. Erroring matches the behavior of named backrefs.\n    // 3. The edge cases where they're matchable rely on rules for backref resetting within\n    //    quantified groups that are different in JS and aren't emulatable. Note that it's not a\n    //    backref in the first place if using `\\10` or higher and not as many capturing groups are\n    //    defined to the left (it's an octal or identity escape).\n    // [TODO] Ideally this would be refactored to include the backref in the AST when it's not an\n    // error in Onig (due to the reffed group being defined to the right), and the error handling\n    // would move to the transformer\n    if (num > numCapturesToLeft) {\n      // [WARNING] Skipping the error breaks assumptions and might create edge case issues, since\n      // backrefs are required to come after their captures; unfortunately this option is needed\n      // for TextMate grammars\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, {orphan});\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups.num, !!numberedRef.groups.sign);\n    }\n    // Invalid in a backref name even when valid in a group name\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\n\nfunction parseCharacterClassHyphen(context, state) {\n  const {parent, tokens, walk} = context;\n  const prevSiblingNode = parent.elements.at(-1);\n  const nextToken = tokens[context.current];\n  if (\n    !state.isCheckingRangeEnd &&\n    prevSiblingNode &&\n    prevSiblingNode.type !== AstTypes.CharacterClass &&\n    prevSiblingNode.type !== AstTypes.CharacterClassRange &&\n    nextToken &&\n    nextToken.type !== TokenTypes.CharacterClassOpen &&\n    nextToken.type !== TokenTypes.CharacterClassClose &&\n    nextToken.type !== TokenTypes.CharacterClassIntersector\n  ) {\n    const nextNode = walk(parent, {\n      ...state,\n      isCheckingRangeEnd: true,\n    });\n    if (prevSiblingNode.type === AstTypes.Character && nextNode.type === AstTypes.Character) {\n      parent.elements.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error('Invalid character class range');\n  }\n  // Literal hyphen\n  return createCharacter(45);\n}\n\nfunction parseCharacterClassOpen(context, state) {\n  const {token, tokens, verbose, walk} = context;\n  const firstClassToken = tokens[context.current];\n  let node = createCharacterClass({negate: token.negate});\n  const intersection = node.elements[0];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== TokenTypes.CharacterClassClose) {\n    if (nextToken.type === TokenTypes.CharacterClassIntersector) {\n      intersection.classes.push(createCharacterClass({negate: false, baseOnly: true}));\n      // Skip the intersector\n      context.current++;\n    } else {\n      const cc = intersection.classes.at(-1);\n      cc.elements.push(walk(cc, state));\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.current], firstClassToken);\n  }\n  if (!verbose) {\n    optimizeCharacterClassIntersection(intersection);\n  }\n  // Simplify tree if we don't need the intersection wrapper\n  if (intersection.classes.length === 1) {\n    const cc = intersection.classes[0];\n    // Only needed if `!verbose`; otherwise an intersection's direct kids are never negated\n    cc.negate = node.negate !== cc.negate;\n    node = cc;\n  }\n  // Skip the closing square bracket\n  context.current++;\n  return node;\n}\n\nfunction parseCharacterSet({token, skipPropertyNameValidation}) {\n  let {kind, negate, value} = token;\n  if (kind === TokenCharacterSetKinds.property) {\n    const normalized = slug(value);\n    if (PosixProperties.has(normalized)) {\n      kind = TokenCharacterSetKinds.posix;\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value, {\n        negate,\n        skipPropertyNameValidation,\n      });\n    }\n  }\n  if (kind === TokenCharacterSetKinds.posix) {\n    return {\n      type: AstTypes.CharacterSet,\n      kind: AstCharacterSetKinds.posix,\n      negate,\n      value,\n    };\n  }\n  return createCharacterSet(kind, {negate});\n}\n\nfunction parseGroupOpen(context, state) {\n  const {token, tokens, capturingGroups, namedGroupsByName, skipLookbehindValidation, verbose, walk} = context;\n  let node = createByGroupKind(token);\n  const isAbsentFunction = node.type === AstTypes.AbsentFunction;\n  const isLookbehind = node.kind === AstAssertionKinds.lookbehind;\n  const isNegLookbehind = isLookbehind && node.negate;\n  // Track capturing group details for backrefs and subroutines (before parsing the group's\n  // contents so nested groups with the same name are tracked in order)\n  if (node.type === AstTypes.CapturingGroup) {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrCreate(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  // Don't allow nested absent functions\n  if (isAbsentFunction && state.isInAbsentFunction) {\n    // Is officially unsupported in Onig but doesn't throw, gives strange results\n    throw new Error('Nested absent function not supported by Oniguruma');\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  while (nextToken.type !== TokenTypes.GroupClose) {\n    if (nextToken.type === TokenTypes.Alternator) {\n      node.alternatives.push(createAlternative());\n      // Skip the alternator\n      context.current++;\n    } else {\n      const alt = node.alternatives.at(-1);\n      const child = walk(alt, {\n        ...state,\n        isInAbsentFunction: state.isInAbsentFunction || isAbsentFunction,\n        isInLookbehind: state.isInLookbehind || isLookbehind,\n        isInNegLookbehind: state.isInNegLookbehind || isNegLookbehind,\n      });\n      alt.elements.push(child);\n      // Centralized validation of lookbehind contents\n      if ((isLookbehind || state.isInLookbehind) && !skipLookbehindValidation) {\n        // JS supports all features within lookbehind, but Onig doesn't. Absent functions of form\n        // `(?~|)` and `(?~|…)` are also invalid in lookbehind (the `(?~…)` and `(?~|…|…)` forms\n        // are allowed), but all forms with `(?~|` throw since they aren't yet supported\n        const msg = 'Lookbehind includes a pattern not allowed by Oniguruma';\n        if (isNegLookbehind || state.isInNegLookbehind) {\n          // - Invalid: `(?=…)`, `(?!…)`, capturing groups\n          // - Valid: `(?<=…)`, `(?<!…)`\n          if (child.kind === AstAssertionKinds.lookahead || child.type === AstTypes.CapturingGroup) {\n            throw new Error(msg);\n          }\n        } else {\n          // - Invalid: `(?=…)`, `(?!…)`, `(?<!…)`\n          // - Valid: `(?<=…)`, capturing groups\n          if (child.kind === AstAssertionKinds.lookahead || (child.kind === AstAssertionKinds.lookbehind && child.negate)) {\n            throw new Error(msg);\n          }\n        }\n      }\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  }\n  if (!verbose) {\n    node = getOptimizedGroup(node);\n  }\n  // Skip the closing parenthesis\n  context.current++;\n  return node;\n}\n\nfunction parseQuantifier({token, parent}) {\n  const {min, max, greedy, possessive} = token;\n  const quantifiedNode = parent.elements.at(-1);\n  if (\n    !quantifiedNode ||\n    quantifiedNode.type === AstTypes.Assertion ||\n    quantifiedNode.type === AstTypes.Directive\n  ) {\n    throw new Error(`Quantifier requires a repeatable token`);\n  }\n  const node = createQuantifier(quantifiedNode, min, max, greedy, possessive);\n  parent.elements.pop();\n  return node;\n}\n\n// Onig subroutine behavior:\n// - Subroutines can appear before the groups they reference; ex: `\\g<1>(a)` is valid.\n// - Multiple subroutines can reference the same group.\n// - Subroutines can reference groups that themselves contain subroutines, followed to any depth.\n// - Subroutines can be used recursively, and `\\g<0>` recursively references the whole pattern.\n// - Subroutines can use relative references (backward or forward); ex: `\\g<+1>(.)\\g<-1>`.\n// - Subroutines don't get their own capturing group numbers; ex: `(.)\\g<1>\\2` is invalid.\n// - Subroutines use the flags that apply to their referenced group, so e.g.\n//   `(?-i)(?<a>a)(?i)\\g<a>` is fully case sensitive.\n// - Differences from PCRE/Perl/Regex+ subroutines:\n//   - Subroutines can't reference duplicate group names (though duplicate names are valid if no\n//     subroutines reference them).\n//   - Subroutines can't use absolute or relative numbers if named capture is used anywhere.\n//   - Named backrefs must be to the right of their group definition, so the backref in\n//     `\\g<a>\\k<a>(?<a>)` is invalid (not directly related to subroutines).\n//   - Subroutines don't restore capturing group match values (for backrefs) upon exit, so e.g.\n//     `(?<a>(?<b>[ab]))\\g<a>\\k<b>` matches `abb` but not `aba`; same for numbered.\n// The interaction of backref multiplexing (an Onig-specific feature) and subroutines is complex:\n// - Only the most recent value matched by a capturing group and its subroutines is considered for\n//   backref multiplexing, and this also applies to capturing groups nested within a group that's\n//   referenced by a subroutine.\n// - Although a subroutine can't reference a group with a duplicate name, it can reference a group\n//   with a nested capture whose name is duplicated (e.g. outside of the referenced group).\n//   - These duplicate names can then multiplex; but only the most recent value matched from within\n//     the outer group (or the subroutines that reference it) is available for multiplexing.\n//   - Ex: With `(?<a>(?<b>[123]))\\g<a>\\g<a>(?<b>0)\\k<b>`, the backref `\\k<b>` can only match `0`\n//     or whatever was matched by the most recently matched subroutine. If you took out `(?<b>0)`,\n//     no multiplexing would occur.\nfunction parseSubroutine(context) {\n  const {token, capturingGroups, subroutines} = context;\n  let ref = token.raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      '': num,\n      '+': numCapturesToLeft + num,\n      '-': numCapturesToLeft + 1 - num,\n    }[numberedRef.groups.sign];\n    if (ref < 1) {\n      throw new Error('Invalid subroutine number');\n    }\n  // Special case for full-pattern recursion; can't be `+0`, `-0`, `00`, etc.\n  } else if (ref === '0') {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\n\nfunction createAbsentFunction(kind) {\n  if (kind !== AstAbsentFunctionKinds.repeater) {\n    throw new Error(`Unexpected absent function kind \"${kind}\"`);\n  }\n  return {\n    type: AstTypes.AbsentFunction,\n    kind,\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createAlternative() {\n  return {\n    type: AstTypes.Alternative,\n    elements: [],\n  };\n}\n\nfunction createAssertion(kind, options) {\n  // Use `createLookaround` for lookahead and lookbehind assertions\n  const negate = !!options?.negate;\n  return {\n    type: AstTypes.Assertion,\n    kind,\n    ...(kind === AstAssertionKinds.word_boundary && {negate}),\n  };\n}\n\nfunction createAssertionFromToken({kind}) {\n  return createAssertion(\n    throwIfNot({\n      '^': AstAssertionKinds.line_start,\n      '$': AstAssertionKinds.line_end,\n      '\\\\A': AstAssertionKinds.string_start,\n      '\\\\b': AstAssertionKinds.word_boundary,\n      '\\\\B': AstAssertionKinds.word_boundary,\n      '\\\\G': AstAssertionKinds.search_start,\n      '\\\\z': AstAssertionKinds.string_end,\n      '\\\\Z': AstAssertionKinds.string_end_newline,\n    }[kind], `Unexpected assertion kind \"${kind}\"`),\n    {negate: kind === r`\\B`}\n  );\n}\n\nfunction createBackreference(ref, options) {\n  const orphan = !!options?.orphan;\n  return {\n    type: AstTypes.Backreference,\n    ...(orphan && {orphan}),\n    ref,\n  };\n}\n\nfunction createByGroupKind({flags, kind, name, negate, number}) {\n  switch (kind) {\n    case TokenGroupKinds.absent_repeater:\n      return createAbsentFunction(AstAbsentFunctionKinds.repeater);\n    case TokenGroupKinds.atomic:\n      return createGroup({atomic: true});\n    case TokenGroupKinds.capturing:\n      return createCapturingGroup(number, name);\n    case TokenGroupKinds.group:\n      return createGroup({flags});\n    case TokenGroupKinds.lookahead:\n    case TokenGroupKinds.lookbehind:\n      return createLookaround({\n        behind: kind === TokenGroupKinds.lookbehind,\n        negate,\n      });\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\n\nfunction createCapturingGroup(number, name) {\n  const hasName = name !== undefined;\n  if (hasName && !isValidGroupNameOniguruma(name)) {\n    throw new Error(`Group name \"${name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: AstTypes.CapturingGroup,\n    number,\n    ...(hasName && {name}),\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createCharacter(charCode, options) {\n  const opts = {\n    useLastValid: false,\n    ...options,\n  };\n  if (charCode > 0x10FFFF) {\n    const hex = charCode.toString(16);\n    if (opts.useLastValid) {\n      charCode = 0x10FFFF;\n    } else if (charCode > 0x13FFFF) {\n      throw new Error(`Invalid code point out of range \"\\\\x{${hex}}\"`);\n    } else {\n      throw new Error(`Invalid code point out of range in JS \"\\\\x{${hex}}\"`);\n    }\n  }\n  return {\n    type: AstTypes.Character,\n    value: charCode,\n  };\n}\n\nfunction createCharacterClass(options) {\n  const opts = {\n    baseOnly: false,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: AstTypes.CharacterClass,\n    negate: opts.negate,\n    elements: opts.baseOnly ? [] : [createCharacterClassIntersection()],\n  };\n}\n\nfunction createCharacterClassIntersection() {\n  return {\n    type: AstTypes.CharacterClassIntersection,\n    classes: [createCharacterClass({negate: false, baseOnly: true})],\n  };\n}\n\nfunction createCharacterClassRange(min, max) {\n  if (max.value < min.value) {\n    throw new Error('Character class range out of order');\n  }\n  return {\n    type: AstTypes.CharacterClassRange,\n    min,\n    max,\n  };\n}\n\nfunction createCharacterSet(kind, {negate}) {\n  const node = {\n    type: AstTypes.CharacterSet,\n    kind: throwIfNot(AstCharacterSetKinds[kind], `Unexpected character set kind \"${kind}\"`),\n  };\n  if (\n    kind === TokenCharacterSetKinds.digit ||\n    kind === TokenCharacterSetKinds.hex ||\n    kind === TokenCharacterSetKinds.space ||\n    kind === TokenCharacterSetKinds.word\n  ) {\n    node.negate = negate;\n  }\n  return node;\n}\n\nfunction createDirectiveFromToken({kind, flags}) {\n  const node = {\n    type: AstTypes.Directive,\n    kind: throwIfNot(AstDirectiveKinds[kind], `Unexpected directive kind \"${kind}\"`),\n  };\n  // Can't optimize by simply creating a `Group` with a `flags` prop and wrapping the remainder of\n  // the open group or pattern in it, because the flag modifier's effect might extend across\n  // alternation. Ex: `a(?i)b|c` is equivalent to `a(?i:b)|(?i:c)`, not `a(?i:b|c)`\n  if (kind === TokenDirectiveKinds.flags) {\n    node.flags = flags;\n  }\n  return node;\n}\n\nfunction createFlags({ignoreCase, dotAll, extended, digitIsAscii, spaceIsAscii, wordIsAscii}) {\n  return {\n    type: AstTypes.Flags,\n    ignoreCase,\n    dotAll,\n    extended,\n    digitIsAscii,\n    spaceIsAscii,\n    wordIsAscii,\n  };\n}\n\nfunction createGroup(options) {\n  const atomic = options?.atomic;\n  const flags = options?.flags;\n  return {\n    type: AstTypes.Group,\n    ...(atomic && {atomic}),\n    ...(flags && {flags}),\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createLookaround(options) {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: AstTypes.Assertion,\n    kind: opts.behind ? AstAssertionKinds.lookbehind : AstAssertionKinds.lookahead,\n    negate: opts.negate,\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createPattern() {\n  return {\n    type: AstTypes.Pattern,\n    alternatives: [createAlternative()],\n  };\n}\n\nfunction createQuantifier(element, min, max, greedy = true, possessive = false) {\n  const node = {\n    type: AstTypes.Quantifier,\n    min,\n    max,\n    greedy,\n    possessive,\n    element,\n  };\n  if (max < min) {\n    return {\n      ...node,\n      min: max,\n      max: min,\n      possessive: true,\n    };\n  }\n  return node;\n}\n\nfunction createRegex(pattern, flags) {\n  return {\n    type: AstTypes.Regex,\n    pattern,\n    flags,\n  };\n}\n\nfunction createSubroutine(ref) {\n  return {\n    type: AstTypes.Subroutine,\n    ref,\n  };\n}\n\nfunction createUnicodeProperty(value, options) {\n  const opts = {\n    negate: false,\n    skipPropertyNameValidation: false,\n    ...options,\n  };\n  return {\n    type: AstTypes.CharacterSet,\n    kind: AstCharacterSetKinds.property,\n    value: opts.skipPropertyNameValidation ? value : getJsUnicodePropertyName(value),\n    negate: opts.negate,\n  }\n}\n\nfunction createVariableLengthCharacterSet(kind) {\n  return {\n    type: AstTypes.VariableLengthCharacterSet,\n    kind: throwIfNot({\n      '\\\\R': AstVariableLengthCharacterSetKinds.newline,\n      '\\\\X': AstVariableLengthCharacterSetKinds.grapheme,\n    }[kind], `Unexpected varcharset kind \"${kind}\"`),\n  };\n}\n\n// Unlike Onig, JS Unicode property names are case sensitive, don't ignore spaces, hyphens, and\n// underscores, and require underscores in specific positions\nfunction getJsUnicodePropertyName(value) {\n  const slugged = slug(value);\n  if (JsUnicodePropertiesOfStringsMap.has(slugged)) {\n    // Variable-length properties of strings aren't supported by Onig\n    throw new Error(r`Unicode property \"\\p{${value}}\" unsupported in Oniguruma`);\n  }\n  const jsName = JsUnicodePropertiesMap.get(slugged);\n  if (jsName) {\n    return jsName;\n  }\n  // Assume it's a script name (avoids including heavyweight data for long list of script names);\n  // JS requires formatting `Like_This`, so use best effort to reformat the name (covers a lot, but\n  // isn't able to map for all possible formatting differences)\n  return value.\n    trim().\n    replace(/[- _]+/g, '_').\n    replace(/[A-Z][a-z]+(?=[A-Z])/g, '$&_'). // `PropertyName` to `Property_Name`\n    replace(/[A-Za-z]+/g, m => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\n\n// If a direct child group is needlessly nested, return it instead (after modifying it)\nfunction getOptimizedGroup(node) {\n  const firstAltFirstEl = node.alternatives[0].elements[0];\n  if (\n    node.type === AstTypes.Group &&\n    hasOnlyChild(node, kid => kid.type === AstTypes.Group) &&\n    !(node.atomic && firstAltFirstEl.flags) &&\n    !(node.flags && (firstAltFirstEl.atomic || firstAltFirstEl.flags))\n  ) {\n    if (node.atomic) {\n      firstAltFirstEl.atomic = true;\n    } else if (node.flags) {\n      firstAltFirstEl.flags = node.flags;\n    }\n    return firstAltFirstEl;\n  }\n  return node;\n}\n\nfunction isValidGroupNameOniguruma(name) {\n  // The more restrictive rules for valid JS group names are captured in `isValidGroupNameJs`. Note\n  // that backrefs and subroutines might contextually use `-` and `+` to indicate relative index or\n  // recursion level\n  return /^[\\p{Alpha}\\p{Pc}][^)]*$/u.test(name);\n}\n\n// For any intersection classes that contain only a class, swap the parent with its (modded) child\nfunction optimizeCharacterClassIntersection(intersection) {\n  for (let i = 0; i < intersection.classes.length; i++) {\n    const cc = intersection.classes[i];\n    const firstChild = cc.elements[0];\n    if (cc.elements.length === 1 && firstChild.type === AstTypes.CharacterClass) {\n      intersection.classes[i] = firstChild;\n      firstChild.negate = cc.negate !== firstChild.negate;\n    }\n  }\n}\n\nfunction throwIfUnclosedCharacterClass(token, firstClassToken) {\n  return throwIfNot(\n    token,\n    // Easier to understand error when applicable\n    `${firstClassToken?.value === 93 ? 'Empty' : 'Unclosed'} character class`\n  );\n}\n\nfunction throwIfUnclosedGroup(token) {\n  return throwIfNot(token, 'Unclosed group');\n}\n\nexport {\n  AstAbsentFunctionKinds,\n  AstAssertionKinds,\n  AstCharacterSetKinds,\n  AstDirectiveKinds,\n  AstTypes,\n  AstVariableLengthCharacterSetKinds,\n  createAbsentFunction,\n  createAlternative,\n  createAssertion,\n  createBackreference,\n  createCapturingGroup,\n  createCharacter,\n  createCharacterClass,\n  createCharacterClassIntersection,\n  createCharacterClassRange,\n  createCharacterSet,\n  createFlags,\n  createGroup,\n  createLookaround,\n  createPattern,\n  createQuantifier,\n  createRegex,\n  createSubroutine,\n  createUnicodeProperty,\n  createVariableLengthCharacterSet,\n  parse,\n};\n","import {Accuracy, Target} from './options.js';\nimport {AstAssertionKinds, AstCharacterSetKinds, AstDirectiveKinds, AstTypes, AstVariableLengthCharacterSetKinds, createAlternative, createAssertion, createBackreference, createCapturingGroup, createCharacterSet, createGroup, createLookaround, createQuantifier, createUnicodeProperty, parse} from './parse.js';\nimport {tokenize} from './tokenize.js';\nimport {traverse} from './traverse.js';\nimport {JsUnicodeProperties, PosixClassesMap} from './unicode.js';\nimport {cp, getNewCurrentFlags, getOrCreate, isMinTarget, r} from './utils.js';\nimport {hasOnlyChild, isAlwaysNonZeroLength, isAlwaysZeroLength, isConsumptiveGroup, isLookaround} from './utils-ast.js';\nimport emojiRegex from 'emoji-regex-xs';\n\n/**\n@typedef {{\n  type: 'Regex';\n  parent: null;\n  pattern: Object;\n  flags: Object;\n  options: Object;\n  _strategy: string | null;\n}} RegexAst\n*/\n/**\nTransforms an Oniguruma AST in-place to a [Regex+](https://github.com/slevithan/regex) AST.\nAssumes target ES2025, expecting the generator to down-convert to the desired JS target version.\n\nRegex+'s syntax and behavior is a strict superset of native JavaScript, so the AST is very close\nto representing native ES2025 `RegExp` but with some added features (atomic groups, possessive\nquantifiers, recursion). The AST doesn't use some of Regex+'s extended features like flag x or\nsubroutines because they follow PCRE behavior and work somewhat differently than in Oniguruma. The\nAST represents what's needed to precisely reproduce Oniguruma behavior using Regex+.\n@param {import('./parse.js').OnigurumaAst} ast\n@param {{\n  accuracy?: keyof Accuracy;\n  asciiWordBoundaries?: boolean;\n  avoidSubclass?: boolean;\n  bestEffortTarget?: keyof Target;\n}} [options]\n@returns {RegexAst}\n*/\nfunction transform(ast, options) {\n  const opts = {\n    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n    // - `VariableLengthCharacterSet` kind `grapheme` (`\\X`): An exact representation would require\n    //   heavy Unicode data; a best-effort approximation requires knowing the target.\n    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode-based\n    //   representations would be hard to change to ASCII-based after the fact in the generator\n    //   based on `target`/`accuracy`, so produce the appropriate structure here.\n    accuracy: 'default',\n    asciiWordBoundaries: false,\n    avoidSubclass: false,\n    bestEffortTarget: 'ES2025',\n    ...options,\n  };\n  const firstPassState = {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    flagDirectivesByAlt: new Map(),\n    jsGroupNameMap: new Map(),\n    minTargetEs2024: isMinTarget(opts.bestEffortTarget, 'ES2024'),\n    passedLookbehind: false,\n    strategy: null,\n    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n    subroutineRefMap: new Map(),\n    supportedGNodes: new Set(),\n    digitIsAscii: ast.flags.digitIsAscii,\n    spaceIsAscii: ast.flags.spaceIsAscii,\n    wordIsAscii: ast.flags.wordIsAscii,\n  };\n  traverse({node: ast}, firstPassState, FirstPassVisitor);\n  // Global flags modified by the first pass\n  const globalFlags = {\n    dotAll: ast.flags.dotAll,\n    ignoreCase: ast.flags.ignoreCase,\n  };\n  // The interplay of subroutines (with Onig's unique rules/behavior for them; see comments in the\n  // parser for details) with backref multiplexing (a unique Onig feature), flag modifiers, and\n  // duplicate group names (which might be indirectly referenced by subroutines even though\n  // subroutines can't directly reference duplicate names) is extremely complicated to emulate in\n  // JS in a way that handles all edge cases, so we need multiple passes to do it\n  const secondPassState = {\n    currentFlags: globalFlags,\n    prevFlags: null,\n    globalFlags,\n    groupOriginByCopy: new Map(),\n    groupsByName: new Map(),\n    multiplexCapturesToLeftByRef: new Map(),\n    openRefs: new Map(),\n    reffedNodesByReferencer: new Map(),\n    subroutineRefMap: firstPassState.subroutineRefMap,\n  };\n  traverse({node: ast}, secondPassState, SecondPassVisitor);\n  const thirdPassState = {\n    groupsByName: secondPassState.groupsByName,\n    highestOrphanBackref: 0,\n    numCapturesToLeft: 0,\n    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer,\n  };\n  traverse({node: ast}, thirdPassState, ThirdPassVisitor);\n  ast._strategy = firstPassState.strategy;\n  return ast;\n}\n\nconst FirstPassVisitor = {\n  AbsentFunction({node, replaceWith}) {\n    // Convert absent repeater `(?~…)` to `(?:(?:(?!…)\\p{Any})*)`\n    const group = prepContainer(createGroup(), [\n      adoptAndSwapKids(createLookaround({negate: true}), node.alternatives),\n      createUnicodeProperty('Any'),\n    ]);\n    const quantifier = createQuantifier(group, 0, Infinity);\n    group.parent = quantifier;\n    replaceWith(prepContainer(createGroup(), [quantifier]));\n  },\n\n  Alternative: {\n    enter({node, parent, key}, {flagDirectivesByAlt}) {\n      // Look for own-level flag directives when entering an alternative because after traversing\n      // the directive itself, any subsequent flag directives will no longer be at the same level\n      const flagDirectives = node.elements.filter(el => el.kind === AstDirectiveKinds.flags);\n      for (let i = key + 1; i < parent.alternatives.length; i++) {\n        const forwardSiblingAlt = parent.alternatives[i];\n        getOrCreate(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n      }\n    },\n    exit({node}, {flagDirectivesByAlt}) {\n      // Wait until exiting to wrap an alternative's nodes with flag groups that extend flag\n      // directives from prior sibling alternatives because doing this at the end allows inner\n      // nodes to accurately check their level in the tree\n      if (flagDirectivesByAlt.get(node)?.length) {\n        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n        if (flags) {\n          const flagGroup = prepContainer(createGroup({flags}), node.elements);\n          // Manually set the parent since we're not using `replaceWith`\n          flagGroup.parent = node;\n          node.elements = [flagGroup];\n        }\n      }\n    },\n  },\n\n  Assertion({node, key, container, ast, remove, replaceWith}, state) {\n    const {kind, negate} = node;\n    const {asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii} = state;\n    if (kind === AstAssertionKinds.line_end) {\n      // Onig's only line break char is line feed, unlike JS\n      replaceWith(parseFragment(r`(?=\\z|\\n)`));\n    } else if (kind === AstAssertionKinds.line_start) {\n      // Onig's only line break char is line feed, unlike JS. Onig's `^` doesn't match after a\n      // string-terminating line feed\n      replaceWith(parseFragment(r`(?<=\\A|\\n(?!\\z))`, {skipLookbehindValidation: true}));\n    } else if (kind === AstAssertionKinds.lookbehind) {\n      state.passedLookbehind = true;\n    } else if (kind === AstAssertionKinds.search_start) {\n      if (supportedGNodes.has(node)) {\n        ast.flags.sticky = true;\n        remove();\n      } else {\n        const prev = container[key - 1]; // parent.elements[key - 1]\n        // Not all ways of blocking the `\\G` from matching are covered (ex: a node prior to the\n        // prev node could block), but blocked `\\G` is an edge case so it's okay if some blocked\n        // cases resulting in the standard error for being unsupported\n        if (prev && isAlwaysNonZeroLength(prev)) {\n          replaceWith(prepContainer(createLookaround({negate: true})));\n        } else if (avoidSubclass) {\n          throw new Error(r`Uses \"\\G\" in a way that requires a subclass`);\n        } else {\n          replaceWith(createAssertion(AstAssertionKinds.string_start));\n          state.strategy = 'search_start_clip';\n        }\n      }\n    } else if (kind === AstAssertionKinds.string_end_newline) {\n      replaceWith(parseFragment(r`(?=\\n?\\z)`));\n    } else if (kind === AstAssertionKinds.word_boundary && !wordIsAscii && !asciiWordBoundaries) {\n      const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n      const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n      replaceWith(parseFragment(negate ? B : b));\n    }\n    // Kinds `string_end` and `string_start` don't need transformation since JS flag m isn't used.\n    // Kinds `lookahead` and `lookbehind` also don't need transformation\n  },\n\n  Backreference({node}, {jsGroupNameMap}) {\n    let {ref} = node;\n    if (typeof ref === 'string' && !isValidGroupNameJs(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n\n  CapturingGroup({node}, {jsGroupNameMap, subroutineRefMap}) {\n    let {name} = node;\n    if (name && !isValidGroupNameJs(name)) {\n      name = getAndStoreJsGroupName(name, jsGroupNameMap);\n      node.name = name;\n    }\n    subroutineRefMap.set(node.number, node);\n    if (name) {\n      subroutineRefMap.set(name, node);\n    }\n  },\n\n  CharacterSet({node, replaceWith}, {accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii}) {\n    const {kind, negate, value} = node;\n    // Flag D with `\\d`, `\\p{Digit}`, `[[:digit:]]`\n    if (digitIsAscii && (kind === AstCharacterSetKinds.digit || value === 'digit')) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.digit, {negate}));\n      return;\n    }\n    // Flag S with `\\s`, `\\p{Space}`, `[[:space:]]`\n    if (spaceIsAscii && (kind === AstCharacterSetKinds.space || value === 'space')) {\n      replaceWith(setNegate(parseFragment(asciiSpaceChar), negate));\n      return;\n    }\n    // Flag W with `\\w`, `\\p{Word}`, `[[:word:]]`\n    if (wordIsAscii && (kind === AstCharacterSetKinds.word || value === 'word')) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.word, {negate}));\n      return;\n    }\n    if (kind === AstCharacterSetKinds.any) {\n      replaceWith(createUnicodeProperty('Any'));\n    } else if (kind === AstCharacterSetKinds.digit) {\n      replaceWith(createUnicodeProperty('Nd', {negate}));\n    } else if (kind === AstCharacterSetKinds.hex) {\n      replaceWith(createUnicodeProperty('AHex', {negate}));\n    } else if (kind === AstCharacterSetKinds.non_newline) {\n      replaceWith(parseFragment(r`[^\\n]`));\n    } else if (kind === AstCharacterSetKinds.space) {\n      // Can't use JS's Unicode-based `\\s` since unlike Onig it includes `\\uFEFF`, excludes `\\x85`\n      replaceWith(createUnicodeProperty('space', {negate}));\n    } else if (kind === AstCharacterSetKinds.word) {\n      replaceWith(setNegate(parseFragment(defaultWordChar), negate));\n    } else if (kind === AstCharacterSetKinds.property) {\n      if (!JsUnicodeProperties.has(value)) {\n        // Assume it's a script; no error checking is the price for avoiding heavyweight Unicode\n        // data for all script names\n        node.key = 'sc';\n      }\n    } else if (kind === AstCharacterSetKinds.posix) {\n      if (!minTargetEs2024 && (value === 'graph' || value === 'print')) {\n        if (accuracy === 'strict') {\n          throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n        }\n        let ascii = {\n          graph: '!-~',\n          print: ' -~',\n        }[value];\n        if (negate) {\n          // POSIX classes are always nested in a char class; manually invert the range rather than\n          // using `[^…]` so it can be unwrapped since ES2018 doesn't support nested classes\n          ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n        }\n        replaceWith(parseFragment(`[${ascii}]`));\n      } else {\n        replaceWith(setNegate(parseFragment(PosixClassesMap.get(value)), negate));\n      }\n    }\n  },\n\n  Directive(path, state) {\n    const {node, parent, ast, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings} = path;\n    const {kind, flags} = node;\n    if (kind === AstDirectiveKinds.flags) {\n      if (!flags.enable && !flags.disable) {\n        // Flag directive without flags; ex: `(?-)`, `(?--)`\n        remove();\n      } else {\n        const flagGroup = prepContainer(createGroup({flags}), removeAllNextSiblings());\n        replaceWith(flagGroup);\n        traverseReplacement(flagGroup, path, state, FirstPassVisitor);\n      }\n    } else if (kind === AstDirectiveKinds.keep) {\n      const firstAltFirstEl = ast.pattern.alternatives[0].elements[0];\n      // Supporting a full-pattern wrapper around `\\K` enables use with flag modifiers\n      const hasWrapperGroup =\n        // Not emulatable if within a `CapturingGroup`\n        hasOnlyChild(ast.pattern, kid => kid.type === AstTypes.Group) &&\n        firstAltFirstEl.alternatives.length === 1;\n      const topLevel = hasWrapperGroup ? firstAltFirstEl : ast.pattern;\n      if (parent.parent !== topLevel || topLevel.alternatives.length > 1) {\n        throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n      }\n      replaceWith(prepContainer(createLookaround({behind: true}), removeAllPrevSiblings()));\n    }\n  },\n\n  Flags({node, parent}) {\n    // Remove Onig flags that aren't available in JS\n    [ 'digitIsAscii', // Flag D\n      'extended', // Flag x\n      'spaceIsAscii', // Flag S\n      'wordIsAscii', // Flag W\n    ].forEach(f => delete node[f]);\n    Object.assign(node, {\n      // JS flag g; no Onig equiv\n      global: false,\n      // JS flag d; no Onig equiv\n      hasIndices: false,\n      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n      // results (also allows `^` and `$` to be used in the generator for string start and end)\n      multiline: false,\n      // JS flag y; no Onig equiv, but used for `\\G` emulation\n      sticky: node.sticky ?? false,\n      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out\n      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values\n      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)\n    });\n    // Options accepted by Regex+; see <github.com/slevithan/regex#-options>\n    parent.options = {\n      disable: {\n        // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n        x: true,\n        // Onig has no flag to control \"named capture only\" mode but contextually applies its\n        // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n        n: true,\n      },\n      force: {\n        // Always add flag v because we're generating an AST that relies on it (it enables JS\n        // support for Onig features nested classes, set intersection, Unicode properties, etc.).\n        // However, the generator might disable flag v based on its `target` option\n        v: true,\n      },\n    };\n  },\n\n  Group({node}) {\n    if (!node.flags) {\n      return;\n    }\n    const {enable, disable} = node.flags;\n    // Onig's flag x (`extended`) isn't available in JS\n    enable?.extended && delete enable.extended;\n    disable?.extended && delete disable.extended;\n    // JS doesn't support flag groups that enable and disable the same flag; ex: `(?i-i:)`\n    enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n    // Cleanup\n    enable && !Object.keys(enable).length && delete node.flags.enable;\n    disable && !Object.keys(disable).length && delete node.flags.disable;\n    !node.flags.enable && !node.flags.disable && delete node.flags;\n  },\n\n  Pattern: {\n    enter({node}, {supportedGNodes}) {\n      // For `\\G` to be accurately emulatable using JS flag y, it must be at (and only at) the start\n      // of every top-level alternative (with complex rules for what determines being at the start).\n      // Additional `\\G` error checking in `Assertion` visitor\n      const leadingGs = [];\n      let hasAltWithLeadG = false;\n      let hasAltWithoutLeadG = false;\n      for (const alt of node.alternatives) {\n        if (alt.elements.length === 1 && alt.elements[0].kind === AstAssertionKinds.search_start) {\n          // Remove the `\\G` (leaving behind an empty alternative, and without adding JS flag y)\n          // since a top-level alternative that includes only `\\G` always matches at the start of the\n          // match attempt. Note that this is based on Oniguruma's rules, and is different than other\n          // regex flavors where `\\G` matches at the end of the previous match (a subtle distinction\n          // that's relevant after zero-length matches)\n          alt.elements.pop();\n        } else {\n          const leadingG = getLeadingG(alt.elements);\n          if (leadingG) {\n            hasAltWithLeadG = true;\n            Array.isArray(leadingG) ?\n              leadingGs.push(...leadingG) :\n              leadingGs.push(leadingG);\n          } else {\n            hasAltWithoutLeadG = true;\n          }\n        }\n      }\n      if (hasAltWithLeadG && !hasAltWithoutLeadG) {\n        // Supported `\\G` nodes will be removed (and add flag y) when traversed\n        leadingGs.forEach(g => supportedGNodes.add(g));\n      }\n    },\n    exit(_, {accuracy, passedLookbehind, strategy}) {\n      if (accuracy === 'strict' && passedLookbehind && strategy) {\n        throw new Error(r`Uses \"\\G\" in a way that requires non-strict accuracy`);\n      }\n    },\n  },\n\n  Quantifier({node}) {\n    if (node.element.type === AstTypes.Quantifier) {\n      // Change e.g. `a**` to `(?:a*)*`\n      const group = prepContainer(createGroup(), [node.element]);\n      // Manually set the parent since we're not using `replaceWith`\n      group.parent = node;\n      node.element = group;\n    }\n  },\n\n  Subroutine({node}, {jsGroupNameMap}) {\n    let {ref} = node;\n    if (typeof ref === 'string' && !isValidGroupNameJs(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n\n  VariableLengthCharacterSet({node, replaceWith}, {accuracy, minTargetEs2024}) {\n    const {kind} = node;\n    if (kind === AstVariableLengthCharacterSetKinds.newline) {\n      replaceWith(parseFragment('(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])'));\n    } else if (kind === AstVariableLengthCharacterSetKinds.grapheme) {\n      if (accuracy === 'strict') {\n        throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n      }\n      // `emojiRegex` is more permissive than `\\p{RGI_Emoji}` since it allows over/under-qualified\n      // emoji using a general pattern that matches any Unicode sequence following the structure of\n      // a valid emoji. That actually makes it more accurate for matching any grapheme\n      const emoji = minTargetEs2024 ? r`\\p{RGI_Emoji}` : emojiRegex().source.replace(/\\\\u\\{/g, `\\\\x{`);\n      // Close approximation of an extended grapheme cluster. Details: <unicode.org/reports/tr29/>.\n      // Skip name check to allow `RGI_Emoji` through, which Onig doesn't support\n      replaceWith(parseFragment(r`(?>\\r\\n|${emoji}|\\P{M}\\p{M}*)`, {skipPropertyNameValidation: true}));\n    } else {\n      throw new Error(`Unexpected varcharset kind \"${kind}\"`);\n    }\n  },\n};\n\nconst SecondPassVisitor = {\n  Backreference({node}, {multiplexCapturesToLeftByRef, reffedNodesByReferencer}) {\n    const {orphan, ref} = node;\n    if (!orphan) {\n      // Copy the current state for later multiplexing expansion. That's done in a subsequent pass\n      // because backref numbers need to be recalculated after subroutine expansion\n      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({node}) => node)]);\n    }\n  },\n\n  CapturingGroup: {\n    enter(\n      { node,\n        replaceWith,\n        skip,\n      },\n      { groupOriginByCopy,\n        groupsByName,\n        multiplexCapturesToLeftByRef,\n        openRefs,\n        reffedNodesByReferencer,\n      }\n    ) {\n      // Has value if we're within a subroutine expansion\n      const origin = groupOriginByCopy.get(node);\n\n      // ## Handle recursion; runs after subroutine expansion\n      if (origin && openRefs.has(node.number)) {\n        // Recursion doesn't affect any following backrefs to its `ref` (unlike other subroutines),\n        // so don't wrap with a capture. The reffed group might have its name removed due to later\n        // subroutine expansion\n        const recursion = createRecursion(node.number);\n        reffedNodesByReferencer.set(recursion, openRefs.get(node.number));\n        replaceWith(recursion);\n        // This node's kids have been removed from the tree, so no need to traverse them\n        skip();\n        return;\n      }\n      openRefs.set(node.number, node);\n\n      // ## Track data for backref multiplexing\n      multiplexCapturesToLeftByRef.set(node.number, []);\n      if (node.name) {\n        getOrCreate(multiplexCapturesToLeftByRef, node.name, []);\n      }\n      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n      for (let i = 0; i < multiplexNodes.length; i++) {\n        // Captures added via subroutine expansion (maybe indirectly because they were descendant\n        // captures of the reffed group or in a nested subroutine expansion) form a set with their\n        // origin group and any other copies of it added via subroutines. Only the most recently\n        // matched within this set is added to backref multiplexing. So search the list of already-\n        // tracked multiplexed nodes for this group name or number to see if there's a node being\n        // replaced by this capture\n        const multiplex = multiplexNodes[i];\n        if (\n          // This group is from subroutine expansion, and there's a multiplex value from either the\n          // origin node or a prior subroutine expansion group with the same origin\n          (origin === multiplex.node || (origin && origin === multiplex.origin)) ||\n          // This group is not from subroutine expansion, and it comes after a subroutine expansion\n          // group that refers to this group\n          node === multiplex.origin\n        ) {\n          multiplexNodes.splice(i, 1);\n          break;\n        }\n      }\n      multiplexCapturesToLeftByRef.get(node.number).push({node, origin});\n      if (node.name) {\n        multiplexCapturesToLeftByRef.get(node.name).push({node, origin});\n      }\n\n      // ## Track data for duplicate names\n      // Pre-ES2025 doesn't allow duplicate names, but ES2025 allows duplicate names that are\n      // unique per mutually exclusive alternation path. However, Oniguruma's handling for named\n      // subpatterns on match results means we can't use this ES2025 feature even when in an ES2025\n      // env. So, if using a duplicate name, remove the name from all but the first instance that\n      // wasn't created by subroutine expansion\n      if (node.name) {\n        const groupsWithSameName = getOrCreate(groupsByName, node.name, new Map());\n        let hasDuplicateNameToRemove = false;\n        if (origin) {\n          // Subroutines and their child captures shouldn't hold duplicate names in the final state\n          hasDuplicateNameToRemove = true;\n        } else {\n          for (const groupInfo of groupsWithSameName.values()) {\n            if (!groupInfo.hasDuplicateNameToRemove) {\n              // Will change to an unnamed capture in a later pass\n              hasDuplicateNameToRemove = true;\n              break;\n            }\n          }\n        }\n        groupsByName.get(node.name).set(node, {node, hasDuplicateNameToRemove});\n      }\n      if (origin) {\n        // Used by the generator to handle subroutines and their child captures as emulation groups\n        node._originNumber = origin.number;\n      }\n    },\n    exit({node}, {openRefs}) {\n      openRefs.delete(node.number);\n    },\n  },\n\n  Group: {\n    enter({node}, state) {\n      // Flag directives have already been converted to flag groups by the previous pass\n      state.prevFlags = state.currentFlags;\n      if (node.flags) {\n        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n      }\n    },\n    exit(_, state) {\n      state.currentFlags = state.prevFlags;\n    },\n  },\n\n  Recursion({node, parent}, {reffedNodesByReferencer}) {\n    // Recursion nodes are created during the current traversal; they're only traversed here if a\n    // recursion node created during traversal is then copied by a subroutine expansion, e.g. with\n    // `(?<a>\\g<a>)\\g<a>`\n    const {ref} = node;\n    // Immediate parent is an alternative or quantifier; can skip\n    let reffed = parent;\n    while ((reffed = reffed.parent)) {\n      if (reffed.type === AstTypes.CapturingGroup && (reffed.name === ref || reffed.number === ref)) {\n        break;\n      }\n    }\n    // Track the referenced node because `ref`s are rewritten in a subsequent pass; capturing group\n    // names and numbers might change due to subroutine expansion and duplicate group names\n    reffedNodesByReferencer.set(node, reffed);\n  },\n\n  Subroutine(path, state) {\n    const {node, replaceWith} = path;\n    const {ref} = node;\n    const reffedGroupNode = state.subroutineRefMap.get(ref);\n    // Other forms of recursion are handled by the `CapturingGroup` visitor\n    const isGlobalRecursion = ref === 0;\n    const expandedSubroutine = isGlobalRecursion ?\n      createRecursion(0) :\n      // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null);\n    let replacement = expandedSubroutine;\n    if (!isGlobalRecursion) {\n      // Subroutines take their flags from the reffed group, not the flags surrounding themselves\n      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, node => {\n        return node.type === AstTypes.Group && !!node.flags;\n      }));\n      const reffedGroupFlags = reffedGroupFlagMods ?\n        getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) :\n        state.globalFlags;\n      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n        replacement = prepContainer(createGroup({\n          flags: getFlagModsFromFlags(reffedGroupFlags),\n        }), [expandedSubroutine]);\n      }\n    }\n    replaceWith(replacement);\n    if (!isGlobalRecursion) {\n      traverseReplacement(replacement, path, state, SecondPassVisitor);\n    }\n  },\n};\n\nconst ThirdPassVisitor = {\n  Backreference({node, replaceWith}, state) {\n    if (node.orphan) {\n      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n      // Don't renumber; used with `allowOrphanBackrefs`\n      return;\n    }\n    const reffedNodes = state.reffedNodesByReferencer.get(node);\n    const participants = reffedNodes.filter(reffed => canParticipateWithNode(reffed, node));\n    // For the backref's `ref`, use `number` rather than `name` because group names might have been\n    // removed if they're duplicates within their alternation path, or they might be removed later\n    // by the generator (depending on target) if they're duplicates within the overall pattern.\n    // Backrefs must come after groups they ref, so reffed node `number`s are already recalculated\n    if (!participants.length) {\n      // If no participating capture, convert backref to to `(?!)`; backrefs to nonparticipating\n      // groups can't match in Onig but match the empty string in JS\n      replaceWith(prepContainer(createLookaround({negate: true})));\n    } else if (participants.length > 1) {\n      // Multiplex\n      const alts = participants.map(reffed => adoptAndSwapKids(\n        createAlternative(),\n        [createBackreference(reffed.number)]\n      ));\n      replaceWith(adoptAndSwapKids(createGroup(), alts));\n    } else {\n      node.ref = participants[0].number;\n    }\n  },\n\n  CapturingGroup({node}, state) {\n    // Recalculate the number since the current value might be wrong due to subroutine expansion\n    node.number = ++state.numCapturesToLeft;\n    if (node.name) {\n      // Removing duplicate names here rather than in an earlier pass avoids extra complexity when\n      // handling subroutine expansion and backref multiplexing\n      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n        delete node.name;\n      }\n    }\n  },\n\n  Recursion({node}, state) {\n    if (node.ref === 0) {\n      return;\n    }\n    // For the recursion's `ref`, use `number` rather than `name` because group names might have\n    // been removed if they're duplicates within their alternation path, or they might be removed\n    // later by the generator (depending on target) if they're duplicates within the overall\n    // pattern. Since recursion appears within the group it refs, the reffed node's `number` has\n    // already been recalculated\n    node.ref = state.reffedNodesByReferencer.get(node).number;\n  },\n\n  Regex: {\n    exit({node}, state) {\n      // [HACK] Add unnamed captures to the end of the regex if needed to allow orphaned backrefs\n      // to be valid in JS with flag u/v. This is needed to support TextMate grammars, which\n      // replace numbered backrefs in their `end` pattern with values matched by captures in their\n      // `begin` pattern! See <github.com/microsoft/vscode-textmate/blob/7e0ea282f4f25fef12a6c84fa4fa7266f67b58dc/src/rule.ts#L661-L663>\n      // An `end` pattern, prior to this substitution, might have backrefs to a group that doesn't\n      // exist within `end`. This presents a dilemma since both Oniguruma and JS (with flag u/v)\n      // error for backrefs to undefined captures. So adding captures to the end is a solution that\n      // doesn't change what the regex matches, and lets invalid numbered backrefs through. Note:\n      // Orphan backrefs are only allowed if `allowOrphanBackrefs` is enabled\n      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n      for (let i = 0; i < numCapsNeeded; i++) {\n        const emptyCapture = createCapturingGroup();\n        node.pattern.alternatives.at(-1).elements.push(emptyCapture);\n      }\n    },\n  },\n};\n\n// `\\t\\n\\v\\f\\r\\x20`\nconst asciiSpaceChar = '[\\t-\\r ]';\n// Different than `PosixClassesMap`'s `word`\nconst defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\n\nfunction adoptAndSwapKids(parent, kids) {\n  kids.forEach(kid => kid.parent = parent);\n  parent[getContainerAccessor(parent)] = kids;\n  return parent;\n}\n\nfunction areFlagsEqual(a, b) {\n  return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\n\nfunction canParticipateWithNode(capture, node) {\n  // Walks to the left (prev siblings), down (sibling descendants), up (parent), then back down\n  // (parent's prev sibling descendants) the tree in a loop\n  let rightmostPoint = node;\n  do {\n    if (rightmostPoint.type === AstTypes.Pattern) {\n      // End of the line; capture is not in node's alternation path\n      return false;\n    }\n    if (rightmostPoint.type === AstTypes.Alternative) {\n      // Skip past alts to their parent because we don't want to look at the kids of preceding alts\n      continue;\n    }\n    if (rightmostPoint === capture) {\n      // Capture is ancestor of node\n      return false;\n    }\n    const kidsOfParent = getKids(rightmostPoint.parent);\n    for (const kid of kidsOfParent) {\n      if (kid === rightmostPoint) {\n        // Reached rightmost node in sibling list that we want to consider; break to parent loop\n        break;\n      }\n      if (kid === capture) {\n        return true;\n      }\n      if (hasDescendant(kid, capture)) {\n        return true;\n      }\n    }\n  } while ((rightmostPoint = rightmostPoint.parent));\n  throw new Error('Unexpected path');\n}\n\n// Creates a deep copy of the provided node, with special handling:\n// - Make `parent` props point to their parent in the copy\n// - Update the provided `originMap` for each cloned capturing group (outer and nested)\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n  const store = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === 'parent') {\n      // If the last cloned item was a container array (for holding kids), use the object above it\n      store.parent = Array.isArray(up) ? up2 : up;\n    } else if (value && typeof value === 'object') {\n      store[key] = cloneCapturingGroup(value, originMap, store, up);\n    } else {\n      if (key === 'type' && value === AstTypes.CapturingGroup) {\n        // Key is the copied node, value is the origin node\n        originMap.set(store, originMap.get(obj) ?? obj);\n      }\n      store[key] = value;\n    }\n  }\n  return store;\n}\n\n// `Recursion` nodes are used only by the transformer\nfunction createRecursion(ref) {\n  return {\n    type: AstTypes.Recursion,\n    ref,\n  };\n}\n\nfunction getAllParents(node, filterFn) {\n  const results = [];\n  while ((node = node.parent)) {\n    if (!filterFn || filterFn(node)) {\n      results.push(node);\n    }\n  }\n  return results;\n}\n\n// See also `isValidGroupNameJs`\nfunction getAndStoreJsGroupName(name, map) {\n  if (map.has(name)) {\n    return map.get(name);\n  }\n  // Onig group names can't start with `$`, but JS names can\n  const jsName = `$${map.size}_${name.replace(/^[^$_\\p{IDS}]|[^$\\u200C\\u200D\\p{IDC}]/ug, '_')}`;\n  map.set(name, jsName);\n  return jsName;\n}\n\n// Returns the string key for the container that holds the node's kids\nfunction getContainerAccessor(node) {\n  for (const accessor of ['alternatives', 'classes', 'elements']) {\n    if (node[accessor]) {\n      return accessor;\n    }\n  }\n  return null;\n}\n\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n  const flagProps = ['dotAll', 'ignoreCase'];\n  const combinedFlags = {enable: {}, disable: {}};\n  flagNodes.forEach(({flags}) => {\n    flagProps.forEach(prop => {\n      if (flags.enable?.[prop]) {\n        // Need to remove `disable` since disabled flags take precedence\n        delete combinedFlags.disable[prop];\n        combinedFlags.enable[prop] = true;\n      }\n      if (flags.disable?.[prop]) {\n        combinedFlags.disable[prop] = true;\n      }\n    });\n  });\n  if (!Object.keys(combinedFlags.enable).length) {\n    delete combinedFlags.enable;\n  }\n  if (!Object.keys(combinedFlags.disable).length) {\n    delete combinedFlags.disable;\n  }\n  if (combinedFlags.enable || combinedFlags.disable) {\n    return combinedFlags;\n  }\n  return null;\n}\n\nfunction getFlagModsFromFlags({dotAll, ignoreCase}) {\n  const mods = {};\n  if (dotAll || ignoreCase) {\n    mods.enable = {};\n    dotAll && (mods.enable.dotAll = true);\n    ignoreCase && (mods.enable.ignoreCase = true);\n  }\n  if (!dotAll || !ignoreCase) {\n    mods.disable = {};\n    !dotAll && (mods.disable.dotAll = true);\n    !ignoreCase && (mods.disable.ignoreCase = true);\n  }\n  return mods;\n}\n\nfunction getKids(node) {\n  if (!node) {\n    throw new Error('Node expected');\n  }\n  // [NOTE] Not handling `Regex` kids (`pattern`, `flags`) and `CharacterClassRange` kids (`min`,\n  // `max`) only because not needed by current callers\n  if (node.type === AstTypes.Quantifier) {\n    return [node.element];\n  }\n  const accessor = getContainerAccessor(node);\n  return accessor && node[accessor];\n}\n\nfunction getLeadingG(els) {\n  const firstToConsider = els.find(el => (\n    el.kind === AstAssertionKinds.search_start ||\n    isLoneGLookaround(el, {negate: false}) ||\n    !isAlwaysZeroLength(el)\n  ));\n  if (!firstToConsider) {\n    return null;\n  }\n  if (firstToConsider.kind === AstAssertionKinds.search_start) {\n    return firstToConsider;\n  }\n  if (isLookaround(firstToConsider)) {\n    return firstToConsider.alternatives[0].elements[0];\n  }\n  if (isConsumptiveGroup(firstToConsider)) {\n    const gNodesForGroup = [];\n    // Recursively find `\\G` nodes for all alternatives in the group\n    for (const alt of firstToConsider.alternatives) {\n      const leadingG = getLeadingG(alt.elements);\n      if (!leadingG) {\n        // Don't return `gNodesForGroup` collected so far since this alt didn't qualify\n        return null;\n      }\n      Array.isArray(leadingG) ?\n        gNodesForGroup.push(...leadingG) :\n        gNodesForGroup.push(leadingG);\n    }\n    return gNodesForGroup;\n  }\n  return null;\n}\n\nfunction hasDescendant(node, descendant) {\n  const kids = getKids(node) ?? [];\n  for (const kid of kids) {\n    if (\n      kid === descendant ||\n      hasDescendant(kid, descendant)\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isLoneGLookaround(node, options) {\n  const opts = {\n    negate: null,\n    ...options,\n  };\n  return (\n    isLookaround(node) &&\n    (opts.negate === null || node.negate === opts.negate) &&\n    hasOnlyChild(node, kid => kid.kind === AstAssertionKinds.search_start)\n  );\n}\n\n// See also `getAndStoreJsGroupName`\nfunction isValidGroupNameJs(name) {\n  // JS group names are more restrictive than Onig; see `isValidGroupNameOniguruma` and\n  // <developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers>\n  return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\n\n// Returns a single node, either the given node or all nodes wrapped in a noncapturing group\nfunction parseFragment(pattern, options) {\n  const ast = parse(tokenize(pattern), options);\n  const alts = ast.pattern.alternatives;\n  if (alts.length > 1 || alts[0].elements.length > 1) {\n    return adoptAndSwapKids(createGroup(), alts);\n  }\n  return alts[0].elements[0];\n}\n\nfunction prepContainer(node, kids) {\n  const accessor = getContainerAccessor(node);\n  // Set the parent for the default container of a new node\n  node[accessor][0].parent = node;\n  if (kids) {\n    adoptAndSwapKids(node[accessor][0], kids);\n  }\n  return node;\n}\n\nfunction setNegate(node, negate) {\n  node.negate = negate;\n  return node;\n}\n\nfunction traverseReplacement(replacement, {parent, key, container}, state, visitor) {\n  traverse({\n    // Don't use the `node` from `path`\n    node: replacement,\n    parent,\n    key,\n    container,\n  }, state, visitor);\n}\n\nexport {\n  transform,\n};\n","import {getOptions} from './options.js';\nimport {AstAssertionKinds, AstCharacterSetKinds, AstTypes} from './parse.js';\nimport {traverse} from './traverse.js';\nimport {getIgnoreCaseMatchChars, UnicodePropertiesWithSpecificCase} from './unicode.js';\nimport {cp, getNewCurrentFlags, isMinTarget, r} from './utils.js';\nimport {isLookaround} from './utils-ast.js';\nimport {emulationGroupMarker} from 'regex/internals';\n\n/**\nGenerates a Regex+ compatible `pattern`, `flags`, and `options` from a Regex+ AST.\n@param {import('./transform.js').RegexAst} ast\n@param {import('.').OnigurumaToEsOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n  options: Object;\n}}\n*/\nfunction generate(ast, options) {\n  const opts = getOptions(options);\n  const minTargetEs2024 = isMinTarget(opts.target, 'ES2024');\n  const minTargetEs2025 = isMinTarget(opts.target, 'ES2025');\n  const recursionLimit = opts.rules.recursionLimit;\n  if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {\n    throw new Error('Invalid recursionLimit; use 2-20');\n  }\n\n  // If the output can't use flag groups, we need a pre-pass to check for the use of chars with\n  // case in case sensitive/insensitive states. This minimizes the need for case expansions (though\n  // expansions are lossless, even given Unicode case complexities) and allows supporting case\n  // insensitive backrefs in more cases\n  // [TODO] Consider gathering this data in the transformer's final traversal to avoid work here\n  let hasCaseInsensitiveNode = null;\n  let hasCaseSensitiveNode = null;\n  if (!minTargetEs2025) {\n    const iStack = [ast.flags.ignoreCase];\n    traverse({node: ast}, {\n      getCurrentModI: () => iStack.at(-1),\n      popModI() {iStack.pop()},\n      pushModI(isIOn) {iStack.push(isIOn)},\n      setHasCasedChar() {\n        if (iStack.at(-1)) {\n          hasCaseInsensitiveNode = true;\n        } else {\n          hasCaseSensitiveNode = true;\n        }\n      },\n    }, FlagModifierVisitor);\n  }\n\n  const appliedGlobalFlags = {\n    dotAll: ast.flags.dotAll,\n    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n    //   used (to avoid unnecessary node expansion).\n    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n    //   forced without the use of ES2025 flag groups)\n    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode),\n  };\n  let lastNode = null;\n  const state = {\n    accuracy: opts.accuracy,\n    appliedGlobalFlags,\n    avoidSubclass: opts.avoidSubclass,\n    captureMap: new Map(),\n    currentFlags: {\n      dotAll: ast.flags.dotAll,\n      ignoreCase: ast.flags.ignoreCase,\n    },\n    inCharClass: false,\n    lastNode,\n    recursionLimit,\n    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n    useFlagMods: minTargetEs2025,\n    useFlagV: minTargetEs2024,\n    verbose: opts.verbose,\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    switch (node.type) {\n      case AstTypes.Regex:\n        // Final result is an object; other node types return strings\n        return {\n          pattern: gen(node.pattern),\n          flags: gen(node.flags),\n          options: {...node.options},\n        };\n      case AstTypes.Alternative:\n        return node.elements.map(gen).join('');\n      case AstTypes.Assertion:\n        return genAssertion(node, state, gen);\n      case AstTypes.Backreference:\n        return genBackreference(node, state);\n      case AstTypes.CapturingGroup:\n        return genCapturingGroup(node, state, gen);\n      case AstTypes.Character:\n        return genCharacter(node, state);\n      case AstTypes.CharacterClass:\n        return genCharacterClass(node, state, gen);\n      case AstTypes.CharacterClassIntersection:\n        if (!state.useFlagV) {\n          throw new Error('Use of class intersection requires min target ES2024');\n        }\n        return node.classes.map(gen).join('&&');\n      case AstTypes.CharacterClassRange:\n        return genCharacterClassRange(node, state);\n      case AstTypes.CharacterSet:\n        return genCharacterSet(node, state);\n      case AstTypes.Flags:\n        return genFlags(node, state);\n      case AstTypes.Group:\n        return genGroup(node, state, gen);\n      case AstTypes.Pattern:\n        return node.alternatives.map(gen).join('|');\n      case AstTypes.Quantifier:\n        return gen(node.element) + getQuantifierStr(node);\n      case AstTypes.Recursion:\n        return genRecursion(node, state);\n      default:\n        // Node types `AbsentFunction`, `Directive`, `Subroutine`, and `VariableLengthCharacterSet`\n        // are never included in transformer output\n        throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n  }\n\n  const result = gen(ast);\n  if (!minTargetEs2024) {\n    // Switch from flag v to u. By default, Regex+ implicitly chooses; control it instead\n    delete result.options.force.v;\n    result.options.disable.v = true;\n    result.options.unicodeSetsPlugin = null;\n  }\n  return result;\n}\n\nconst FlagModifierVisitor = {\n  AnyGroup: {\n    enter({node}, state) {\n      const currentModI = state.getCurrentModI();\n      state.pushModI(\n        node.flags ?\n          getNewCurrentFlags({ignoreCase: currentModI}, node.flags).ignoreCase :\n          currentModI\n      );\n    },\n    exit(_, state) {\n      state.popModI();\n    },\n  },\n  Backreference(_, state) {\n    // Can't know for sure, so assume the backref will include chars with case (best that could be\n    // done is not calling `setHasCasedChar` if the reffed group doesn't contain a char with case\n    // or most kinds of char sets)\n    state.setHasCasedChar();\n  },\n  Character({node}, state) {\n    if (charHasCase(cp(node.value))) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterClassRange({node, skip}, state) {\n    skip();\n    if (getCasesOutsideCharClassRange(node, {firstOnly: true}).length) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterSet({node}, state) {\n    if (\n      node.kind === AstCharacterSetKinds.property &&\n      UnicodePropertiesWithSpecificCase.has(node.value)\n    ) {\n      state.setHasCasedChar();\n    }\n  },\n};\n\nconst BaseEscapeChars = new Set([\n  '$', '(', ')', '*', '+', '.', '?', '[', '\\\\', ']', '^', '{', '|', '}',\n]);\nconst CharClassEscapeChars = new Set([\n  '-', '\\\\', ']', '^',\n  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n  // linters and regex syntax processors that expect unescaped `[` to create a nested class\n  '[',\n]);\nconst CharClassEscapeCharsFlagV = new Set([\n  '(', ')', '-', '/', '[', '\\\\', ']', '^', '{', '|', '}',\n  // Double punctuators; also includes already-listed `-` and `^`\n  '!', '#', '$', '%', '&', '*', '+', ',', '.', ':', ';', '<', '=', '>', '?', '@', '`', '~',\n]);\nconst CharCodeEscapeMap = new Map([\n  [ 9, r`\\t`], // horizontal tab\n  [10, r`\\n`], // line feed\n  [11, r`\\v`], // vertical tab\n  [12, r`\\f`], // form feed\n  [13, r`\\r`], // carriage return\n  [0x2028, r`\\u2028`], // line separator\n  [0x2029, r`\\u2029`], // paragraph separator\n  [0xFEFF, r`\\uFEFF`], // ZWNBSP/BOM\n]);\n\nconst casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n  return casedRe.test(char);\n}\n\nfunction genAssertion(node, _, gen) {\n  const {kind, negate, alternatives} = node;\n  if (isLookaround(node)) {\n    const prefix = `${kind === AstAssertionKinds.lookahead ? '' : '<'}${negate ? '!' : '='}`;\n    return `(?${prefix}${alternatives.map(gen).join('|')})`;\n  }\n  // Can always use `^` and `$` for string boundaries since JS flag m is never relied on; Onig uses\n  // different line break chars\n  if (kind === AstAssertionKinds.string_end) {\n    return '$';\n  }\n  if (kind === AstAssertionKinds.string_start) {\n    return '^';\n  }\n  // If a word boundary came through the transformer unaltered, that means `wordIsAscii` or\n  // `asciiWordBoundaries` is enabled\n  if (kind === AstAssertionKinds.word_boundary) {\n    return negate ? r`\\B` : r`\\b`;\n  }\n  // Kinds `line_end`, `line_start`, `search_start`, and `string_end_newline` are never included in\n  // transformer output\n  throw new Error(`Unexpected assertion kind \"${kind}\"`);\n}\n\nfunction genBackreference({ref}, state) {\n  if (typeof ref !== 'number') {\n    throw new Error('Unexpected named backref in transformed AST');\n  }\n  if (\n    !state.useFlagMods &&\n    state.accuracy === 'strict' &&\n    state.currentFlags.ignoreCase &&\n    !state.captureMap.get(ref).ignoreCase\n  ) {\n    throw new Error('Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy');\n  }\n  return '\\\\' + ref;\n}\n\nfunction genCapturingGroup({name, number, alternatives, _originNumber}, state, gen) {\n  state.captureMap.set(number, {ignoreCase: state.currentFlags.ignoreCase});\n  return `(${\n    name ? `?<${name}>` : ''\n  }${\n    !state.avoidSubclass && _originNumber ?\n      // All captures from/within expanded subroutines are marked as emulation groups, and some are\n      // specially marked as emulation groups with transfer. `number` is based on the pattern after\n      // subroutine expansion, whereas `_originNumber` points to the origin capture of an expanded\n      // subroutine (or child capture) *prior* to subroutine expansion. `_originNumber` is\n      // `undefined` if the current capture isn't from an expanded subroutine\n      `${_originNumber < number ? `$${_originNumber}` : ''}${emulationGroupMarker}` :\n      ''\n  }${\n    alternatives.map(gen).join('|')\n  })`;\n}\n\nfunction genCharacter({value}, state) {\n  const char = cp(value);\n  const escaped = getCharEscape(value, {\n    isAfterBackref: state.lastNode.type === AstTypes.Backreference,\n    inCharClass: state.inCharClass,\n    useFlagV: state.useFlagV,\n  });\n  if (escaped !== char) {\n    return escaped;\n  }\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n    const cases = getIgnoreCaseMatchChars(char);\n    return state.inCharClass ?\n      cases.join('') :\n      (cases.length > 1 ? `[${cases.join('')}]` : cases[0]);\n  }\n  return char;\n}\n\nfunction genCharacterClass({negate, parent, elements}, state, gen) {\n  const genClass = () => `[${negate ? '^' : ''}${elements.map(gen).join('')}]`;\n  if (!state.inCharClass) {\n    // For the outermost char class, set state\n    state.inCharClass = true;\n    const result = genClass();\n    state.inCharClass = false;\n    return result;\n  }\n  // No first element for implicit class in empty intersection like `[&&]`\n  const firstType = elements[0]?.type;\n  if (\n    !negate &&\n    firstType &&\n    (\n      ( // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n        (!state.useFlagV || !state.verbose) &&\n        parent.type === AstTypes.CharacterClass &&\n        firstType !== AstTypes.CharacterClassIntersection\n      ) ||\n      ( !state.verbose &&\n        parent.type === AstTypes.CharacterClassIntersection &&\n        // JS doesn't allow intersection with union or ranges\n        elements.length === 1 &&\n        firstType !== AstTypes.CharacterClass &&\n        firstType !== AstTypes.CharacterClassRange\n      )\n    )\n  ) {\n    // Remove unnecessary nesting; unwrap kids into the parent char class. Some basic char class\n    // optimization has already been done in the parser\n    return elements.map(gen).join('');\n  }\n  if (!state.useFlagV && parent.type === AstTypes.CharacterClass) {\n    throw new Error('Use of nested character class requires min target ES2024');\n  }\n  return genClass();\n}\n\nfunction genCharacterClassRange(node, state) {\n  const min = node.min.value;\n  const max = node.max.value;\n  const escOpts = {\n    isAfterBackref: false,\n    inCharClass: true,\n    useFlagV: state.useFlagV,\n  };\n  const minStr = getCharEscape(min, escOpts);\n  const maxStr = getCharEscape(max, escOpts);\n  const extraChars = new Set();\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n    // [TODO] Avoid duplication by considering other chars in the parent char class when expanding\n    const charsOutsideRange = getCasesOutsideCharClassRange(node);\n    const ranges = getCodePointRangesFromChars(charsOutsideRange);\n    ranges.forEach(value => {\n      extraChars.add(\n        Array.isArray(value) ?\n          `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` :\n          getCharEscape(value, escOpts)\n      );\n    });\n  }\n  // Create the range without calling `gen` on the `min`/`max` kids\n  return `${minStr}-${maxStr}${[...extraChars].join('')}`;\n}\n\nfunction genCharacterSet({kind, negate, value, key}, state) {\n  if (kind === AstCharacterSetKinds.dot) {\n    return state.currentFlags.dotAll ?\n      ((state.appliedGlobalFlags.dotAll || state.useFlagMods) ? '.' : '[^]') :\n      // Onig's only line break char is line feed, unlike JS\n      r`[^\\n]`;\n  }\n  if (kind === AstCharacterSetKinds.digit) {\n    return negate ? r`\\D` : r`\\d`;\n  }\n  if (kind === AstCharacterSetKinds.property) {\n    if (\n      state.useAppliedIgnoreCase &&\n      state.currentFlags.ignoreCase &&\n      UnicodePropertiesWithSpecificCase.has(value)\n    ) {\n      // Support for this would require heavy Unicode data. Could change e.g. `\\p{Lu}` to `\\p{LC}`\n      // if not using strict `accuracy` (since it's close but not 100%), but this wouldn't work\n      // for e.g. `\\p{Lt}`, and in any case, it's probably user error if using these case-specific\n      // props case-insensitively\n      throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n    }\n    return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : ''}${value}}`;\n  }\n  if (kind === AstCharacterSetKinds.word) {\n    return negate ? r`\\W` : r`\\w`;\n  }\n  // Kinds `hex`, `posix`, and `space` are never included in transformer output\n  throw new Error(`Unexpected character set kind \"${kind}\"`);\n}\n\nfunction genFlags(node, state) {\n  return (\n    // The transformer should never turn on the properties for flags d, g, and m since Onig doesn't\n    // have equivs. Flag m is never relied on since Onig uses different line break chars than JS\n    // (node.hasIndices ? 'd' : '') +\n    // (node.global ? 'g' : '') +\n    // (node.multiline ? 'm' : '') +\n    (state.appliedGlobalFlags.ignoreCase ? 'i' : '') +\n    (node.dotAll ? 's' : '') +\n    (node.sticky ? 'y' : '')\n    // Regex+ doesn't allow explicitly adding flags it handles implicitly, so there are no\n    // `unicode` (flag u) or `unicodeSets` (flag v) props; those flags are added separately\n  );\n}\n\nfunction genGroup({atomic, flags, parent, alternatives}, state, gen) {\n  const currentFlags = state.currentFlags;\n  if (flags) {\n    state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n  }\n  const contents = alternatives.map(gen).join('|');\n  const result = (\n    !state.verbose &&\n    alternatives.length === 1 &&\n    parent.type !== AstTypes.Quantifier &&\n    !atomic &&\n    (!state.useFlagMods || !flags)\n   ) ? contents : `(?${getGroupPrefix(atomic, flags, state.useFlagMods)}${contents})`;\n  state.currentFlags = currentFlags;\n  return result;\n}\n\nfunction genRecursion({ref}, state) {\n  const limit = state.recursionLimit;\n  // Using the syntax supported by `regex-recursion`\n  return ref === 0 ? `(?R=${limit})` : r`\\g<${ref}&R=${limit}>`;\n}\n\n/**\nGiven a `CharacterClassRange` node, returns an array of chars that are a case variant of a char in\nthe range, and aren't already in the range.\n*/\nfunction getCasesOutsideCharClassRange(node, options) {\n  const firstOnly = !!options?.firstOnly;\n  const min = node.min.value;\n  const max = node.max.value;\n  const found = [];\n  // Avoid unneeded work. Assumptions (per Unicode 16):\n  // - No case variants cross the Basic Multilingual Plane boundary\n  // - No cased chars appear beyond the Supplementary Multilingual Plane\n  if ((min < 65 && (max === 0xFFFF || max >= 0x1FFFF)) || (min === 0x10000 && max >= 0x1FFFF)) {\n    return found;\n  }\n  for (let i = min; i <= max; i++) {\n    const char = cp(i);\n    if (!charHasCase(char)) {\n      continue;\n    }\n    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter(caseOfChar => {\n      const num = caseOfChar.codePointAt(0);\n      return num < min || num > max;\n    });\n    if (charsOutsideRange.length) {\n      found.push(...charsOutsideRange);\n      if (firstOnly) {\n        break;\n      }\n    }\n  }\n  return found;\n}\n\n// This shouldn't modifiy any char that has case\nfunction getCharEscape(codePoint, {isAfterBackref, inCharClass, useFlagV}) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || (codePoint > 126 && codePoint < 160) ||\n    // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 0x3FFFF ||\n    // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    (isAfterBackref && isDigitCharCode(codePoint))\n  ) {\n    // Don't convert codePoint `0` to `\\0` since that's corruptible by following literal digits\n    return codePoint > 0xFF ?\n      `\\\\u{${codePoint.toString(16).toUpperCase()}}` :\n      `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, '0')}`;\n  }\n  const escapeChars = inCharClass ?\n    (useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars) :\n    BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? '\\\\' : '') + char;\n}\n\nfunction getCodePointRangesFromChars(chars) {\n  const codePoints = chars.map(char => char.codePointAt(0)).sort((a, b) => a - b);\n  const values = [];\n  let start = null;\n  for (let i = 0; i < codePoints.length; i++) {\n    if (codePoints[i + 1] === codePoints[i] + 1) {\n      start ??= codePoints[i];\n    } else if (start === null) {\n      values.push(codePoints[i]);\n    } else {\n      values.push([start, codePoints[i]]);\n      start = null;\n    }\n  }\n  return values;\n}\n\nfunction getGroupPrefix(atomic, flagMods, useFlagMods) {\n  if (atomic) {\n    return '>';\n  }\n  let mods = '';\n  if (flagMods && useFlagMods) {\n    const {enable, disable} = flagMods;\n    mods =\n      (enable?.ignoreCase ? 'i' : '') +\n      (enable?.dotAll ? 's' : '') +\n      (disable ? '-' : '') +\n      (disable?.ignoreCase ? 'i' : '') +\n      (disable?.dotAll ? 's' : '');\n  }\n  return `${mods}:`;\n}\n\nfunction getQuantifierStr({min, max, greedy, possessive}) {\n  let base;\n  if (!min && max === 1) {\n    base = '?';\n  } else if (!min && max === Infinity) {\n    base = '*';\n  } else if (min === 1 && max === Infinity) {\n    base = '+';\n  } else if (min === max) {\n    base = `{${min}}`;\n  } else {\n    base = `{${min},${max === Infinity ? '' : max}}`;\n  }\n  return base + (possessive ? '+' : (greedy ? '' : '?'));\n}\n\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\n\nexport {\n  generate,\n};\n","import {RegExpSubclass} from 'regex/internals';\n\n/**\n@typedef {{\n  strategy?: string | null;\n  useEmulationGroups?: boolean;\n}} EmulatedRegExpOptions\n*/\n\n/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but can be given\nresults from `toDetails` to produce the same result as `toRegExp`.\n@augments RegExp\n*/\nclass EmulatedRegExp extends RegExpSubclass {\n  /**\n  @private\n  @type {string | null}\n  */\n  #strategy;\n  /**\n  Can be used to serialize the arguments used to create the instance.\n  @type {{\n    pattern: string;\n    flags: string;\n    options: EmulatedRegExpOptions;\n  }}\n  */\n  rawArgs;\n  /**\n  @overload\n  @param {string} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */\n  /**\n  @overload\n  @param {EmulatedRegExp} pattern\n  @param {string} [flags]\n  */\n  constructor(pattern, flags, options) {\n    // Argument `options` isn't provided when regexes are copied via `new EmulatedRegExp(regexp)`,\n    // including as part of the internal handling of string methods `matchAll` and `split`\n    if (pattern instanceof RegExp) {\n      if (options) {\n        throw new Error('Cannot provide options when copying a regexp');\n      }\n      super(pattern, flags);\n      if (pattern instanceof EmulatedRegExp) {\n        this.#strategy = pattern.#strategy;\n        this.rawArgs = pattern.rawArgs;\n      } else {\n        this.#strategy = null;\n        this.rawArgs = {\n          pattern: pattern.source,\n          flags: pattern.flags,\n          options: {},\n        };\n      }\n      if (flags !== undefined) {\n        this.rawArgs.flags = flags;\n      }\n    } else {\n      const opts = {\n        strategy: null,\n        useEmulationGroups: false,\n        ...options,\n      };\n      super(pattern, flags, {useEmulationGroups: opts.useEmulationGroups});\n      this.#strategy = opts.strategy;\n      this.rawArgs = {\n        pattern,\n        flags: flags ?? '',\n        options: {\n          ...(opts.strategy && {strategy: opts.strategy}),\n          ...(opts.useEmulationGroups && {useEmulationGroups: true}),\n        },\n      };\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes. Provides special case handling\n  that requires coupling with pattern changes during transpilation.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const exec = super.exec;\n    const useLastIndex = this.global || this.sticky;\n    const pos = this.lastIndex;\n\n    // Support uncommon and otherwise-unsupported uses of `\\G`\n    if (this.#strategy === 'search_start_clip' && useLastIndex && pos) {\n      // Reset since this tests on a sliced string that we want to match at the start of\n      this.lastIndex = 0;\n      // Slicing the string can lead to mismatches when three edge cases are stacked on each other:\n      // 1. An uncommon use of `\\G` that relies on subclass-based emulation, combined with...\n      // 2. Lookbehind that searches behind the search start (not match start) position...\n      // 3. During a search when the regex's `lastIndex` isn't `0`.\n      // The `search_start_clip` strategy is therefore only allowed with strict `accuracy` when\n      // lookbehind isn't present\n      const match = exec.call(this, str.slice(pos));\n      if (match) {\n        adjustMatchDetailsForOffset(match, this, str, pos);\n        this.lastIndex += pos;\n      }\n      return match;\n    }\n\n    return exec.call(this, str);\n  }\n}\n\nfunction adjustMatchDetailsForOffset(match, re, input, offset) {\n  match.input = input;\n  match.index += offset;\n  if (re.hasIndices) {\n    const indices = match.indices;\n    for (let i = 0; i < indices.length; i++) {\n      const arr = indices[i];\n      if (arr) {\n        // Replace the array rather than updating values since the keys of `match.indices` and\n        // `match.indices.groups` share their value arrays by reference. Need to be precise in case\n        // they were previously altered separately\n        indices[i] = [arr[0] + offset, arr[1] + offset];\n      }\n    }\n    const groupIndices = indices.groups;\n    if (groupIndices) {\n      Object.keys(groupIndices).forEach(key => {\n        const arr = groupIndices[key];\n        if (arr) {\n          groupIndices[key] = [arr[0] + offset, arr[1] + offset];\n        }\n      });\n    }\n  }\n}\n\nexport {\n  EmulatedRegExp,\n};\n","import {transform} from './transform.js';\nimport {generate} from './generate.js';\nimport {Accuracy, getOptions, Target} from './options.js';\nimport {parse} from './parse.js';\nimport {EmulatedRegExp} from './subclass.js';\nimport {tokenize} from './tokenize.js';\nimport {atomic, emulationGroupMarker, possessive} from 'regex/internals';\nimport {recursion} from 'regex-recursion';\n\n// The transformation and error checking for Oniguruma's unique syntax and behavior differences\n// compared to native JS RegExp is layered into all steps of the compilation process:\n// 1. Tokenizer: Understands Oniguruma syntax, with many large and small differences from JS.\n// 2. Parser: Builds an Oniguruma AST from the tokens, with understanding of Oniguruma differences.\n// 3. Transformer: Converts the Oniguruma AST to a Regex+ AST that preserves all Oniguruma\n//    behavior. This is true even in cases of non-native-JS features that are supported by both\n//    Regex+ and Oniguruma but with subtly different behavior in each (subroutines, flag x).\n// 4. Generator: Converts the Regex+ AST to a Regex+ pattern, flags, and options.\n// 5. Compiler: Components of the Regex+ libray are used to transpile several remaining features\n//    that aren't native to JS (atomic groups, possessive quantifiers, recursion). Regex+ uses a\n//    strict superset of JS RegExp syntax, so using it allows this library to benefit from not\n//    reinventing the wheel for complex features that Regex+ already knows how to transpile to JS.\n\n/**\n@typedef {{\n  accuracy?: keyof Accuracy;\n  avoidSubclass?: boolean;\n  flags?: string;\n  global?: boolean;\n  hasIndices?: boolean;\n  rules?: {\n    allowOrphanBackrefs?: boolean;\n    asciiWordBoundaries?: boolean;\n    captureGroup?: boolean;\n    recursionLimit?: number;\n    singleline?: boolean;\n  };\n  target?: keyof Target;\n  verbose?: boolean;\n}} OnigurumaToEsOptions\n*/\n\n/**\nAccepts an Oniguruma pattern and returns the details needed to construct an equivalent JavaScript `RegExp`.\n@param {string} pattern Oniguruma regex pattern.\n@param {OnigurumaToEsOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n  options?: import('./subclass.js').EmulatedRegExpOptions;\n}}\n*/\nfunction toDetails(pattern, options) {\n  const opts = getOptions(options);\n  const avoidSubclass = opts.avoidSubclass;\n  const tokenized = tokenize(pattern, opts.flags, {\n    captureGroup: opts.rules.captureGroup,\n    singleline: opts.rules.singleline,\n  });\n  const onigurumaAst = parse(tokenized, {\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    verbose: opts.verbose,\n  });\n  const regexAst = transform(onigurumaAst, {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n    avoidSubclass,\n    bestEffortTarget: opts.target,\n  });\n  const generated = generate(regexAst, opts);\n  const pluginData = {useEmulationGroups: !avoidSubclass};\n  const result = {\n    pattern: atomic(possessive(recursion(generated.pattern, pluginData)), pluginData),\n    flags: `${opts.hasIndices ? 'd' : ''}${opts.global ? 'g' : ''}${generated.flags}${generated.options.disable.v ? 'u' : 'v'}`,\n  };\n  const useEmulationGroups = !avoidSubclass && result.pattern.includes(emulationGroupMarker);\n  const strategy = regexAst._strategy;\n  if (useEmulationGroups || strategy) {\n    result.options = {\n      ...(strategy && {strategy}),\n      ...(useEmulationGroups && {useEmulationGroups}),\n    };\n  }\n  return result;\n}\n\n/**\nReturns an Oniguruma AST generated from an Oniguruma pattern.\n@param {string} pattern Oniguruma regex pattern.\n@param {{\n  flags?: string;\n  rules?: {\n    captureGroup?: boolean;\n  };\n}} [options]\n@returns {import('./parse.js').OnigurumaAst}\n*/\nfunction toOnigurumaAst(pattern, options) {\n  const flags = options?.flags ?? '';\n  const captureGroup = options?.rules?.captureGroup ?? false;\n  return parse(tokenize(pattern, flags, {captureGroup}));\n}\n\n// // Returns a Regex+ AST generated from an Oniguruma pattern\n// function toRegexAst(pattern, options) {\n//   return transform(toOnigurumaAst(pattern, options));\n// }\n\n/**\nAccepts an Oniguruma pattern and returns an equivalent JavaScript `RegExp`.\n@param {string} pattern Oniguruma regex pattern.\n@param {OnigurumaToEsOptions} [options]\n@returns {RegExp | EmulatedRegExp}\n*/\nfunction toRegExp(pattern, options) {\n  const result = toDetails(pattern, options);\n  if (result.options) {\n    return new EmulatedRegExp(result.pattern, result.flags, result.options);\n  }\n  return new RegExp(result.pattern, result.flags);\n}\n\nexport {\n  EmulatedRegExp,\n  toDetails,\n  toOnigurumaAst,\n  // toRegexAst,\n  toRegExp,\n};\n"],"names":["range","raw","value","path","key","possessive","atomic","node","recursion","atomic","possessive","emulationGroupMarker"],"mappings":"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","debugId":null}}]
}